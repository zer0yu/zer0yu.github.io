<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> SSRF之如何bypass filter_var(),preg_match()and parse_url() · Z3R0YU</title><meta name="description" content="SSRF之如何bypass filter_var(),preg_match()and parse_url() - z3r0yu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://zer0yu.github.io/atom.xml" title="Z3R0YU"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/Z3r0yu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/zer0yu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">SSRF之如何bypass filter_var(),preg_match()and parse_url()</h1><div class="post-info">Mar 10, 2018</div><div class="post-content"><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>​    前几天我读了两篇非常棒的论文：第一篇是发表在blackhat.com上的“A New Era of SSRF ”，讲述的是不同编程语言的SSRF问题；第二篇是由Positive Technology发表的一篇名为“PHP Wrapper” 的论文，它主要讲述的是如何以多种不同的方式使用PHP Wrapper来绕过过滤器以及受过滤的输入（您可以在结尾处找到这两个链接）。</p>
<p>​    在本文中，我将深入介绍一些SSRF技术，您可以使用这些技术攻击那些使用filter_var()或preg_match()等过滤器的PHP脚本，并且可以使用curl或file或file_get_contents()来获取HTTP内容。</p>
<p>对于抓娃娃机的一种典型的SSRF攻击</p>
<p>引用OWASP上的定义：</p>
<p>​    在服务器端请求伪造（SSRF）攻击中，攻击者可以利用服务器上的功能来读取或更新内网资源。 攻击者可以配置或更改与服务器上运行的代码有关的URL链接来读取或提交数据，此外，通过精心构造的URL，攻击者可以读取服务器配置，例如AWS元数据，连接到启用http数据库的内部服务器中抑或是对内部的非公开服务发起post请求。</p>
<h3 id="0x09-对URL解析函数进行SSRF"><a href="#0x09-对URL解析函数进行SSRF" class="headerlink" title="0x09 对URL解析函数进行SSRF"></a>0x09 对URL解析函数进行SSRF</h3><p>​    <code>parse_url()</code>是用于解析一个 URL 并返回一个包含在 URL 中出现的各种组成部分关联数组的PHP函数。这个函数并不是要验证给定的URL，它只是将它分解成上面列出的部分。 部分网址也可以作为<code>parse_url()</code>的输入并被尽可能的正确解析。</p>
<p>​    在一个PHP脚本中去bypass一个用于将部分字符串转换为一个变量的的正则表达式是我们最喜欢研究的技术之一。这项工作是否成功最终将由Bash来认定。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0://evil$google.com</div></pre></td></tr></table></figure>
<p>使用“Bash中变量的语法”来绕过过滤器并利用SSRF</p>
<p>​    使用这种方式，我让bash将$google分析为一个空变量，并且使用curl请求了evil <empty> .com。 这是不是很酷？:)</empty></p>
<p>​    然而这只发生在curl语法中。 实际上，正如上面的屏幕截图所示，由parse_url()解析的主机名仍然是 evil\$google.com。 \$ google变量并没有被解释。 只有当使用了exec()函数而且脚本又使用$r[‘host’]来创建一个curl HTTP请求时，Bash才会将其转换为一个空变量。</p>
<p>​    显然，这个工作只是为了防止PHP脚本使用exec()或system()函数来调用像curl，wget之类的系统命令。</p>
<h3 id="0x10-win环境中data-之于XSS"><a href="#0x10-win环境中data-之于XSS" class="headerlink" title="0x10  win环境中data://之于XSS"></a>0x10  win环境中data://之于XSS</h3><p>​    另一个使用file_get_contents()代替PHP使用system()或exec()调用curl的例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">   <span class="keyword">echo</span> <span class="string">"Argument: "</span>.$argv[<span class="number">1</span>].<span class="string">"\n"</span>;</div><div class="line">   <span class="comment">// check if argument is a valid URL</span></div><div class="line">   <span class="keyword">if</span>(filter_var($argv[<span class="number">1</span>], FILTER_VALIDATE_URL)) &#123;</div><div class="line">      <span class="comment">// parse URL</span></div><div class="line">      $r = parse_url($argv[<span class="number">1</span>]);</div><div class="line">      print_r($r);</div><div class="line">      <span class="comment">// check if host ends with google.com</span></div><div class="line">      <span class="keyword">if</span>(preg_match(<span class="string">'/google\.com$/'</span>, $r[<span class="string">'host'</span>])) &#123;</div><div class="line">         <span class="comment">// get page from URL</span></div><div class="line">         $a = file_get_contents($argv[<span class="number">1</span>]);</div><div class="line">         <span class="keyword">echo</span>($a);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">echo</span> <span class="string">"Error: Host not allowed"</span>;</div><div class="line">      &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">echo</span> <span class="string">"Error: Invalid URL"</span>;</div><div class="line">   &#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>​    正如你所见，file_get_contents()在使用之前描述的相同技术验证之后使用了原始参数变量。 让我们尝试通过注入一些文本来修改响应主体，如“I Love PHP”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data://text/plain;base64,SSBsb3ZlIFBIUAo=google.com</div></pre></td></tr></table></figure>
<p>尝试控制响应主体</p>
<p>​    parse_url()不允许将文本设置为请求主机，并且它返回了“not allowed host”正确拒绝解析。不要绝望！ 有一件事我们可以做，我们可以尝试将某些东西“注入”URI的MIME类型部分……因为在这种情况下，PHP不关心MIME类型…也是，又有谁在乎呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data://google.com/plain;base64,SSBsb3ZlIFBIUAo=</div></pre></td></tr></table></figure>
<p>向响应体注入 “I love PHP”</p>
<p>接下来进行XSS攻击便是小菜一碟了…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data://text.google.com/plain;base64,&lt;...b64...&gt;</div></pre></td></tr></table></figure>
<p>使用之前描述的技术进行简单的XSS</p>
<p>以上便是全部，感谢观看！</p>
<h3 id="0x11-Links"><a href="#0x11-Links" class="headerlink" title="0x11 Links"></a>0x11 Links</h3><p>Positive Technologies: “PHP Wrappers”<a href="http://bit.ly/2lXk1e8" target="_blank" rel="external"> http://bit.ly/2lXk1e8</a><br>Orange Tsai: “A new era of SSRF” <a href="http://ubm.io/2FdUu9F" target="_blank" rel="external">http://ubm.io/2FdUu9F</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/06/introduction-to-ssrf/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://zer0yu.github.io">z3r0yu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>